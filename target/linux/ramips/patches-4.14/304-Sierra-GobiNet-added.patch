From 4abd9c584f3f328f9de06db8adebdb0ee8254d3f Mon Sep 17 00:00:00 2001
From: fengmushu <fengmushu@gmail.com>
Date: Sun, 27 Jan 2019 13:22:14 +0800
Subject: [PATCH] Sierra GobiNet added

---
 drivers/net/usb/GobiSerial.c     | 1811 ++++++
 drivers/net/usb/GobiUSBNet.c     | 3579 +++++++++++
 drivers/net/usb/Kconfig          |   12 +
 drivers/net/usb/Makefile         |    4 +
 drivers/net/usb/QMI.c            | 2232 +++++++
 drivers/net/usb/QMI.h            |  518 ++
 drivers/net/usb/QMIDevice.c      | 9860 ++++++++++++++++++++++++++++++
 drivers/net/usb/QMIDevice.h      |  550 ++
 drivers/net/usb/Readme.txt       |   78 +
 drivers/net/usb/Structs.h        |  599 ++
 drivers/net/usb/gobi_usbnet.h    |   51 +
 drivers/net/usb/usbnet_2_6_32.c  |  396 ++
 drivers/net/usb/usbnet_2_6_35.c  |  400 ++
 drivers/net/usb/usbnet_3_0_6.c   |  432 ++
 drivers/net/usb/usbnet_3_10_21.c |  457 ++
 drivers/net/usb/usbnet_3_12_xx.c |  513 ++
 drivers/net/usb/usbnet_4_4_xx.c  |  514 ++
 drivers/usb/serial/qcserial.c    |    9 +-
 18 files changed, 22013 insertions(+), 2 deletions(-)
 create mode 100644 drivers/net/usb/GobiSerial.c
 create mode 100644 drivers/net/usb/GobiUSBNet.c
 create mode 100644 drivers/net/usb/QMI.c
 create mode 100644 drivers/net/usb/QMI.h
 create mode 100644 drivers/net/usb/QMIDevice.c
 create mode 100644 drivers/net/usb/QMIDevice.h
 create mode 100644 drivers/net/usb/Readme.txt
 create mode 100644 drivers/net/usb/Structs.h
 create mode 100644 drivers/net/usb/gobi_usbnet.h
 create mode 100644 drivers/net/usb/usbnet_2_6_32.c
 create mode 100644 drivers/net/usb/usbnet_2_6_35.c
 create mode 100644 drivers/net/usb/usbnet_3_0_6.c
 create mode 100644 drivers/net/usb/usbnet_3_10_21.c
 create mode 100644 drivers/net/usb/usbnet_3_12_xx.c
 create mode 100644 drivers/net/usb/usbnet_4_4_xx.c

diff --git a/drivers/net/usb/GobiSerial.c b/drivers/net/usb/GobiSerial.c
new file mode 100644
index 00000000..81b89c4d
--- /dev/null
+++ b/drivers/net/usb/GobiSerial.c
@@ -0,0 +1,1811 @@
+/*===========================================================================
+FILE:
+   GobiSerial.c
+
+DESCRIPTION:
+   Linux Qualcomm Serial USB driver Implementation
+
+PUBLIC DRIVER FUNCTIONS:
+   GobiProbe
+   GobiOpen
+   GobiClose
+   GobiReadBulkCallback
+   GobiSerialSuspend
+   GobiSerialResume (if kernel is less than 2.6.24)
+
+Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Code Aurora Forum nor
+      the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+Alternatively, provided that this notice is retained in full, this software
+may be relicensed by the recipient under the terms of the GNU General Public
+License version 2 ("GPL") and only version 2, in which case the provisions of
+the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
+software under the GPL, then the identification text in the MODULE_LICENSE
+macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
+recipient changes the license terms to the GPL, subsequent recipients shall
+not relicense under alternate licensing terms, including the BSD or dual
+BSD/GPL terms.  In addition, the following license statement immediately
+below and between the words START and END shall also then apply when this
+software is relicensed under the GPL:
+
+START
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License version 2 and only version 2 as
+published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+END
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+==========================================================================*/
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/usb.h>
+#include <linux/usb/serial.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/serial.h>
+
+/* Determine if we are in a particular kernel series */
+#define KERNEL_SERIES(x, y) \
+	((LINUX_VERSION_CODE >> 8) == (KERNEL_VERSION( x,y,0 ) >> 8))
+
+//---------------------------------------------------------------------------
+// Global variables and definitions
+//---------------------------------------------------------------------------
+
+// Version Information
+#define DRIVER_VERSION "2018-12-21/SWI_2.36"
+#define DRIVER_AUTHOR "Qualcomm Innovation Center"
+#define DRIVER_DESC "GobiSerial"
+
+#define NUM_BULK_EPS         1
+#define MAX_BULK_EPS         6
+
+#define SWIMS_USB_REQUEST_SetHostPower	0x09
+#define SET_CONTROL_LINE_STATE_REQUEST_TYPE        0x21
+#define SET_CONTROL_LINE_STATE_REQUEST             0x22
+#define CONTROL_DTR                     0x01
+#define CONTROL_RTS                     0x02
+
+
+// Debug flag
+static int debug;
+// flow control flag
+static int flow_control = 1;
+// allow port open to success even when GPS control message failed
+static int ignore_gps_start_error = 1;
+#define OPEN_GPS_DELAY_IN_SECOND 10
+// Open GPS port delay 
+static int delay_open_gps_port = OPEN_GPS_DELAY_IN_SECOND;
+// Number of serial interfaces
+static int nNumInterfaces;
+// Enable Zero Lenght Payload on USB3 in QDL Mode
+static int iusb3_zlp_enable = 1;
+
+// Global pointer to usb_serial_generic_close function
+// This function is not exported, which is why we have to use a pointer
+// instead of just calling it.
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,26 ))
+   void (* gpClose)(
+      struct usb_serial_port *,
+      struct file * );
+#elif (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,30 ))
+   void (* gpClose)(
+      struct tty_struct *,
+      struct usb_serial_port *,
+      struct file * );
+#else // > 2.6.30
+   void (* gpClose)( struct usb_serial_port * );
+#endif
+
+// DBG macro
+#define DBG( format, arg... ) \
+   if (debug == 1)\
+   { \
+      printk( KERN_INFO "GobiSerial::%s " format, __FUNCTION__, ## arg ); \
+   } \
+
+struct gobi_serial_intf_private {
+       spinlock_t susp_lock;
+       unsigned int suspended:1;
+       struct sierra_port_private *pPortdata;
+};
+
+/*=========================================================================*/
+// Function Prototypes
+/*=========================================================================*/
+
+// Attach to correct interfaces
+static int GobiProbe(
+   struct usb_serial * pSerial,
+   const struct usb_device_id * pID );
+
+// Start GPS if GPS port, run usb_serial_generic_open
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,26 ))
+   int GobiOpen(
+      struct usb_serial_port *   pPort,
+      struct file *              pFilp );
+#elif (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,31 ))
+   int GobiOpen(
+      struct tty_struct *        pTTY,
+      struct usb_serial_port *   pPort,
+      struct file *              pFilp );
+#else // > 2.6.31
+   int GobiOpen(
+      struct tty_struct *        pTTY,
+      struct usb_serial_port *   pPort );
+#endif
+
+// Stop GPS if GPS port, run usb_serial_generic_close
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,26 ))
+   void GobiClose(
+      struct usb_serial_port *,
+      struct file * );
+#elif (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,30 ))
+   void GobiClose(
+      struct tty_struct *,
+      struct usb_serial_port *,
+      struct file * );
+#else // > 2.6.30
+   void GobiClose( struct usb_serial_port * );
+#endif
+
+// Read data from USB, push to TTY and user space
+static void GobiReadBulkCallback( struct urb * pURB );
+
+// Set reset_resume flag
+int GobiSerialSuspend(
+   struct usb_interface *     pIntf,
+   pm_message_t               powerEvent );
+int GobiUSBSerialSuspend(struct usb_serial *serial, pm_message_t message);
+int GobiUSBSerialResume(struct usb_serial *serial);
+int GobiUSBSerialResetResume(struct usb_serial *serial);
+void GobiUSBSerialDisconnect(struct usb_serial * serial);
+static int Gobi_write(struct tty_struct *tty, struct usb_serial_port *port,
+               const unsigned char *buf, int count);
+bool IsDeviceUnbinding(struct usb_serial *serial);
+void GobiUSBSendZeroConfigMsg(struct usb_serial *serial);
+int gobi_usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,
+   void *data, int len, int *actual_length,
+   int timeout);
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,23 ))
+
+// Restart URBs killed during usb_serial_suspend
+int GobiSerialResume( struct usb_interface * pIntf );
+
+#endif
+void stop_read_write_urbs(struct usb_serial *serial);
+
+
+#define MDM9X15_DEVICE(vend, prod) \
+	USB_DEVICE(vend, prod), \
+	.driver_info = BIT(1) | BIT(8) | BIT(10) | BIT(11)
+
+#define G3K_DEVICE(vend, prod) \
+	USB_DEVICE(vend, prod), \
+	.driver_info = BIT(0)
+
+#if ((KERNEL_SERIES( 3,4 ) && LINUX_VERSION_CODE >= KERNEL_VERSION( 3,4,34 )) || \
+     (KERNEL_SERIES( 3,2 ) && LINUX_VERSION_CODE >= KERNEL_VERSION( 3,2,0 )) || \
+     (KERNEL_SERIES( 3,5 ) && LINUX_VERSION_CODE >= KERNEL_VERSION( 3,5,0 )) || \
+     (KERNEL_SERIES( 3,7 ) && LINUX_VERSION_CODE >= KERNEL_VERSION( 3,7,10 )) || \
+     (KERNEL_SERIES( 3,8 ) && LINUX_VERSION_CODE >= KERNEL_VERSION( 3,8,1) ) || \
+     (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,8,1) ))
+/* workaround for upstream commit b2ca699076573c94fee9a73cb0d8645383b602a0 */
+#warning "Assuming disc_mutex is locked external to the module"
+static inline void Gobi_lock_disc_mutex(struct usb_serial *serial) {
+   if (LINUX_VERSION_CODE < KERNEL_VERSION( 3,12,0) )
+   {
+      WARN_ON(!mutex_is_locked(&serial->disc_mutex));
+   }
+}
+static inline void Gobi_unlock_disc_mutex(struct usb_serial *serial) {}
+#else
+/* use the legacy method of locking disc_mutex in this driver */
+#warning "Using legacy method of locking disc_mutex"
+static inline void Gobi_lock_disc_mutex(struct usb_serial *serial) {
+   mutex_lock(&serial->disc_mutex);
+}
+static inline void Gobi_unlock_disc_mutex(struct usb_serial *serial) {
+   mutex_unlock(&serial->disc_mutex);
+}
+#endif
+
+/*=========================================================================*/
+// Qualcomm Gobi 3000 VID/PIDs
+/*=========================================================================*/
+static struct usb_device_id GobiVIDPIDTable[] =
+{
+   { USB_DEVICE(0x05c6, 0x920c) },   // Gobi 3000 QDL
+   { USB_DEVICE(0x05c6, 0x920d) },   // Gobi 3000 Composite
+   /* Sierra Wireless QMI VID/PID */
+   { USB_DEVICE(0x1199, 0x68A2),
+      .driver_info = BIT(8) | BIT(19) | BIT(20) |
+                     BIT(10) | BIT(11) /* in case a MDM9x15 switched to 0x68a2 */
+   },
+   /* Sierra Wireless QMI MC78/WP7/AR7 */
+   { USB_DEVICE(0x1199, 0x68C0),
+      /* blacklist the interface */
+      /* whitelist interfaces 5 for raw data */
+      .driver_info = BIT(1) | BIT(6) | BIT(8) | BIT(10) | BIT(11) | BIT(12) | BIT(13)
+   },
+
+   /* Sierra Wireless QMI MC74xx/EM74xx */
+   { USB_DEVICE(0x1199, 0x9071),
+      /* blacklist the interface */
+      .driver_info = BIT(1) | BIT(4) | BIT(5) | BIT(6) | BIT(8) | BIT(10) | BIT(11) | BIT(12) | BIT(13)
+   },
+
+   /* Sierra Wireless QMI MC74xx/EM74xx */
+   { USB_DEVICE(0x1199, 0x9070),
+      /* blacklist the interface */
+      .driver_info = BIT(1) | BIT(4) | BIT(5) | BIT(6) | BIT(8) | BIT(10) | BIT(11) | BIT(12) | BIT(13)
+   },
+
+   /* Sierra Wireless QMI AR759x */
+   { USB_DEVICE(0x1199, 0x9100),
+      /* blacklist the interface */
+      /* whitelist interfaces 5 & 6 for raw data and open sim resp. */
+      .driver_info = BIT(1) | BIT(8) | BIT(10) | BIT(11) | BIT(12) | BIT(13)
+   },
+   
+   /* Sierra Wireless QMI AR758x */
+   { USB_DEVICE(0x1199, 0x9102),
+      /* blacklist the interface */
+      /* whitelist interfaces 5 & 6 for raw data and open sim resp. */
+      .driver_info = BIT(1) | BIT(8) | BIT(10) | BIT(11) | BIT(12) | BIT(13)
+   },
+   
+   /* Sierra Wireless QMI AR759x */
+   { USB_DEVICE(0x1199, 0x9110),
+      /* blacklist the interface */
+      /* whitelist interfaces 5 & 6 for raw data and open sim resp. */
+      .driver_info = BIT(1) | BIT(8) | BIT(10) | BIT(11) | BIT(12) | BIT(13)
+   },
+   
+   /* Sierra Wireless QMI MC75xx/EM75xx BOOT*/
+   { USB_DEVICE(0x1199, 0x9090),
+      /* blacklist the interface */
+      .driver_info = BIT(1) | BIT(5) | BIT(6) | BIT(8) | BIT(10) | BIT(11) | BIT(12) | BIT(13)
+   },
+   { USB_DEVICE(0x1199, 0x9091),
+      /* blacklist the interface */
+      .driver_info = BIT(1) | BIT(5) | BIT(6) | BIT(8) | BIT(10) | BIT(11) | BIT(12) | BIT(13)
+   }, 
+   { USB_DEVICE(0x1199, 0x90b0),
+      /* blacklist the interface */
+      .driver_info = BIT(1) | BIT(5) | BIT(6) | BIT(8) | BIT(10) | BIT(11) | BIT(12) | BIT(13)
+   },
+   { USB_DEVICE(0x1199, 0x90b1),
+      /* blacklist the interface */
+      .driver_info = BIT(1) | BIT(5) | BIT(6) | BIT(8) | BIT(10) | BIT(11) | BIT(12) | BIT(13)
+   },
+   { USB_DEVICE(0x1199, 0x90c0),
+      /* blacklist the interface */
+      .driver_info = BIT(1) | BIT(5) | BIT(6) | BIT(8) | BIT(10) | BIT(11) | BIT(12) | BIT(13)
+   },
+   { USB_DEVICE(0x1199, 0x90c1),
+      /* blacklist the interface */
+      .driver_info = BIT(1) | BIT(5) | BIT(6) | BIT(8) | BIT(10) | BIT(11) | BIT(12) | BIT(13)
+   },
+
+   {G3K_DEVICE(0x1199, 0x9010)},
+   {G3K_DEVICE(0x1199, 0x9011)},
+   {G3K_DEVICE(0x1199, 0x9012)},
+   {G3K_DEVICE(0x1199, 0x9013)},
+   {G3K_DEVICE(0x1199, 0x9014)},
+   {G3K_DEVICE(0x1199, 0x9015)},
+   {G3K_DEVICE(0x1199, 0x9018)},
+   {G3K_DEVICE(0x1199, 0x9019)},
+   {G3K_DEVICE(0x03F0, 0x361D)},
+   {G3K_DEVICE(0x03F0, 0x371D)},
+
+   {MDM9X15_DEVICE(0x1199, 0x9040)},
+   {MDM9X15_DEVICE(0x1199, 0x9041)},
+   {MDM9X15_DEVICE(0x1199, 0x9051)},
+   {MDM9X15_DEVICE(0x1199, 0x9053)},
+   {MDM9X15_DEVICE(0x1199, 0x9054)},
+   {MDM9X15_DEVICE(0x1199, 0x9055)},
+   {MDM9X15_DEVICE(0x1199, 0x9056)},
+   {MDM9X15_DEVICE(0x1199, 0x9060)},
+   {MDM9X15_DEVICE(0x1199, 0x9061)},
+
+   { }  // Terminating entry
+};
+MODULE_DEVICE_TABLE( usb, GobiVIDPIDTable );
+
+enum {
+    eSendUnknown=-1,
+    eSendStart=0,
+    eSendEnd=1,
+};
+/* per port private data */
+struct sierra_port_private {
+   /* Settings for the port */
+   int rts_state;    /* Handshaking pins (outputs) */
+   int dtr_state;
+   int isClosing;
+   int iGPSStartState;
+   unsigned long ulExpires;
+   int iUsb3ZlpEnable;
+};
+
+int gobi_usb_serial_generic_resume(struct usb_interface *intf)
+{
+   struct usb_serial *serial = usb_get_intfdata(intf);
+   return usb_serial_generic_resume(serial);
+}
+
+/*=========================================================================*/
+// Struct usb_serial_driver
+// Driver structure we register with the USB core
+/*=========================================================================*/
+static struct usb_driver GobiDriver =
+{
+   .name       = "GobiSerial",
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 3,5,0 ))
+   .probe      = usb_serial_probe,
+   .disconnect = usb_serial_disconnect,
+#endif
+   .id_table   = GobiVIDPIDTable,
+#ifdef CONFIG_PM
+   .suspend    = usb_serial_suspend,
+   .resume = gobi_usb_serial_generic_resume,
+   .reset_resume = gobi_usb_serial_generic_resume,
+   .supports_autosuspend = true,
+#else
+   .suspend    = NULL,
+   .resume     = NULL,
+   .supports_autosuspend = false,
+#endif
+};
+
+static int Gobi_calc_interface(struct usb_serial *serial)
+{
+   int interface;
+   struct usb_interface *p_interface;
+   struct usb_host_interface *p_host_interface;
+   dev_dbg(&serial->dev->dev, "%s\n", __func__);
+
+   /* Get the interface structure pointer from the serial struct */
+   p_interface = serial->interface;
+
+   /* Get a pointer to the host interface structure */
+   p_host_interface = p_interface->cur_altsetting;
+
+   /* read the interface descriptor for this active altsetting
+    * to find out the interface number we are on
+    */
+   interface = p_host_interface->desc.bInterfaceNumber;
+
+   return interface;
+}
+
+static int Gobi_send_setup(struct usb_serial_port *port)
+{
+   struct usb_serial *serial = port->serial;
+   struct sierra_port_private *portdata;
+   __u16 interface = 0;
+   int val = 0;
+   int retval;
+
+   dev_dbg(&port->dev, "%s\n", __func__);
+
+   portdata = usb_get_serial_port_data(port);
+
+   if (portdata->dtr_state)
+      val |= CONTROL_DTR;
+   if (portdata->rts_state)
+      val |= CONTROL_RTS;
+
+   /* obtain interface for usb control message below */
+   if (serial->num_ports == 1) {
+      interface = Gobi_calc_interface(serial);
+   }
+   else {
+      dev_err(&port->dev, 
+            "flow control is not supported for %d serial port\n",
+            serial->num_ports);
+      return -ENODEV;
+   }
+
+   retval = usb_autopm_get_interface(serial->interface);
+   if (retval < 0)
+   {
+      return retval;
+   }
+
+   retval = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
+         SET_CONTROL_LINE_STATE_REQUEST,
+         SET_CONTROL_LINE_STATE_REQUEST_TYPE,
+         val, interface, NULL, 0, USB_CTRL_SET_TIMEOUT);
+   usb_autopm_put_interface(serial->interface);
+
+   return retval;
+}
+
+static void Gobi_dtr_rts(struct usb_serial_port *port, int on)
+{
+   struct usb_serial *serial = port->serial;
+   struct sierra_port_private *portdata;
+
+   portdata = usb_get_serial_port_data(port);
+   portdata->rts_state = on;
+   portdata->dtr_state = on;
+
+   /* only send down the usb control message if enabled */
+   if (serial->dev && flow_control) {
+      Gobi_lock_disc_mutex(serial);
+      if (!serial->disconnected)
+      {
+         Gobi_send_setup(port);
+      }
+      Gobi_unlock_disc_mutex(serial);
+   }
+}
+
+/*
+ * swiState
+ * 0x0000   Host device is awake
+ * 0x0001   Host device is suspended
+ */
+static int set_power_state(struct usb_device *udev, __u16 swiState)
+{
+    int result;
+    dev_dbg(&udev->dev, "%s\n", __func__);
+    result = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+            SWIMS_USB_REQUEST_SetHostPower, /* __u8 request      */
+            USB_TYPE_VENDOR,                /* __u8 request type */
+            swiState,                       /* __u16 value       */
+            0,                              /* __u16 index       */
+            NULL,                           /* void *data        */
+            0,                              /* __u16 size        */
+            USB_CTRL_SET_TIMEOUT);          /* int timeout       */
+    return result;
+}
+
+static int Gobi_startup(struct usb_serial *serial)
+{
+   struct usb_serial_port *port = NULL;
+   struct sierra_port_private *portdata = NULL;
+   struct gobi_serial_intf_private *intfdata = NULL;
+   int i;
+
+   dev_dbg(&serial->dev->dev, "%s\n", __func__);
+
+   if (serial->num_ports) {
+      /* Note: One big piece of memory is allocated for all ports 
+       * private data in one shot. This memory is split into equal 
+       * pieces for each port. 
+       */
+      portdata = (struct sierra_port_private *)kzalloc
+         (sizeof(*portdata) * serial->num_ports, GFP_KERNEL);
+      if (!portdata) {
+         dev_dbg(&serial->dev->dev, "%s: No memory!\n", __func__);
+         return -ENOMEM;
+      }
+   }
+   intfdata = usb_get_serial_data(serial);
+   if(intfdata)
+   {
+      intfdata->pPortdata = portdata;
+   }
+   else
+   {
+      kfree(portdata);
+      return -ENOMEM;
+   }
+   /* Now setup per port private data */
+   for (i = 0; i < serial->num_ports; i++, portdata++) {
+      struct sierra_port_private *privatedata;
+      privatedata = portdata;
+      privatedata->iGPSStartState = eSendUnknown;
+      privatedata->ulExpires = jiffies + msecs_to_jiffies(delay_open_gps_port*1000);
+      port = serial->port[i];
+      privatedata->iUsb3ZlpEnable = iusb3_zlp_enable;
+      /* Set the port private data pointer */
+      usb_set_serial_port_data(port, portdata);
+   }
+
+   return 0;
+}
+
+int Gobi_portremove(struct usb_serial_port *port)
+{
+   
+   struct sierra_port_private *portdata = usb_get_serial_port_data(port);
+   struct gobi_serial_intf_private *intfdata = NULL;
+   u8 port_number;
+   usb_set_serial_port_data(port, NULL);
+   intfdata = usb_get_serial_data(port->serial);
+   #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,11,0 ))
+   port_number = (u8)port->port_number;
+   #else
+   port_number = (u8)port->number;
+   #endif
+   if(port_number==0)
+   {
+      if(intfdata)
+      {
+         intfdata->pPortdata = NULL;
+      }
+      if(portdata)
+      kfree(portdata);
+   }
+   return 0;
+}
+
+void GobiUSBSendZeroConfigMsg(struct usb_serial *serial)
+{
+   int ret = 0;
+   DBG("\n");
+   if(!serial)
+   {
+      return ;
+   }
+   if(!serial->dev)
+   {
+      return ;
+   }
+   ret = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
+   USB_REQ_SET_CONFIGURATION, 0,
+   serial->dev->actconfig->desc.bConfigurationValue, 0,
+   NULL, 0, USB_CTRL_SET_TIMEOUT);
+   if (ret < 0) 
+   {
+      printk( KERN_INFO "Send ZERO CONF FAIL!\n" );
+   }
+}
+
+bool IsDeviceUnbinding(struct usb_serial *serial)
+{
+   struct usb_device *udev = NULL;
+   struct usb_interface *interface = NULL;
+   DBG("\n");
+   if((!serial)||
+      (!serial->interface) ||
+      (!serial->interface->cur_altsetting))
+   {
+      return false;
+   }
+   #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,33 ))
+   if(serial->interface->resetting_device)
+   {
+      return false;
+   }
+   #endif
+   if (serial->num_ports < 1) 
+   {
+      return false;
+   }
+   interface = serial->interface;
+   if(!serial->dev)
+   {
+      return false;
+   }
+   udev = serial->dev;
+   if((!udev)||
+      (!udev->parent))
+   {
+      return false;
+   }
+   if ((udev->parent->state == USB_STATE_NOTATTACHED )||
+      (udev->state == USB_STATE_NOTATTACHED ))
+   {
+      return false;
+   }
+   if(interface->cur_altsetting->desc.bInterfaceNumber!=0)
+   {
+      return false;
+   }      
+   if(interface->condition == USB_INTERFACE_UNBINDING)
+   {
+      return true;
+   }
+   return false;
+}
+
+static void Gobi_release(struct usb_serial *serial)
+{
+   int i;
+   struct usb_serial_port *port;
+   struct sierra_port_private *portdata;
+   struct gobi_serial_intf_private *intfdata = NULL;
+   if(!serial)
+      return ;
+   if(!serial->dev)
+      return ;
+   dev_dbg(&serial->dev->dev, "%s\n", __func__);
+   //Set USB CONFIGURATION to ZERO
+   if(IsDeviceUnbinding(serial))
+   {
+      GobiUSBSendZeroConfigMsg(serial);
+   }
+   intfdata = usb_get_serial_data(serial);
+   usb_set_serial_data(serial,NULL);
+   stop_read_write_urbs(serial);
+   if (serial->num_ports > 0) {
+      port = serial->port[0];
+      if (port)
+      {
+         /* Note: The entire piece of memory that was allocated 
+          * in the startup routine can be released by passing
+          * a pointer to the beginning of the piece.
+          * This address corresponds to the address of the chunk
+          * that was given to port 0.
+          */
+         portdata = usb_get_serial_port_data(port);
+         usb_set_serial_port_data(port, NULL);
+         if(portdata)
+         {
+            intfdata->pPortdata = NULL;
+            kfree(portdata);
+         }
+         else
+         {
+            if(intfdata)
+            {
+               portdata = intfdata->pPortdata;
+               if(portdata)
+               {
+                  kfree(portdata);
+               }
+               intfdata->pPortdata = NULL;
+            }
+         }
+      }
+   }
+
+   for (i = 0; i < serial->num_ports; ++i) {
+      port = serial->port[i];
+      if (!port)
+      {
+         continue;
+      }
+      usb_set_serial_port_data(port, NULL);
+   }
+   if(intfdata)
+   {
+      kfree(intfdata);
+   }
+}
+
+/*=========================================================================*/
+// Struct usb_serial_driver
+/*=========================================================================*/
+static struct usb_serial_driver gGobiDevice =
+{
+   .driver =
+   {
+      .owner     = THIS_MODULE,
+      .name      = "GobiSerial driver",
+   },
+   .description         = "GobiSerial",
+   .id_table            = GobiVIDPIDTable,
+   .usb_driver          = &GobiDriver,
+   .num_ports           = NUM_BULK_EPS,
+   .probe               = GobiProbe,
+   .open                = GobiOpen,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,25 ))
+   .num_interrupt_in    = NUM_DONT_CARE,
+   .num_bulk_in         = 1,
+   .num_bulk_out        = 1,
+#endif
+   .write                 = Gobi_write,
+
+   /* TODO PowerPC RD1020DB kernel 3.0 support
+    */
+   /* register read_bulk_callback in order to resume upon -EPROTO
+    */
+   .read_bulk_callback  = GobiReadBulkCallback,
+   .dtr_rts             = Gobi_dtr_rts,
+   .attach              = Gobi_startup,
+   .port_remove         = Gobi_portremove,
+   .release             = Gobi_release,
+   .disconnect           = GobiUSBSerialDisconnect,
+#ifdef CONFIG_PM
+    .suspend    = GobiUSBSerialSuspend,
+    .resume     = GobiUSBSerialResume,
+     #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,5,0 ))
+    .reset_resume = GobiUSBSerialResetResume,
+    #endif
+ #endif
+};
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,4,0 ))
+static struct usb_serial_driver * const serial_drivers[] = {
+   &gGobiDevice, NULL
+};
+#endif
+
+//---------------------------------------------------------------------------
+// USB serial core overridding Methods
+//---------------------------------------------------------------------------
+/*===========================================================================
+METHOD:
+   GobiProbe (Free Method)
+
+DESCRIPTION:
+   Attach to correct interfaces
+
+PARAMETERS:
+   pSerial    [ I ] - Serial structure
+   pID        [ I ] - VID PID table
+
+RETURN VALUE:
+   int - negative error code on failure
+         zero on success
+===========================================================================*/
+static int GobiProbe(
+   struct usb_serial * pSerial,
+   const struct usb_device_id * pID )
+{
+   // Assume failure
+   int nRetval = -ENODEV;
+   int nInterfaceNum;
+   struct usb_host_endpoint * pEndpoint;
+   int endpointIndex;
+   int numEndpoints;
+   struct gobi_serial_intf_private *intfdata;
+
+   DBG( "\n" );
+
+   // Test parameters
+   if ( (pSerial == NULL)
+   ||   (pSerial->dev == NULL)
+   ||   (pSerial->dev->actconfig == NULL)
+   ||   (pSerial->interface == NULL)
+   ||   (pSerial->interface->cur_altsetting == NULL)
+   ||   (pSerial->type == NULL) )
+   {
+      DBG( "invalid parameter\n" );
+      return -EINVAL;
+   }
+
+
+   intfdata = kzalloc(sizeof(*intfdata), GFP_KERNEL);
+   if (!intfdata)
+           return -ENOMEM;
+   
+   spin_lock_init(&intfdata->susp_lock);
+   
+   usb_set_serial_data(pSerial, intfdata);
+
+   nNumInterfaces = pSerial->dev->actconfig->desc.bNumInterfaces;
+   DBG( "Num Interfaces = %d\n", nNumInterfaces );
+   nInterfaceNum = pSerial->interface->cur_altsetting->desc.bInterfaceNumber;
+   DBG( "This Interface = %d\n", nInterfaceNum );
+   #ifdef CONFIG_PM
+   pSerial->dev->reset_resume = 0;
+   #endif
+
+   if (nNumInterfaces == 1)
+   {
+      // QDL mode?
+      if ((nInterfaceNum == 0) || (nInterfaceNum == 1))
+      {
+         DBG( "QDL port found\n" );
+         nRetval = usb_set_interface( pSerial->dev,
+                                      nInterfaceNum,
+                                      0 );
+         if (nRetval < 0)
+         {
+            DBG( "Could not set interface, error %d\n", nRetval );
+         }
+      }
+      else
+      {
+         DBG( "Incorrect QDL interface number\n" );
+      }
+   }
+   else if (nNumInterfaces > 1)
+   {
+      /* Composite mode */
+      if (pSerial->interface->cur_altsetting->desc.bInterfaceClass != USB_CLASS_VENDOR_SPEC )
+      {
+         DBG( "Ignoring non vendor class interface #%d\n", nInterfaceNum );
+         usb_set_serial_data(pSerial, NULL);
+         kfree(intfdata);
+         return -ENODEV;
+      }
+      else if (pID->driver_info &&
+             test_bit(nInterfaceNum, &pID->driver_info)) {
+         DBG( "Ignoring blacklisted interface #%d\n", nInterfaceNum );
+         usb_set_serial_data(pSerial, NULL);
+         kfree(intfdata);
+         return -ENODEV;
+      }
+      else
+      {
+         nRetval = usb_set_interface( pSerial->dev,
+                                      nInterfaceNum,
+                                      0 );
+         if (nRetval < 0)
+         {
+            DBG( "Could not set interface, error %d\n", nRetval );
+         }
+
+         // Check for recursion
+         if (pSerial->type->close != GobiClose)
+         {
+            // Store usb_serial_generic_close in gpClose
+            gpClose = pSerial->type->close;
+            pSerial->type->close = GobiClose;
+         }
+      }
+   }
+   if (nRetval == 0 && nNumInterfaces > 1 )
+   {
+      // Clearing endpoint halt is a magic handshake that brings
+      // the device out of low power (airplane) mode
+      // NOTE: FCC verification should be done before this, if required
+      numEndpoints = pSerial->interface->cur_altsetting
+                         ->desc.bInterfaceNumber;
+
+      for (endpointIndex = 0; endpointIndex < numEndpoints; endpointIndex++)
+      {
+         pEndpoint = pSerial->interface->cur_altsetting->endpoint
+                   + endpointIndex;
+
+         if (pEndpoint != NULL
+         &&  usb_endpoint_dir_out( &pEndpoint->desc ) == true)
+         {
+            int pipe = usb_sndbulkpipe( pSerial->dev,
+                                        pEndpoint->desc.bEndpointAddress );
+            nRetval = usb_clear_halt( pSerial->dev, pipe );
+
+            // Should only be one
+            break;
+         }
+      }
+   }
+
+   return nRetval;
+}
+
+/*===========================================================================
+METHOD:
+   IsGPSPort (Free Method)
+
+DESCRIPTION:
+   Determines whether the interface is GPS port
+
+PARAMETERS:
+   pPort   [ I ] - USB serial port structure
+
+RETURN VALUE:
+   bool- true if this is a GPS port
+       - false otherwise
+===========================================================================*/
+bool IsGPSPort(struct usb_serial_port *   pPort )
+{
+   DBG( "Product=0x%x, Interface=0x%x\n",
+        cpu_to_le16(pPort->serial->dev->descriptor.idProduct),
+        pPort->serial->interface->cur_altsetting->desc.bInterfaceNumber);
+
+   switch (cpu_to_le16(pPort->serial->dev->descriptor.idProduct))
+   {
+      case 0x68A2:  /* Sierra Wireless QMI */
+      case 0x68C0:
+      case 0x9041:
+      case 0x9071:
+      case 0x9070:
+      //9x50
+      case 0x9090:
+      //9x50
+      case 0x9091:
+      case 0x90b0:
+      case 0x90b1:
+      case 0x9100:
+      case 0x9102:
+      case 0x9110:
+         if (pPort->serial->interface->cur_altsetting->desc.bInterfaceNumber == 2)
+            return true;
+         break;
+
+      case 0x9011:  /* Sierra Wireless G3K */
+      case 0x9013:  /* Sierra Wireless G3K */
+      case 0x9015:  /* Sierra Wireless G3K */
+      case 0x9019:  /* Sierra Wireless G3K */
+      case 0x371D:  /* G3K */
+         if (pPort->serial->interface->cur_altsetting->desc.bInterfaceNumber == 3)
+            return true;
+         break;
+
+      default:
+         return false;
+         break;
+  }
+  return false;
+}
+
+/*===========================================================================
+METHOD:
+   GobiOpen (Free Method)
+
+DESCRIPTION:
+   Start GPS if GPS port, run usb_serial_generic_open
+
+PARAMETERS:
+   pTTY    [ I ] - TTY structure (only on kernels <= 2.6.26)
+   pPort   [ I ] - USB serial port structure
+   pFilp   [ I ] - File structure (only on kernels <= 2.6.31)
+
+RETURN VALUE:
+   int - zero for success
+       - negative errno on error
+===========================================================================*/
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,26 ))
+int GobiOpen(
+   struct usb_serial_port *   pPort,
+   struct file *              pFilp )
+#elif (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,31 ))
+int GobiOpen(
+   struct tty_struct *        pTTY,
+   struct usb_serial_port *   pPort,
+   struct file *              pFilp )
+#else // > 2.6.31
+int GobiOpen(
+   struct tty_struct *        pTTY,
+   struct usb_serial_port *   pPort )
+#endif
+{
+   struct sierra_port_private *portdata;
+   const char startMessage[] = "$GPS_START";
+   int nResult;
+   int bytesWrote;
+
+   DBG( "\n" );
+
+   portdata = usb_get_serial_port_data(pPort);
+   portdata->isClosing = 0;
+
+   // Test parameters
+   if ( (pPort == NULL)
+   ||   (pPort->serial == NULL)
+   ||   (pPort->serial->dev == NULL)
+   ||   (pPort->serial->interface == NULL)
+   ||   (pPort->serial->interface->cur_altsetting == NULL) )
+   {
+      DBG( "invalid parameter\n" );
+      return -EINVAL;
+   }
+
+   // Is this the GPS port?
+   if ((IsGPSPort(pPort)) == true)
+   {
+      int count = 0;
+      if(portdata->iGPSStartState == eSendUnknown)
+      {
+        unsigned long now = jiffies;
+        if(now < portdata->ulExpires)
+        {
+           unsigned long diff = jiffies_to_msecs(portdata->ulExpires-now);
+           //Not wait more then delay_open_gps_port Seconds.
+           if( diff > (delay_open_gps_port*1000))
+           {
+              DBG("Overwrite DELAY %lu msec\n",diff);
+              diff = delay_open_gps_port*1000;
+           }
+           DBG("DELAY %lu msec\n",diff);
+           if(diff > 0)
+           msleep(diff);
+           DBG("DELAY FINISH\n");
+        }
+        else
+        {
+          DBG("NON DELAY OPEN!\n" );
+        }
+      }
+      portdata->iGPSStartState = eSendStart;
+      DBG( "GPS Port detected! send GPS_START!\n" );
+      // Send startMessage, USB_CTRL_SET_TIMEOUT timeout
+      do
+      {
+        nResult = gobi_usb_bulk_msg( pPort->serial->dev,
+                              usb_sndbulkpipe( pPort->serial->dev,
+                                               pPort->bulk_out_endpointAddress ),
+                              (void *)&startMessage[0],
+                              sizeof( startMessage ),
+                              &bytesWrote,
+                              USB_CTRL_SET_TIMEOUT );
+        if(nResult!=0)
+        {
+           if(count++>6)
+           {
+              printk( KERN_INFO "Send GPS_START Timeout!\n" );
+              break;
+           }
+        }
+      }while(-ETIMEDOUT==nResult);
+      DBG( "send GPS_START done\n");
+      if (nResult != 0)
+      {
+         DBG( "error %d sending startMessage\n", nResult );
+         if (!ignore_gps_start_error)
+         {
+            return nResult;
+         }
+      }
+      if (bytesWrote != sizeof( startMessage ))
+      {
+         DBG( "invalid write size %d, %lu\n",
+              bytesWrote,
+              (unsigned long)sizeof( startMessage ) );
+         if (!ignore_gps_start_error)
+         {
+            return -EIO;
+         }
+      }
+      portdata->iGPSStartState = eSendEnd;
+   }
+
+   // Clear endpoint halt condition
+   if( nNumInterfaces > 1 )
+   {
+      nResult = usb_clear_halt(pPort->serial->dev,
+                               usb_sndbulkpipe(pPort->serial->dev,
+                               pPort->bulk_in_endpointAddress) | USB_DIR_IN );
+      if (nResult != 0)
+      {
+         DBG( "usb_clear_halt return value = %d\n", nResult );
+      }
+   }
+
+   /* host device is awake */
+   set_power_state(pPort->serial->dev, 0x0000);
+
+   // Pass to usb_serial_generic_open
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,26 ))
+   return usb_serial_generic_open( pPort, pFilp );
+#elif (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,31 ))
+   return usb_serial_generic_open( pTTY, pPort, pFilp );
+#else // > 2.6.31
+   return usb_serial_generic_open( pTTY, pPort );
+#endif
+}
+
+/*===========================================================================
+METHOD:
+   GobiClose (Free Method)
+
+DESCRIPTION:
+   Stop GPS if GPS port, run usb_serial_generic_close
+
+PARAMETERS:
+   pTTY    [ I ] - TTY structure (only if kernel > 2.6.26 and <= 2.6.29)
+   pPort   [ I ] - USB serial port structure
+   pFilp   [ I ] - File structure (only on kernel <= 2.6.30)
+===========================================================================*/
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,26 ))
+void GobiClose(
+   struct usb_serial_port *   pPort,
+   struct file *              pFilp )
+#elif (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,30 ))
+void GobiClose(
+   struct tty_struct *        pTTY,
+   struct usb_serial_port *   pPort,
+   struct file *              pFilp )
+#else // > 2.6.30
+void GobiClose( struct usb_serial_port * pPort )
+#endif
+{
+   struct sierra_port_private *portdata;
+   const char stopMessage[] = "$GPS_STOP";
+   int nResult;
+   int bytesWrote;
+
+   DBG( "\n" );
+
+   portdata = usb_get_serial_port_data(pPort);
+   portdata->isClosing = 1;
+
+   // Test parameters
+   if ( (pPort == NULL)
+   ||   (pPort->serial == NULL)
+   ||   (pPort->serial->dev == NULL)
+   ||   (pPort->serial->interface == NULL)
+   ||   (pPort->serial->interface->cur_altsetting == NULL) )
+   {
+      DBG( "invalid parameter\n" );
+      return;
+   }
+
+   // Is this the GPS port?
+   if ((IsGPSPort(pPort)) == true)
+   {
+      DBG( "GPS Port detected! send GPS_STOP!\n" );
+      // Send stopMessage, 1s timeout
+      nResult = gobi_usb_bulk_msg( pPort->serial->dev,
+                              usb_sndbulkpipe( pPort->serial->dev,
+                                               pPort->bulk_out_endpointAddress ),
+                              (void *)&stopMessage[0],
+                              sizeof( stopMessage ),
+                              &bytesWrote,
+                              100 );
+      if (nResult != 0)
+      {
+         DBG( "error %d sending stopMessage\n", nResult );
+      }
+      if (bytesWrote != sizeof( stopMessage ))
+      {
+         DBG( "invalid write size %d, %lu\n",
+              bytesWrote,
+              (unsigned long)sizeof( stopMessage ) );
+      }
+   }
+
+   // Pass to usb_serial_generic_close
+   if (gpClose == NULL)
+   {
+      DBG( "NULL gpClose\n" );
+      return;
+   }
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,26 ))
+   gpClose( pPort, pFilp );
+#elif (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,30 ))
+   gpClose( pTTY, pPort, pFilp );
+#else // > 2.6.30
+   gpClose( pPort );
+#endif
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,35 ))
+/* Push data to tty layer and resubmit the bulk read URB */
+static void flush_and_resubmit_read_urb(struct usb_serial_port *port)
+{
+    struct urb *urb = port->read_urb;
+    struct tty_struct *tty = tty_port_tty_get(&port->port);
+    char *ch = (char *)urb->transfer_buffer;
+    int i;
+
+    if (!tty || urb->status)
+    {
+        tty_kref_put(tty);
+        goto done;
+    }
+
+    /* The per character mucking around with sysrq path it too slow for
+       stuff like 3G modems, so shortcircuit it in the 99.9999999% of cases
+       where the USB serial is not a console anyway */
+    if (!port->console || !port->sysrq)
+        tty_insert_flip_string(tty, ch, urb->actual_length);
+    else {
+        /* Push data to tty */
+        for (i = 0; i < urb->actual_length; i++, ch++) {
+            if (!usb_serial_handle_sysrq_char(tty, port, *ch))
+                tty_insert_flip_char(tty, *ch, TTY_NORMAL);
+        }
+    }
+    tty_flip_buffer_push(tty);
+    tty_kref_put(tty);
+done:
+    usb_serial_generic_resubmit_read_urb(port, GFP_ATOMIC);
+}
+#endif //#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,35 ))
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,3,0 )) 
+static int usb_serial_generic_submit_read_urb(struct usb_serial_port *port,
+                        int index, gfp_t mem_flags)
+{       
+    int res;
+
+    if (!test_and_clear_bit(index, &port->read_urbs_free))
+        return 0;
+
+    dev_dbg(&port->dev, "%s - urb %d\n", __func__, index);
+    
+    res = usb_submit_urb(port->read_urbs[index], mem_flags);
+    if (res) {
+        if (res != -EPERM) {
+            dev_err(&port->dev,
+                    "%s - usb_submit_urb failed: %d\n",
+                    __func__, res);
+        }
+        set_bit(index, &port->read_urbs_free);
+        return res;
+    }
+
+    return 0;
+}
+#endif //#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,3,0 )) 
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,25 ))
+
+/*===========================================================================
+METHOD:
+   GobiReadBulkCallback (Free Method)
+
+DESCRIPTION:
+   Read data from USB, push to TTY and user space
+
+PARAMETERS:
+   pURB  [ I ] - USB Request Block (urb) that called us
+
+RETURN VALUE:
+===========================================================================*/
+static void GobiReadBulkCallback( struct urb * pURB )
+{
+   struct sierra_port_private *portdata;
+   struct usb_serial_port * pPort = pURB->context;
+   struct tty_struct * pTTY = pPort->tty;
+   int nResult;
+   int nRoom = 0;
+   unsigned int pipeEP;
+   int status = urb->status;
+
+   DBG( "port %d\n", pPort->number );
+
+   portdata = usb_get_serial_port_data(pPort);
+   if (portdata->isClosing)
+   {
+       /* ignore bulk callback when port is closing */
+       return;
+   }
+
+   if (status != 0)
+   {
+      if (status == -ESHUTDOWN || status == -ENOENT || status == -ENODEV) {
+      {
+          return;
+      }
+      DBG("nonzero read bulk status received: %d\n", pURB->status );
+   }
+
+   usb_serial_debug_data( debug,
+                          &pPort->dev,
+                          __FUNCTION__,
+                          pURB->actual_length,
+                          pURB->transfer_buffer );
+
+   // We do no port throttling
+
+   // Push data to tty layer and user space read function
+   if ( (pTTY != 0) && (status == 0) && (pURB->actual_length) )
+   {
+      nRoom = tty_buffer_request_room( pTTY, pURB->actual_length );
+      DBG( "room size %d %d\n", nRoom, 512 );
+      if (nRoom != 0)
+      {
+         tty_insert_flip_string( pTTY, pURB->transfer_buffer, nRoom );
+         tty_flip_buffer_push( pTTY );
+      }
+   }
+
+   pipeEP = usb_rcvbulkpipe( pPort->serial->dev,
+                             pPort->bulk_in_endpointAddress );
+
+   // For continuous reading
+   usb_fill_bulk_urb( pPort->read_urb,
+                      pPort->serial->dev,
+                      pipeEP,
+                      pPort->read_urb->transfer_buffer,
+                      pPort->read_urb->transfer_buffer_length,
+                      GobiReadBulkCallback,
+                      pPort );
+
+   nResult = usb_submit_urb( pPort->read_urb, GFP_ATOMIC );
+   if (nResult != 0)
+   {
+      DBG( "failed resubmitting read urb, error %d\n", nResult );
+   }
+}
+#else
+void GobiReadBulkCallback(struct urb *urb)
+{   
+    struct sierra_port_private *portdata;
+    struct usb_serial_port *port = urb->context;
+    unsigned char *data = urb->transfer_buffer;
+    unsigned long flags;
+    int status = urb->status;
+    int i;
+
+    #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,3,0 ))
+    for (i = 0; i < ARRAY_SIZE(port->read_urbs); ++i) {
+        if (urb == port->read_urbs[i])
+            break;
+    }
+    if (i < ARRAY_SIZE(port->read_urbs))
+        set_bit(i, &port->read_urbs_free);
+    #endif
+
+    /* only ignore bulk callback after the bit of read_urbs_free was set,
+       so that the port can be accessed later on */
+    portdata = usb_get_serial_port_data(port);
+    if (portdata->isClosing)
+    {
+        /* ignore bulk callback when port is closing */
+        return;
+    }
+
+    dev_dbg(&port->dev, "%s - urb %d, len %d\n", __func__, i,
+                            urb->actual_length);
+    
+    if (urb->status) {
+        if (status == -ESHUTDOWN || status == -ENOENT || status == -ENODEV) {
+            return;
+        }
+        DBG("%s - non-zero urb status: %d\n",
+            __func__, urb->status);
+    }
+    else
+    { 
+        #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,7,0 ))
+            usb_serial_debug_data(&port->dev, __func__, urb->actual_length, data);
+        #else
+            usb_serial_debug_data(debug, &port->dev, __func__, urb->actual_length, data);
+        #endif
+
+        #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,35 ))
+        port->serial->type->process_read_urb(urb);
+        #endif
+    }
+
+    /* Throttle the device if requested by tty */
+    spin_lock_irqsave(&port->lock, flags);
+    port->throttled = port->throttle_req;
+    if (!port->throttled)
+    {
+        spin_unlock_irqrestore(&port->lock, flags);
+        #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,3,0 ))
+        if (i < ARRAY_SIZE(port->read_urbs))        
+            usb_serial_generic_submit_read_urb(port, i, GFP_ATOMIC);
+        #elif (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,35 )) 
+        usb_serial_generic_submit_read_urb(port, GFP_ATOMIC);
+        #else
+        flush_and_resubmit_read_urb(port);
+        #endif
+    }
+    else
+    {
+        spin_unlock_irqrestore(&port->lock, flags);
+    }
+}
+
+#endif //#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,25 ))
+
+#ifdef CONFIG_PM
+/*===========================================================================
+METHOD:
+   GobiSerialSuspend (Public Method)
+
+DESCRIPTION:
+   Set reset_resume flag
+
+PARAMETERS
+   pIntf          [ I ] - Pointer to interface
+   powerEvent     [ I ] - Power management event
+
+RETURN VALUE:
+   int - 0 for success
+         negative errno for failure
+===========================================================================*/
+int GobiSerialSuspend(
+   struct usb_interface *     pIntf,
+   pm_message_t               powerEvent )
+{
+   struct usb_serial * pDev;
+   DBG( "\n" );
+   if (pIntf == 0)
+   {
+      return -ENOMEM;
+   }
+
+   pDev = usb_get_intfdata( pIntf );
+   if (pDev == NULL)
+   {
+      return -ENXIO;
+   }
+
+   // Unless this is PM_EVENT_SUSPEND, make sure device gets rescanned
+   if ((powerEvent.event & PM_EVENT_SUSPEND) == 0)
+   {
+      pDev->dev->reset_resume = 1;
+   }
+
+   // Run usb_serial's suspend function
+   return usb_serial_suspend( pIntf, powerEvent );
+}
+
+
+#endif /* CONFIG_PM*/
+
+
+static void gobi_stop_rx_urbs(struct usb_serial_port *port)
+{
+        usb_kill_urb(port->interrupt_in_urb);
+}
+
+void stop_read_write_urbs(struct usb_serial *serial)
+{
+        int i;
+        struct usb_serial_port *port;
+
+        /* Stop reading/writing urbs */
+        for (i = 0; i < serial->num_ports; ++i) {
+                port = serial->port[i];
+                gobi_stop_rx_urbs(port);
+        }
+}
+
+
+
+#ifdef CONFIG_PM
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,23 ))
+
+/*===========================================================================
+METHOD:
+   GobiSerialResume (Free Method)
+
+DESCRIPTION:
+   Restart URBs killed during usb_serial_suspend
+
+   Fixes 2 bugs in 2.6.23 kernel
+      1. pSerial->type->resume was NULL and unchecked, caused crash.
+      2. set_to_generic_if_null was not run for resume.
+
+PARAMETERS:
+   pIntf  [ I ] - Pointer to interface
+
+RETURN VALUE:
+   int - 0 for success
+         negative errno for failure
+===========================================================================*/
+int GobiSerialResume( struct usb_interface * pIntf )
+{
+   struct usb_serial * pSerial = usb_get_intfdata( pIntf );
+   struct usb_serial_port * pPort;
+   int portIndex, errors, nResult;
+
+   if (pSerial == NULL)
+   {
+      DBG( "no pSerial\n" );
+      return -ENOMEM;
+   }
+   if (pSerial->type == NULL)
+   {
+      DBG( "no pSerial->type\n" );
+      return ENOMEM;
+   }
+   if (pSerial->type->resume == NULL)
+   {
+      // Expected behaviour in 2.6.23, in later kernels this was handled
+      // by the usb-serial driver and usb_serial_generic_resume
+      errors = 0;
+      for (portIndex = 0; portIndex < pSerial->num_ports; portIndex++)
+      {
+         pPort = pSerial->port[portIndex];
+         if (pPort->open_count > 0 && pPort->read_urb != NULL)
+         {
+            nResult = usb_submit_urb( pPort->read_urb, GFP_NOIO );
+            if (nResult < 0)
+            {
+               // Return first error we see
+               DBG( "error %d\n", nResult );
+               return nResult;
+            }
+         }
+      }
+
+      // Success
+      return 0;
+   }
+
+   // Execution would only reach this point if user has
+   // patched version of usb-serial driver.
+   return usb_serial_resume( pIntf );
+}
+
+#endif
+#endif /* CONFIG_PM*/
+
+#ifdef CONFIG_PM
+int GobiUSBSerialResetResume(struct usb_serial *serial)
+{
+    DBG( "\n" );
+    return GobiUSBSerialResume(serial);
+}
+
+int GobiUSBSerialResume(struct usb_serial *serial)
+{
+   struct gobi_serial_intf_private *intfdata = usb_get_serial_data(serial);
+   DBG( "\n" );
+   spin_lock_irq(&intfdata->susp_lock);
+   intfdata->suspended = 0;
+   spin_unlock_irq(&intfdata->susp_lock);
+ 
+   return 0;
+}
+
+int GobiUSBSerialSuspend(struct usb_serial *pDev, pm_message_t powerEvent)
+{
+   struct gobi_serial_intf_private *intfdata = usb_get_serial_data(pDev);
+   DBG( "\n" );
+   spin_lock_irq(&intfdata->susp_lock);
+   intfdata->suspended = 1;
+   spin_unlock_irq(&intfdata->susp_lock);
+   stop_read_write_urbs(pDev);
+   return 0;
+}
+#endif
+
+void GobiUSBSerialDisconnect(struct usb_serial *serial)
+{
+   DBG( "\n" );
+   stop_read_write_urbs(serial);
+   return ;
+}
+
+/*===========================================================================
+METHOD:
+   GobiInit (Free Method)
+
+DESCRIPTION:
+   Register the driver and device
+
+PARAMETERS:
+
+RETURN VALUE:
+   int - negative error code on failure
+         zero on success
+===========================================================================*/
+static int __init GobiInit( void )
+{
+   int nRetval = 0;
+   gpClose = NULL;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 3,4,0 ))
+   // Registering driver to USB serial core layer
+   nRetval = usb_serial_register( &gGobiDevice );
+   if (nRetval != 0)
+   {
+      return nRetval;
+   }
+
+   // Registering driver to USB core layer
+   nRetval = usb_register( &GobiDriver );
+   if (nRetval != 0)
+   {
+      usb_serial_deregister( &gGobiDevice );
+      return nRetval;
+   }
+
+   // This will be shown whenever driver is loaded
+   printk( KERN_INFO "%s: %s\n", DRIVER_DESC, DRIVER_VERSION );
+
+#else
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,5,0 ))
+   nRetval = usb_serial_register_drivers(serial_drivers, KBUILD_MODNAME, GobiVIDPIDTable);
+#else
+   nRetval = usb_serial_register_drivers(&GobiDriver, serial_drivers);
+#endif
+   if (nRetval == 0)
+   {
+      printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+            DRIVER_DESC "\n");
+   }
+#endif
+
+
+   return nRetval;
+}
+
+/*===========================================================================
+METHOD:
+   GobiExit (Free Method)
+
+DESCRIPTION:
+   Deregister the driver and device
+
+PARAMETERS:
+
+RETURN VALUE:
+===========================================================================*/
+static void __exit GobiExit( void )
+{
+   gpClose = NULL;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 3,4,0 ))
+   usb_deregister( &GobiDriver );
+   usb_serial_deregister( &gGobiDevice );
+#else
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,5,0 ))
+   usb_serial_deregister_drivers(serial_drivers);
+#else
+   usb_serial_deregister_drivers(&GobiDriver, serial_drivers);
+#endif
+#endif
+}
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 3,2,0 ))
+static inline int usb_endpoint_maxp(const struct usb_endpoint_descriptor *epd)
+{
+   return le16_to_cpu(epd->wMaxPacketSize);
+}
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,35 ))
+static inline struct usb_host_endpoint *
+usb_pipe_endpoint(struct usb_device *dev, unsigned int pipe)
+{
+   struct usb_host_endpoint **eps;
+   eps = usb_pipein(pipe) ? dev->ep_in : dev->ep_out;
+   return eps[usb_pipeendpoint(pipe)];
+}
+#endif
+
+/*===========================================================================
+METHOD:
+   Gobi_write (Free Method)
+
+DESCRIPTION:
+   call usb_serial_generic_write and conditionally add zero lenght payload.
+
+PARAMETERS:
+   pTTY    [ I ] - TTY structure
+   pPort   [ I ] - USB serial port structure
+   buf     [ I ] - write buffer
+   count   [ I ] - number of buffer need to be writen.
+
+RETURN VALUE:
+   int - usb_serial_generic_write return value
+===========================================================================*/
+static int Gobi_write(struct tty_struct *pTTY, struct usb_serial_port *pPort,
+               const unsigned char *buf, int count)
+{
+   int result = usb_serial_generic_write(pTTY, pPort, buf, count);
+   struct usb_serial *pSerial;
+   struct usb_host_endpoint *ep;
+   struct sierra_port_private *portdata;
+   if( (pPort) && 
+       (pPort->serial) && 
+       (pPort->serial->interface) )
+   {
+      if(pPort->serial->interface->cur_altsetting->desc.bInterfaceNumber!=0)
+      {
+         return result;
+      }
+   }
+   else
+   {
+      return -ENODEV;
+   }
+   pSerial = pPort->serial;
+   if( (pSerial) && 
+       (pSerial->dev) &&
+       (pSerial->dev->actconfig) )
+   {
+      if(pSerial->dev->actconfig->desc.bNumInterfaces!=1)
+      {
+         return result;
+      }
+   }
+   else
+   {
+      return -ENODEV;
+   }
+   portdata = usb_get_serial_port_data(pPort);
+   if(portdata)
+   {
+      if((result ==count)&&(portdata->iUsb3ZlpEnable))
+      {
+         if(pSerial->dev->speed >= USB_SPEED_SUPER)
+         {
+            int pipe=0, len=0, size=0;
+            ep = usb_pipe_endpoint(pSerial->dev, pipe);
+            if( (ep) &&
+                (!(count % usb_endpoint_maxp(&ep->desc))) )
+            {
+               pipe = usb_sndbulkpipe(pSerial->dev, pPort->bulk_out_endpointAddress);
+               gobi_usb_bulk_msg(pSerial->dev, pipe, NULL, size,
+                             &len, 3000);
+            }
+         }
+      }
+   }   
+   return result;
+}
+
+/*===========================================================================
+METHOD:
+   gobi_usb_bulk_msg (private Method)
+
+DESCRIPTION:
+   call usb_bulk_msg and alloc buffer if a data address is within the vmalloc range.
+
+PARAMETERS:
+   usb_dev [ I ] - pointer to the usb device to send the message to
+   pipe    [ I ] - endpoint "pipe" to send the message to
+   data    [ I ] - pointer to the data to send
+   len     [ I ] - length in bytes of the data to send
+   actual_length     [ O ] - pointer to a location to put the actual 
+   length transferred in bytes
+   timeout [ I ] - time in msecs to wait for the message to complete 
+   before timing out (if 0 the wait is forever)
+
+RETURN VALUE:
+   int - usb_bulk_msg return value
+===========================================================================*/
+int gobi_usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,
+   void *data, int len, int *actual_length,
+   int timeout)
+{
+   void *pBuf = NULL;
+   int ret = 0;
+   
+   pBuf = kzalloc(len,GFP_KERNEL);
+   if(!pBuf)
+   {
+      DBG("MEM ERROR!\n");
+      return -ENOMEM;
+   }
+   memcpy(pBuf,data,len);
+
+   ret = usb_bulk_msg(usb_dev,pipe,pBuf,len,actual_length,timeout);
+   if(pBuf!=data)
+   {
+      kfree(pBuf);
+      pBuf = NULL;
+   }
+   return ret;
+}
+
+// Calling kernel module to init our driver
+module_init( GobiInit );
+module_exit( GobiExit );
+
+MODULE_VERSION( DRIVER_VERSION );
+MODULE_AUTHOR( DRIVER_AUTHOR );
+MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_LICENSE( "Dual BSD/GPL" );
+
+module_param( debug, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( debug, "Debug enabled or not" );
+module_param( flow_control, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( flow_control, "flow control enabled or not" );
+module_param( ignore_gps_start_error, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( ignore_gps_start_error, 
+   "allow port open to success even when GPS control message failed");
+module_param( delay_open_gps_port, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( delay_open_gps_port, "Delay Open GPS Port, after device ready" );
+module_param( iusb3_zlp_enable, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( iusb3_zlp_enable, "0 = Disable , 1 (default) ZLP on USB3 in QDL mode" );
+
diff --git a/drivers/net/usb/GobiUSBNet.c b/drivers/net/usb/GobiUSBNet.c
new file mode 100644
index 00000000..8396236b
--- /dev/null
+++ b/drivers/net/usb/GobiUSBNet.c
@@ -0,0 +1,3579 @@
+/*===========================================================================
+FILE:
+   GobiUSBNet.c
+
+DESCRIPTION:
+   Qualcomm USB Network device for Gobi 3000
+
+FUNCTIONS:
+   GobiNetSuspend
+   GobiNetResume
+   GobiNetDriverBind
+   GobiNetDriverUnbind
+   GobiUSBNetURBCallback
+   GobiUSBNetTXTimeout
+   GobiUSBNetAutoPMThread
+   GobiUSBNetStartXmit
+   GobiUSBNetOpen
+   GobiUSBNetStop
+   GobiUSBNetProbe
+   GobiUSBNetModInit
+   GobiUSBNetModExit
+
+Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Code Aurora Forum nor
+      the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+Alternatively, provided that this notice is retained in full, this software
+may be relicensed by the recipient under the terms of the GNU General Public
+License version 2 ("GPL") and only version 2, in which case the provisions of
+the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
+software under the GPL, then the identification text in the MODULE_LICENSE
+macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
+recipient changes the license terms to the GPL, subsequent recipients shall
+not relicense under alternate licensing terms, including the BSD or dual
+BSD/GPL terms.  In addition, the following license statement immediately
+below and between the words START and END shall also then apply when this
+software is relicensed under the GPL:
+
+START
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License version 2 and only version 2 as
+published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+END
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+/* ===========================================================================
+Reference http://www.spinics.net/lists/linux-usb/msg56457.html
+USB/xhci: Enable remote wakeup for USB3 devices
+===========================================================================*/
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+
+#include "Structs.h"
+#include "QMIDevice.h"
+#include "QMI.h"
+#include "gobi_usbnet.h"
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <net/ip.h>
+#include <net/sch_generic.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <net/xfrm.h>
+
+#ifdef CONFIG_MEMCG
+#define MEMCG_NOT_FIX
+#ifdef MEMCG_NOT_FIX
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,13,0 ) &&\
+       LINUX_VERSION_CODE < KERNEL_VERSION( 4,4,0 ))
+#warning "Remove memcontrol.h task_in_memcg_oom warning : replace 'return p->memcg_oom.memcg;' to 'return p->memcg_oom.memcg==NULL ? 0 : 1;' in function task_in_memcg_oom"
+#warning "Commnet '#define MEMCG_NOT_FIX' above after fix applied."
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION( 4,4,0 ) )
+#warning "Remove memcontrol.h task_in_memcg_oom warning : replace 'return p->memcg_in_oom;' to 'return p->memcg_in_oom==NULL ? 0 : 1;' in function task_in_memcg_oom"
+#warning "Commnet '#define MEMCG_NOT_FIX' above after fix applied."
+#endif
+#endif
+#endif
+#include <asm/siginfo.h>   //siginfo
+#include <linux/rcupdate.h>   //rcu_read_lock
+#include <linux/sched.h>   //find_task_by_pid_type
+#include <linux/irq.h>
+#include <net/sch_generic.h>
+
+#ifdef CONFIG_IPV6
+static inline __u8 ipv6_tclass2(const struct ipv6hdr *iph)
+{
+         return (ntohl(*(__be32 *)iph) >> 20) & 0xff;
+}
+#endif
+
+#define BIT_9X15    (31)
+//-----------------------------------------------------------------------------
+// Probe one device at the time when set to "1"
+//-----------------------------------------------------------------------------
+#ifdef CONFIG_ANDROID
+#define _PROBE_LOCK_ 1
+#else
+#define _PROBE_LOCK_ 1
+#endif
+//-----------------------------------------------------------------------------
+// Definitions
+//-----------------------------------------------------------------------------
+
+// Version Information
+#define DRIVER_VERSION "2018-12-21/SWI_2.55"
+#define DRIVER_AUTHOR "Qualcomm Innovation Center"
+#define DRIVER_DESC "GobiNet"
+#define QOS_HDR_LEN (6)
+#define IPV6HDR_PAYLOAD_UPPER (4)
+#define IPV6HDR_PAYLOAD_LOWER (5)
+#define IPV6HDR_LENGTH (40) // ipv6 header length
+#define IPV4HDR_TOT_UPPER (2)
+#define IPV4HDR_TOT_LOWER (3)
+#define MAC48_MULTICAST_ID (0x33)
+#define GOBI_MAX_SINGLE_PACKET_SIZE 2048
+#define FIX_RX_BUFFER 1
+#define USB_CONF_ATTRIBUTE_REMOTE_WAKEUP_ENABLE 0x20
+
+// Debug flag
+int debug;
+int qos_debug;
+int iModuleExit=0;
+/*
+ * enable/disable TE flow control
+ */
+int iTEEnable=-1;
+int iQMAPEnable=-1;
+int iMaxQMUXSupported=-1;
+int iIPAlias=1;
+//Fill zero to ethernet header source address.
+int iEthSrcMACNonZero=0;
+/*
+ * Is RAW IP RAW
+ */
+#ifndef DATA_MODE_RP
+int iRAWIPEnable=0;
+#else
+int iRAWIPEnable=1;
+#endif
+
+#ifdef TX_URB_MONITOR
+
+    /* 
+     * URB monitor requires that Sierra override some functions to get 
+     * URB information. 
+     * TX_XMIT_SIERRA indicates the default Linux functions that were over-ridden
+     * TX_URB_MONITOR indicates the changes made for URB monitor to work 
+     * 
+     */
+    #ifndef TX_XMIT_SIERRA
+    #define TX_XMIT_SIERRA
+    #endif
+
+/* Current URB monitor implementation is supported on kernel versions
+ * between 2.6.31 and 2.6.32. This is because the default "usbnet_start_xmit" function
+ * is over-ridden by Sierra to provide this functionality. Post kernel 2.6.32, 
+ * there is a change in "usbnet_start_xmit" which is not handled 
+ * by Sierra Gobinet driver
+ */
+//TO TEST DIFFERENT KERNEL VERSIONS
+//#undef LINUX_VERSION_CODE
+//#define LINUX_VERSION_CODE  KERNEL_VERSION( 3,13,1 )
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,31 ) ||\
+       (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,32 ) &&\
+       LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,35 )) ||\
+       (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,35 ) &&\
+       LINUX_VERSION_CODE < KERNEL_VERSION( 3,0,6 )) ||\
+       (LINUX_VERSION_CODE > KERNEL_VERSION( 3,0,6 ) &&\
+       LINUX_VERSION_CODE < KERNEL_VERSION( 3,10,1 )) ||\
+       (LINUX_VERSION_CODE > KERNEL_VERSION( 3,11,0 ) &&\
+       LINUX_VERSION_CODE < KERNEL_VERSION( 3,12,0)) ||\
+       (LINUX_VERSION_CODE > KERNEL_VERSION( 3,12,0 ) &&\
+       LINUX_VERSION_CODE < KERNEL_VERSION( 4,4,0)) ||\
+       (LINUX_VERSION_CODE > KERNEL_VERSION( 4,4,0 ) &&\
+       LINUX_VERSION_CODE < KERNEL_VERSION( 4,4,2)) ||\
+       LINUX_VERSION_CODE >= KERNEL_VERSION( 4,5,0 ) )
+#error "URB_MONITOR is NOT supported on this kernel version"
+#endif
+#endif //TX_URB_MONITOR
+
+// Allow user interrupts
+int interruptible = 1;
+
+// Number of IP packets which may be queued up for transmit
+int txQueueLength = 100;
+
+// Class should be created during module init, so needs to be global
+static struct class * gpClass;
+struct semaphore taskLoading;
+
+/**************************************************/
+bool isModuleUnload(sGobiUSBNet *pDev);
+int FixEthFrame(struct usbnet *dev, struct sk_buff *skb, int isIpv4);
+void ResetEthHeader(struct usbnet *dev, struct sk_buff *skb, int isIpv4, int isQMAPPacket);
+int GobiUSBNetOpen( struct net_device * pNet );
+int GobiUSBNetStop( struct net_device * pNet );
+#ifdef FIX_RX_BUFFER
+int GobiUSBNetChangeMTU(struct net_device *netdev, int new_mtu);
+#endif
+static int GobiNetDriverLteRxFixup(struct usbnet *dev, struct sk_buff *skb);
+void SendWakeupControlMsg(
+   struct usb_interface * pIntf,
+   int oldPowerState);
+void StopQMUXNet(sGobiUSBNet * pGobiDev);
+void DeleteQMUXNet(sGobiUSBNet * pGobiDev);
+int gobi_dev_forward_skb(struct net_device *dev, struct sk_buff *skb);
+int GobiUSBNetUpdateRxUrbSize(struct net_device *netdev, u32 new_rx_urb_size);
+void DestroyQMAPRxBuffer(sGobiUSBNet *pGobiDev);
+int CreateQMAPRxBuffer(sGobiUSBNet *pGobiDev);
+void *gobi_skb_push(struct sk_buff *pSKB, unsigned int len);
+int GobiUSBLockReset( struct usb_interface * pIntf );
+void gobi_dev_deactivate(struct net_device *dev);
+void gobi_netif_stop_queue(struct net_device *dev);
+void gobi_usbnet_stop(struct net_device *net);
+int gobi_rtnl_trylock(void);
+void stop_virtual_netdev(struct net_device *dev);
+int iIsRemoteWakeupSupport(struct usbnet * pDev);
+
+int CreateQMAPRxBuffer(sGobiUSBNet *pGobiDev)
+{
+   pGobiDev->pLastSKB = dev_alloc_skb(pGobiDev->ULDatagramSize);
+   pGobiDev->pLastSKB->len=0;
+   pGobiDev->iPacketInComplete = 0;
+   return 0;
+}
+
+void DestroyQMAPRxBuffer(sGobiUSBNet *pGobiDev)
+{
+   if(pGobiDev==NULL)
+      return ;
+   if(pGobiDev->pLastSKB!=NULL)
+      dev_kfree_skb_any(pGobiDev->pLastSKB);
+   pGobiDev->pLastSKB=NULL;
+   return ;
+}
+
+void DeleteQMUXNet(sGobiUSBNet * pGobiDev)
+{
+   if(pGobiDev==NULL)
+      return;
+   if(pGobiDev->mpNetDev == NULL)
+      return;
+   gobi_usbnet_stop(pGobiDev->mpNetDev->net);//IPV6 lock error
+   gobi_dev_deactivate(pGobiDev->mpNetDev->net);
+   if(pGobiDev->iQMUXEnable!=0)
+   {
+      gobi_netif_stop_queue(pGobiDev->mpNetDev->net);
+      netif_carrier_off(pGobiDev->mpNetDev->net);
+      gobi_usbnet_stop(pGobiDev->mpNetDev->net);
+      gobi_netif_stop_queue(pGobiDev->mpNetDev->net);
+      if(netif_running(pGobiDev->mpNetDev->net))
+      {
+         DBG("running\n");
+      }
+      if (!gobi_rtnl_trylock()) 
+      {
+         DBG("!gobi_rtnl_trylock\n");
+         restart_syscall();
+         return;
+      }
+      
+      if(pGobiDev->iIPAlias==0)
+      {
+         int i=0;
+         for(i=0;i<MAX_MUX_NUMBER_SUPPORTED;i++)
+         {
+            if(pGobiDev->pNetDevice[i]!=NULL)
+            gobi_qmimux_unregister_device(pGobiDev->pNetDevice[i]);
+         }
+      }
+      rtnl_unlock();
+      gobi_netif_stop_queue(pGobiDev->mpNetDev->net);
+      netif_carrier_off(pGobiDev->mpNetDev->net);
+   }
+}
+
+void StopQMUXNet(sGobiUSBNet * pGobiDev)
+{
+   if(pGobiDev==NULL)
+      return ;
+   if(pGobiDev->mpNetDev == NULL)
+      return;
+   if(pGobiDev->iStoppingNetDev==1)
+      return ;
+   pGobiDev->iStoppingNetDev=1;
+   if (!gobi_rtnl_trylock()) 
+   {
+      printk(KERN_INFO "!force rtnl unlock\n");
+   }
+   rtnl_unlock();
+   gobi_usbnet_stop(pGobiDev->mpNetDev->net);//IPV6 lock error
+   gobi_dev_deactivate(pGobiDev->mpNetDev->net);
+   if(pGobiDev->iQMUXEnable!=0)
+   {
+      int i=0;
+      gobi_netif_stop_queue(pGobiDev->mpNetDev->net);
+      netif_carrier_off(pGobiDev->mpNetDev->net);
+      gobi_usbnet_stop(pGobiDev->mpNetDev->net);
+      gobi_netif_stop_queue(pGobiDev->mpNetDev->net);
+      if(netif_running(pGobiDev->mpNetDev->net))
+      {
+         DBG("running\n");
+      }
+
+      rcu_read_lock();
+      for(i=0;i<MAX_MUX_NUMBER_SUPPORTED;i++)
+      {
+         if(pGobiDev->pNetDevice[i]!=NULL)
+         {
+            stop_virtual_netdev(pGobiDev->pNetDevice[i]);
+         }
+      }
+      rcu_read_unlock();
+
+      gobi_netif_stop_queue(pGobiDev->mpNetDev->net);
+      netif_carrier_off(pGobiDev->mpNetDev->net);
+      wait_ms(500);
+      DeleteQMUXNet(pGobiDev);
+   }
+}
+
+int work_function(void *data)
+{
+
+   int status=0;
+   sGobiUSBNet * pGobiDev = (sGobiUSBNet*)data;
+   char szQMIBusName[64]={0};
+   struct usb_device *dev = NULL;
+   
+   #if _PROBE_LOCK_
+   int i = 0;
+   if(!pGobiDev)
+   {
+      return -1;
+   }
+   while(0!=down_trylock( &taskLoading ))
+   {
+     if((gobi_kthread_should_stop())||
+        signal_pending(current))
+      {
+         pGobiDev->task = NULL;
+         pGobiDev->iTaskID = -1;
+         pGobiDev->mbQMIValid = false;
+         return -1;
+      }
+      i++;
+      if( (i>5000) || isModuleUnload(pGobiDev))
+      {
+         DBG("Get TaskID Timeout");
+         pGobiDev->iTaskID = -1;
+         return 0;
+      }
+      if((i%1000) ==999)
+         DBG("Waiting...\n");
+      set_current_state(TASK_INTERRUPTIBLE);
+      if (signal_pending(current))
+      {
+         return -1;
+      }
+      wait_ms(10);
+      
+      if((gobi_kthread_should_stop())||
+        signal_pending(current))
+      {
+         pGobiDev->task = NULL;
+         pGobiDev->iTaskID = -1;
+         pGobiDev->mbQMIValid = false;
+         return -1;
+      }
+   }
+   set_current_state(TASK_RUNNING);
+   #endif
+   if(!pGobiDev)
+   {
+      return -1;
+   }
+   dev = interface_to_usbdev(pGobiDev->mUsb_Interface);
+   snprintf(szQMIBusName,63,"qcqmi%d-%d-%s:%d.%d",   
+      (int)pGobiDev->mQMIDev.qcqmi,   
+      dev->bus->busnum, dev->devpath,    
+      dev->actconfig->desc.bConfigurationValue,   
+      pGobiDev->mUsb_Interface->cur_altsetting->desc.bInterfaceNumber);
+   pGobiDev->mQMIDev.mpClientMemList = NULL;
+   pGobiDev->iNetLinkStatus = eNetDeviceLink_Disconnected;
+   DBG("Handle qcqmi(%s), task: %d\n",szQMIBusName,pGobiDev->iTaskID);
+   status = RegisterQMIDevice( pGobiDev, pGobiDev->mIs9x15);
+   if (status != 0)
+   {
+      if(pGobiDev)
+      {
+        if(pGobiDev)
+        {
+           DBG("Finish qcqmi(%s) task: %d %d\n",szQMIBusName,pGobiDev->iTaskID,status);
+           pGobiDev->task = NULL;
+           pGobiDev->iTaskID = -1;
+           pGobiDev->mbQMIValid = false;
+        }
+      }
+   }
+   else 
+   {
+      if(pGobiDev->iDataMode==eDataMode_RAWIP)
+      {
+         pGobiDev->mpNetDev->net->hard_header_len = 0;
+         pGobiDev->mpNetDev->net->flags |= IFF_NOARP;
+         #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 4,4,0 ))
+         pGobiDev->mpNetDev->net->flags |= IFF_NOARP | IFF_MULTICAST;
+         /* recalculate buffers after changing hard_header_len */
+         usbnet_change_mtu(pGobiDev->mpNetDev->net, pGobiDev->mpNetDev->net->mtu);
+         pGobiDev->mpNetDev->rx_urb_size = GOBI_MAX_SINGLE_PACKET_SIZE;
+         #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,12,0 ))
+         usbnet_update_max_qlen(pGobiDev->mpNetDev);
+         #endif
+         #endif
+         printk(KERN_INFO "RawIP mode\n" );
+      }
+      else
+      {
+         printk(KERN_INFO "Ethernet mode\n" );
+      }
+      if(pGobiDev->iQMUXEnable)
+      {
+         GobiUSBNetUpdateRxUrbSize(pGobiDev->mpNetDev->net,pGobiDev->ULDatagramSize);
+         CreateQMAPRxBuffer(pGobiDev);
+      }
+      else
+      {
+         GobiUSBNetUpdateRxUrbSize(pGobiDev->mpNetDev->net,GOBI_MAX_SINGLE_PACKET_SIZE);
+      }
+   }
+   if(pGobiDev)
+   {
+      if(pGobiDev)
+      {
+         DBG("Finish qcqmi(%s) task: %d %d\n",szQMIBusName,pGobiDev->iTaskID,status);
+         pGobiDev->task = NULL;
+         pGobiDev->iTaskID = -1;
+      }
+   }
+   #if _PROBE_LOCK_
+   up(&taskLoading);
+   #endif
+   if (status != 0)
+   {
+      // usbnet_disconnect() will call GobiNetDriverUnbind() which will call
+      // DeregisterQMIDevice() to clean up any partially created QMI device
+      if(pGobiDev->mbUnload >= eStatUnloading)
+      {
+         DBG("Device Disconnecting...\n");
+         return 0;
+      }
+      if((gobi_kthread_should_stop())||
+        signal_pending(current))
+      {
+         return 0;
+      }
+      if(pGobiDev)
+      {
+         if(IsDeviceDisconnect(pGobiDev))
+         {
+            DBG( "Device Disconnected!\n" );
+            return 0;
+         }
+         if(-ETIMEDOUT==status)
+         {
+            DBG( "Device usbnet_disconnect!\n" );
+            GobiUSBLockReset(pGobiDev->mUsb_Interface);
+            return 0;
+         }
+      }
+      if(pGobiDev->mbUnload >= eStatUnloading)
+      {
+         DBG("Device Disconnecting...\n");
+         return 0;
+      }
+      if((gobi_kthread_should_stop())||
+        signal_pending(current))
+      {
+         return 0;
+      }
+      if(-ETIMEDOUT==status)
+      {
+         GobiUSBLockReset(pGobiDev->mUsb_Interface);
+      }
+   }
+   
+   return 0;
+
+}
+
+/**************************************************/
+#ifdef CONFIG_PM
+bool bIsSuspend(sGobiUSBNet *pGobiDev)
+{
+   bool rc = false;
+   unsigned long flags = 0;
+   spin_lock_irqsave(&pGobiDev->sSuspendLock,flags);
+   rc = pGobiDev->bSuspend;
+   spin_unlock_irqrestore(&pGobiDev->sSuspendLock,flags);
+   return rc;
+}
+void SetCurrentSuspendStat(sGobiUSBNet *pGobiDev,bool bSuspend)
+{
+   unsigned long flags = 0;
+   spin_lock_irqsave(&pGobiDev->sSuspendLock,flags);
+   pGobiDev->bSuspend = bSuspend;
+   spin_unlock_irqrestore(&pGobiDev->sSuspendLock,flags);
+}
+
+/*===========================================================================
+METHOD:
+   GobiNetSuspend (Public Method)
+
+DESCRIPTION:
+   Stops QMI traffic while device is suspended
+
+PARAMETERS
+   pIntf          [ I ] - Pointer to interface
+   powerEvent     [ I ] - Power management event
+
+RETURN VALUE:
+   int - 0 for success
+         negative errno for failure
+===========================================================================*/
+int GobiNetSuspend(
+   struct usb_interface *     pIntf,
+   pm_message_t               powerEvent )
+{
+   struct usbnet * pDev;
+   sGobiUSBNet * pGobiDev;
+   int nRet = 0;
+
+   if (pIntf == 0)
+   {
+      return -ENOMEM;
+   }
+   DBG("\n");
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,23 ))
+   pDev = usb_get_intfdata( pIntf );
+#else
+   pDev = (struct usbnet *)pIntf->dev.platform_data;
+#endif
+
+   if (pDev == NULL || pDev->net == NULL)
+   {
+      DBG( "failed to get netdevice\n" );
+      return -ENXIO;
+   }
+
+   pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if (pGobiDev == NULL)
+   {
+      DBG( "failed to get QMIDevice\n" );
+      return -ENXIO;
+   }
+
+   #if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,33 ))
+   if (pDev->udev->auto_pm == 0)
+   #else
+   if ((powerEvent.event & PM_EVENT_AUTO) == 0)
+   #endif
+   {
+      DBG( "ConfigPowerSaveSettings\n" );
+      if(ConfigPowerSaveSettings(pGobiDev,QMIWDS,QMI_WDS_GET_PKT_SRVC_STATUS_IND)<0)
+         printk(KERN_ERR"Config Power Save Setting error 1\n");
+      if(ConfigPowerSaveSettings(pGobiDev,QMINAS,QMI_NAS_SERVING_SYSTEM_IND)<0)
+         printk(KERN_ERR"Config Power Save Setting error 2\n");
+      if(ConfigPowerSaveSettings(pGobiDev,QMIWMS,QMI_WMS_EVENT_REPORT_IND)<0)
+         printk(KERN_ERR"Config Power Save Setting error 3\n");
+      if(ConfigPowerSaveSettings(pGobiDev,QMIVOICE,QMI_VOICE_ALL_CALL_STATUS_IND)<0)
+         printk(KERN_ERR"Config Power Save Setting error 4\n");
+   }
+
+   if(SetPowerSaveMode(pGobiDev,1)<0)
+   {
+      printk(KERN_ERR"Suspend Set Power Save Mode error\n");
+   }
+   else
+   {
+      DBG( "Set Power Save Mode 1\n" );
+   }
+
+   SetCurrentSuspendStat(pGobiDev,1);
+
+   KillRead(pGobiDev);
+   
+   // Is this autosuspend or system suspend?
+   //    do we allow remote wakeup?
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,33 ))
+   if (pDev->udev->auto_pm == 0)
+#else
+   if ((powerEvent.event & PM_EVENT_AUTO) == 0)
+#endif
+   {
+      DBG( "device suspended to power level %d\n",
+           powerEvent.event );
+      GobiSetDownReason( pGobiDev, DRIVER_SUSPENDED );
+   }
+   else
+   {
+      DBG( "device autosuspend\n" );
+   }
+
+   if (powerEvent.event & PM_EVENT_SUSPEND)
+   {
+      // Stop QMI read callbacks
+      pDev->udev->reset_resume = 0;
+      DBG("suspend event = 0x%04x\n", powerEvent.event );
+      // Store power state to avoid duplicate resumes
+      pIntf->dev.power.power_state.event = powerEvent.event;
+   }
+   else
+   {
+      // Other power modes cause QMI connection to be lost
+      //pDev->udev->reset_resume = 0;
+   }
+
+   #if defined(USB_INTRF_FUNC_SUSPEND) && defined(USB_INTRF_FUNC_SUSPEND_RW)
+   /* send control message to resume from suspend mode for all interface. 
+      This is required by modem on USB3.0 selective suspend */
+   if ( pDev->udev->speed >= USB_SPEED_SUPER )
+   {
+      nRet = Gobi_usb_control_msg(pIntf,pDev->udev, usb_sndctrlpipe(pDev->udev, 0),
+                               USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
+                               USB_INTRF_FUNC_SUSPEND,
+                               USB_INTRF_FUNC_SUSPEND_RW | USB_INTRF_FUNC_SUSPEND_LP |
+                               pIntf->cur_altsetting->desc.bInterfaceNumber, /* two bytes in this field, suspend option(1 byte) | interface number(1 byte) */
+                               NULL, 0, USB_CTRL_SET_TIMEOUT);
+      if (nRet != 0)
+      {
+          DBG("[line:%d] send usb_control_msg failed!nRet = %d\n", __LINE__, nRet);
+      }
+   }
+   #endif
+   //USB/xhci: Enable remote wakeup for USB3 devices
+   if(iIsRemoteWakeupSupport(pDev))
+   {
+      nRet = Gobi_usb_control_msg(pIntf,pDev->udev, usb_sndctrlpipe(pDev->udev, 0),
+                                  USB_REQ_SET_FEATURE, USB_RECIP_DEVICE,
+                                  USB_DEVICE_REMOTE_WAKEUP,
+                                  0, //Don't care about which interface
+                                  NULL,
+                                  0,
+                                  USB_CTRL_SET_TIMEOUT);
+      if (nRet != 0)
+      {
+          DBG("[line:%d] send usb_control_msg failed!nRet = %d\n", __LINE__, nRet);
+      }
+   }
+   // Run usbnet's suspend function so that the kernel spin lock counter keeps balance
+   return usbnet_suspend( pIntf, powerEvent );
+}
+
+/*===========================================================================
+METHOD:
+   GobiNetResume (Public Method)
+
+DESCRIPTION:
+   Resume QMI traffic or recreate QMI device
+
+PARAMETERS
+   pIntf          [ I ] - Pointer to interface
+
+RETURN VALUE:
+   int - 0 for success
+         negative errno for failure
+===========================================================================*/
+int GobiNetResume( struct usb_interface * pIntf )
+{
+   struct usbnet * pDev;
+   sGobiUSBNet * pGobiDev;
+   int nRet= 0;
+   int oldPowerState;
+   DBG("\n");
+   if (pIntf == 0)
+   {
+      return -ENOMEM;
+   }
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,23 ))
+   pDev = usb_get_intfdata( pIntf );
+#else
+   pDev = (struct usbnet *)pIntf->dev.platform_data;
+#endif
+
+   if (pDev == NULL || pDev->net == NULL)
+   {
+      DBG( "failed to get netdevice\n" );
+      return -ENXIO;
+   }
+
+   pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if (pGobiDev == NULL)
+   {
+      DBG( "failed to get QMIDevice\n" );
+      return -ENXIO;
+   }
+
+   oldPowerState = pIntf->dev.power.power_state.event;
+   pIntf->dev.power.power_state.event = PM_EVENT_ON;
+   DBG( "resuming from power mode 0x%04x\n", oldPowerState );
+
+      // It doesn't matter if this is autoresume or system resume
+      GobiClearDownReason( pGobiDev, DRIVER_SUSPENDED );
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,29 ))
+      // Kick Auto PM thread to process any queued URBs
+      complete( &pGobiDev->mAutoPM.mThreadDoWork );
+#endif
+
+
+   SendWakeupControlMsg(pIntf,oldPowerState);
+   /* Run usbnet's resume function so that the kernel spin lock counter keeps balance */
+   nRet = usbnet_resume( pIntf );
+   if (nRet != 0)
+   {
+       DBG("[line:%d] usbnet_resume failed!nRet = %d\n", __LINE__, nRet);
+   }
+   SetCurrentSuspendStat(pGobiDev,0);
+   if(pGobiDev->mbUnload < eStatUnloading)
+   {
+      StartRead(pGobiDev);
+
+      if(SetPowerSaveMode(pGobiDev,0)<0)
+      {
+         printk(KERN_ERR" Resume Set Power Save Mode error\n");
+      }
+      else
+      {
+         DBG( "Set Power Save Mode 0\n" );
+      }
+   }
+   return nRet;
+}
+
+void GobiNetReset(struct usb_interface * pIntf)
+{
+    sGobiUSBNet * pGobiDev;
+    struct usbnet * pDev;
+    DBG("reset suspend");
+    #if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,23 ))
+    pDev = usb_get_intfdata( pIntf );
+    #else
+    pDev = (struct usbnet *)pIntf->dev.platform_data;
+    #endif
+    pGobiDev = (sGobiUSBNet *)pDev->data[0];
+    if (pGobiDev == NULL)
+   {
+       DBG( "failed to get QMIDevice\n" );
+       return;
+    }
+    //DeregisterQMIDevice(pGobiDev);
+    usbnet_disconnect(pIntf);
+    usb_set_intfdata(pIntf, NULL);
+}
+
+int GobiNetResetResume( struct usb_interface * pIntf )
+{
+   DBG("reset resume suspend\n");
+   if(pIntf->cur_altsetting->desc.bInterfaceNumber ==8)
+   {
+      struct usb_device *udev;
+      printk("Reset Device\n");
+      udev = interface_to_usbdev(pIntf);
+      usb_reset_device(udev);
+   }
+   return 0;
+}
+
+#endif /* CONFIG_PM */
+
+void UsbAutopmGetInterface(struct usb_interface * intf)
+{
+   #if (LINUX_VERSION_CODE < KERNEL_VERSION( 3,0,0 ))
+   gobi_usb_autopm_get_interface_async(intf);
+   #else
+   gobi_usb_autopm_get_interface_no_resume(intf); 
+   #endif
+}
+
+void UsbAutopmPutInterface(struct usb_interface * intf)
+{
+   #if (LINUX_VERSION_CODE < KERNEL_VERSION( 3,0,0 ))
+   gobi_usb_autopm_put_interface_async(intf);
+   #else
+   gobi_usb_autopm_put_interface_no_resume(intf); 
+   #endif
+}
+
+/* very simplistic detection of IPv4 or IPv6 headers */
+static bool possibly_iphdr(const char *data)
+{
+   return (data[0] & 0xd0) == 0x40;
+}
+
+u8 retrieveMuxID(struct sk_buff *skb, sGobiUSBNet *pGobiNet)
+{
+   u8 muxId = 0+MUX_ID_START;
+   unsigned int ipAddress = 0;
+   ipv6_addr *pIPv6Addr = NULL;
+   int i;
+   
+   switch (skb->data[0] & 0xf0) 
+   {
+      case 0x40:
+      {
+         ipAddress = ntohl(((qmap_ipv4_header_t)(skb->data))->src_address);
+         PrintIPAddr("Packet src IP address : ",  ipAddress);
+
+         for ( i = 0; i < MAX_MUX_NUMBER_SUPPORTED; i++ )
+         {
+            if ( ipAddress == pGobiNet->qMuxIPTable[i].ipAddress )
+            {
+               muxId += pGobiNet->qMuxIPTable[i].instance;
+               DBG("Mux ID found : 0x%02x\n",  muxId);
+               break;
+            }
+         }
+         break;
+      }
+      case 0x60:
+      {
+         pIPv6Addr = (ipv6_addr *)(((qmap_ipv6_header_t)(skb->data))->src_address);
+         NETDBG("Src IP addr:");
+         PrintIPV6Addr(pIPv6Addr);
+         for ( i = 0; i < MAX_MUX_NUMBER_SUPPORTED; i++ )
+         {
+            if (memcmp(pIPv6Addr, &pGobiNet->qMuxIPTable[i].ipV6Address.ipv6addr,IPV6_ADDR_LEN)==0 )
+            {
+               muxId += pGobiNet->qMuxIPTable[i].instance;
+               NETDBG("Mux ID found : 0x%02x\n",  muxId);
+               break;
+            }
+            else
+            {
+               if(iIsZeroIPv6Addr(&pGobiNet->qMuxIPTable[i].ipV6Address)==0)
+               {
+                  NETDBG("%d.Mux ID Not Match\n",  i);
+                  PrintIPV6Addr(&pGobiNet->qMuxIPTable[i].ipV6Address);
+               }
+            }
+         }
+         break;
+      }
+      default :
+      {
+         return muxId;
+      }
+   }
+   return muxId;
+}
+
+/*===========================================================================
+METHOD:
+   GobiNetDriverBind (Public Method)
+
+DESCRIPTION:
+   Setup in and out pipes
+
+PARAMETERS
+   pDev           [ I ] - Pointer to usbnet device
+   pIntf          [ I ] - Pointer to interface
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+static int GobiNetDriverBind(
+   struct usbnet *         pDev,
+   struct usb_interface *  pIntf )
+{
+   int numEndpoints;
+   int endpointIndex;
+   struct usb_host_endpoint * pEndpoint = NULL;
+   struct usb_host_endpoint * pIn = NULL;
+   struct usb_host_endpoint * pOut = NULL;
+
+   // Verify one altsetting
+   if (pIntf->num_altsetting != 1)
+   {
+      DBG( "invalid num_altsetting %u\n", pIntf->num_altsetting );
+      return -ENODEV;
+   }
+
+   /* We only accept certain interfaces */
+   if (pIntf->cur_altsetting->desc.bInterfaceClass != USB_CLASS_VENDOR_SPEC )
+   {
+      DBG( "Ignoring non vendor class interface #%d\n",
+           pIntf->cur_altsetting->desc.bInterfaceNumber );
+      return -ENODEV;
+   }
+   else if (pDev->driver_info->data &&
+          !test_bit(pIntf->cur_altsetting->desc.bInterfaceNumber, &pDev->driver_info->data)) {
+      DBG( "invalid interface %d\n",
+           pIntf->cur_altsetting->desc.bInterfaceNumber );
+      return -ENODEV;
+   }
+
+   // Collect In and Out endpoints
+   numEndpoints = pIntf->cur_altsetting->desc.bNumEndpoints;
+   for (endpointIndex = 0; endpointIndex < numEndpoints; endpointIndex++)
+   {
+      pEndpoint = pIntf->cur_altsetting->endpoint + endpointIndex;
+      if (pEndpoint == NULL)
+      {
+         DBG( "invalid endpoint %u\n", endpointIndex );
+         return -ENODEV;
+      }
+
+      if (usb_endpoint_dir_in( &pEndpoint->desc ) == true
+      &&  usb_endpoint_xfer_int( &pEndpoint->desc ) == false)
+      {
+         pIn = pEndpoint;
+      }
+      else if (usb_endpoint_dir_out( &pEndpoint->desc ) == true)
+      {
+         pOut = pEndpoint;
+      }
+   }
+
+   if (pIn == NULL || pOut == NULL)
+   {
+      DBG( "invalid endpoints\n" );
+      return -ENODEV;
+   }
+
+   if (usb_set_interface( pDev->udev,
+                          pIntf->cur_altsetting->desc.bInterfaceNumber,
+                          0 ) != 0)
+   {
+      DBG( "unable to set interface\n" );
+      return -ENODEV;
+   }
+
+   pDev->in = usb_rcvbulkpipe( pDev->udev,
+                   pIn->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK );
+   pDev->out = usb_sndbulkpipe( pDev->udev,
+                   pOut->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK );
+
+   DBG( "in %x, out %x\n",
+        pIn->desc.bEndpointAddress,
+        pOut->desc.bEndpointAddress );
+
+   // In later versions of the kernel, usbnet helps with this
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,23 ))
+   pIntf->dev.platform_data = (void *)pDev;
+#endif
+
+   /* make MAC addr easily distinguishable from an IP header */
+   if (possibly_iphdr(pDev->net->dev_addr)) {
+       pDev->net->dev_addr[0] |= 0x02;   /* set local assignment bit */
+       pDev->net->dev_addr[0] &= 0xbf;   /* clear "IP" bit */
+   }
+
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   GobiNetDriverUnbind (Public Method)
+
+DESCRIPTION:
+   Deregisters QMI device (Registration happened in the probe function)
+
+PARAMETERS
+   pDev           [ I ] - Pointer to usbnet device
+   pIntfUnused    [ I ] - Pointer to interface
+
+RETURN VALUE:
+   None
+===========================================================================*/
+static void GobiNetDriverUnbind(
+   struct usbnet *         pDev,
+   struct usb_interface *  pIntf)
+{
+   sGobiUSBNet * pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if(pGobiDev == NULL)
+   {
+       return ;
+   }
+   // Should already be down, but just in case...
+   gobi_netif_stop_queue(pDev->net);
+   netif_carrier_off( pDev->net );
+   gobi_netif_stop_queue(pGobiDev->mpNetDev->net);
+   netif_carrier_off(pGobiDev->mpNetDev->net);
+   gobi_dev_deactivate(pDev->net);
+
+   DeregisterQMIDevice( pGobiDev );
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,29 ))
+   kfree( pDev->net->netdev_ops );
+   pDev->net->netdev_ops = NULL;
+#endif
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,23 ))
+   pIntf->dev.platform_data = NULL;
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,19 ))
+   pIntf->needs_remote_wakeup = 0;
+#endif
+
+   kfree( pGobiDev );
+   pGobiDev = NULL;
+}
+
+/*===========================================================================
+METHOD:
+   GobiNetDriverTxFixup (Public Method)
+
+DESCRIPTION:
+   Handling data format mode on transmit path
+
+PARAMETERS
+   pDev           [ I ] - Pointer to usbnet device
+   pSKB           [ I ] - Pointer to transmit packet buffer
+   flags          [ I ] - os flags
+
+RETURN VALUE:
+   None
+===========================================================================*/
+struct sk_buff *GobiNetDriverTxFixup(
+   struct usbnet  *pDev, 
+   struct sk_buff *pSKB,
+   gfp_t flags)
+{
+   struct sGobiUSBNet * pGobiDev;
+   DBG( "\n" );
+   pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if (pGobiDev == NULL)
+   {
+      DBG( "failed to get QMIDevice\n" );
+      return NULL;
+   }
+   #ifdef CONFIG_PM
+   if(bIsSuspend(pGobiDev))
+   {
+      DBG("Suspended\n");
+      UsbAutopmGetInterface( pGobiDev->mpIntf );
+      UsbAutopmPutInterface( pGobiDev->mpIntf );
+   }
+   #else
+   DBG( "\n" );
+   #endif
+   if(pGobiDev->iStoppingNetDev==1)
+   {
+      DBG( "Device Disconnecting\n" );
+      dev_kfree_skb_any(pSKB);
+      return NULL;
+   }
+   if((pGobiDev->iQMUXEnable!=0)&&(pGobiDev->iIPAlias==0)&&iIsValidQmuxSKB(pSKB))
+   {
+     if((pSKB->data[0]==00)
+         &&(pSKB->data[1]&0x8F))
+      {
+         DBG( "QMUX For sending to device");
+         //PrintHex (pSKB->data, pSKB->len);
+         return pSKB;
+      }
+   }
+   else if(pGobiDev->iQMUXEnable!=0)
+   {
+      struct gobi_qmimux_hdr *hdr;
+      unsigned int len = 0;
+      unsigned short muxId;
+
+      skb_pull(pSKB, ETH_HLEN);
+      skb_reset_mac_header(pSKB);
+      skb_reset_network_header(pSKB);
+      skb_reset_transport_header(pSKB);
+      if((pGobiDev->iIPAlias!=0)&&(pSKB->len > ETH_HLEN))
+      {
+         muxId = retrieveMuxID(pSKB, pGobiDev);
+         hdr = (struct gobi_qmimux_hdr *)skb_push(pSKB, sizeof(struct gobi_qmimux_hdr));
+         len = pSKB->len - sizeof(struct gobi_qmimux_hdr);
+         hdr->pad = 0;
+         hdr->mux_id = muxId;
+         hdr->pkt_len = cpu_to_be16(len);
+         NETDBG( "QMUX ETH 0x%02x\n", muxId);
+         NetHex (pSKB->data, pSKB->len);
+         return pSKB;
+      }
+      else if((pGobiDev->iIPAlias==0)&&(pSKB->len > ETH_HLEN))
+      {
+         muxId = 0;
+         hdr = (struct gobi_qmimux_hdr *)skb_push(pSKB, sizeof(struct gobi_qmimux_hdr));
+         len = pSKB->len - sizeof(struct gobi_qmimux_hdr);
+         hdr->pad = 0;
+         hdr->mux_id = muxId;
+         hdr->pkt_len = cpu_to_be16(len);
+         NETDBG( "QMUX ETH 0x%02x\n", muxId);
+         NetHex (pSKB->data, pSKB->len);
+         return pSKB;
+      }
+   }
+   if((pGobiDev->iNetLinkStatus!=eNetDeviceLink_Connected)&&(pGobiDev->iQMUXEnable==0))
+   {
+      DBG( "Dropped Packet : Not Connected\n" );
+      dev_kfree_skb_any(pSKB);
+      return NULL;
+   }
+   if(pGobiDev->iDataMode != eDataMode_RAWIP)
+   {
+      return pSKB;
+   }
+   if (pSKB->len > ETH_HLEN)
+   {
+
+      // Skip Ethernet header from message
+      if (skb_pull(pSKB, ETH_HLEN))
+      {
+         DBG( "For sending to device modified: ");
+         skb_reset_mac_header(pSKB);
+         skb_reset_network_header(pSKB);
+         skb_reset_transport_header(pSKB);
+         PrintHex (pSKB->data, pSKB->len);
+         return pSKB;
+      }
+      else
+      {
+         DBG( "Packet Dropped ");
+      }
+   }
+   else
+   {
+      DBG( "Packet Dropped Length");
+   }
+
+   // Filter the packet out, release it
+   dev_kfree_skb_any(pSKB);
+   return NULL;
+}
+
+/*===========================================================================
+METHOD:
+   GobiNetDriverRxQMAPFixup (Public Method)
+
+DESCRIPTION:
+   Handling QAMP frame packets in SKB buffer.
+
+PARAMETERS
+   pDev           [ I ] - Pointer to usbnet device
+   pSKB           [ I ] - Pointer to received packet buffer
+
+RETURN VALUE:
+   None
+===========================================================================*/
+static int GobiNetDriverRxQMAPFixup(struct usbnet  *pDev, 
+    struct sk_buff *pSKB)
+{
+   sGobiUSBNet  *pGobiDev;
+   u8 u8AdaptorMuxID=0;
+   struct net_device *pNetDev=NULL;
+   int offset = 0;
+   int iPackets = iNumberOfQmuxPacket(pSKB,0);
+   u32 length = 0;
+   if(iPackets==0)
+   {
+      if(iIsCMDQMAPHeaderInSKBData(pSKB,0)!=1)
+      {
+         printk("\n iPackets :0\n");
+         NetHex(pSKB->data,pSKB->len);
+      }
+      return 0;
+   }
+   pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if((pGobiDev->iQMUXEnable==0) || (iIsValidQmuxSKB(pSKB)==0))
+   {
+      return 0;
+   }
+   do 
+   {
+      struct sk_buff *nskb =NULL;
+      u8AdaptorMuxID = 0;
+      if(iIsValidQMAPHeaderInSKBData(pSKB,offset)==0)
+      {
+         if(iIsZeroQMAPHeaderInSKBData(pSKB,offset)==1)
+         {
+             return 0;
+         }
+         else
+         {
+            printk("\n Drop Packet Orginal Length:0x%x\n",pSKB->len);
+            ErrHex(pSKB->data,pSKB->len);
+            printk("\n Drop Packet offset : 0x%x\n",offset);
+            ErrHex(pSKB->data+offset,pSKB->len-offset);
+            return 0;
+         }
+      }
+      length = pSKB->data[2+offset];
+      length = (length<<8) + pSKB->data[offset+3];
+      pNetDev = pDev->net;
+      if(length>0)
+      {
+         u32 copylength=0;
+         if((length+offset)>pSKB->len)
+         {
+            copylength = pSKB->len - offset;
+            nskb = pGobiDev->pLastSKB;
+            memcpy(nskb->data,pSKB->data+offset,copylength);
+            nskb->len = copylength;
+            pGobiDev->iPacketInComplete = 1;
+            pGobiDev->pLastSKB = nskb;
+            NETDBG("\n Rx skb len:%d MUX totoal len :%d\n",nskb->len,length);
+            return 0;
+         }
+         else
+         {
+            copylength = length + QMUX_HEADER_LENGTH;
+            nskb = skb_copy(pSKB,GFP_ATOMIC);
+            skb_pull(nskb,offset);
+            skb_trim(nskb,copylength);
+         }
+
+         if(nskb!=NULL)
+         {
+            int result = 0;
+            nskb->dev = pSKB->dev;
+            if((nskb->data[1]&0x8F))
+            {
+               pNetDev = nskb->dev = pDev->net;
+               u8AdaptorMuxID = 0;
+               if(pGobiDev->iIPAlias==0)
+               {
+                  if((nskb->data[1]>=0x80) &&
+                     (nskb->data[1] <0x90))
+                  {
+                     u8AdaptorMuxID =nskb->data[1];
+                     pNetDev = nskb->dev = pGobiDev->pNetDevice[u8AdaptorMuxID-MUX_ID_START];
+                  }
+               }
+            }
+            if(iIsQmuxPacketComplete(nskb)!=1)
+            {
+               pGobiDev->iPacketInComplete = 1;
+               pGobiDev->pLastSKB = nskb;
+               NETDBG("\n Rx skb len:%d MUX totoal len :%d\n",nskb->len,length);
+               return 0;
+            }
+            else
+            {
+               pGobiDev->iPacketInComplete = 0;
+            }
+            if(iRemoveQMAPPaddingBytes(nskb)!=0)
+            {
+               NETDBG("Remove Padding Error\n");
+               return 0;
+            }
+            /* Copy data section to a temporary buffer */
+
+            gobi_skb_push(nskb,ETH_HLEN);
+            
+            if (((*(u8 *)(nskb->data + ETH_HLEN)) & 0xF0) == 0x40)
+            {
+               ResetEthHeader(pDev,nskb,1,u8AdaptorMuxID);
+            }
+            else if(((*(u8 *)(nskb->data + ETH_HLEN)) & 0xF0) == 0x60)
+            {
+               ResetEthHeader(pDev,nskb,0,u8AdaptorMuxID);
+            }
+            else
+            {
+               skb_reset_mac_header(nskb);
+               skb_reset_network_header(nskb);
+               skb_reset_transport_header(nskb);
+            }
+            DBG( "Remove MuxID From Modem modified: ");
+            PrintHex (nskb->data, nskb->len);
+            if(pGobiDev->iIPAlias==0)
+            {
+               result = gobi_dev_forward_skb(pNetDev,nskb);
+               if ( result != NET_RX_SUCCESS)
+               {
+                  NETDBG("!netif_rx NET_RX_SUCCESS: %d\n",result);
+               }
+               else
+               {
+                  NETDBG( "netif_rx NET_RX_SUCCESS\n" );
+               }
+            }
+            else
+            {
+               usbnet_skb_return(pDev,nskb);
+            }
+         } 
+      }
+      offset += length+QMUX_HEADER_LENGTH;
+   }while (offset<pSKB->len);
+   return 1;
+}
+
+/*===========================================================================
+METHOD:
+   GobiNetDriverRxFixup (Public Method)
+
+DESCRIPTION:
+   Handling data format mode on receive path
+
+PARAMETERS
+   pDev           [ I ] - Pointer to usbnet device
+   pSKB           [ I ] - Pointer to received packet buffer
+
+RETURN VALUE:
+   None
+===========================================================================*/
+static int GobiNetDriverRxFixup(
+    struct usbnet  *pDev, 
+    struct sk_buff *pSKB )
+{
+    sGobiUSBNet  *pGobiDev;
+    struct ethhdr *pEth;
+    struct iphdr *pIp;
+    DBG( "\n" );
+
+   /* This check is no longer done by usbnet after 3.13*/ 
+   if (pSKB->len < pDev->net->hard_header_len)
+   {
+      printk( "Packet Dropped \n" );
+      return 0;
+   }
+   pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if (pGobiDev == NULL)
+   {
+      DBG( "failed to get Device\n" );
+      return -ENXIO;
+   }
+   #ifdef CONFIG_PM
+   if(bIsSuspend(pGobiDev))
+   {
+      DBG("Suspended\n");
+      UsbAutopmGetInterface( pGobiDev->mpIntf );
+      UsbAutopmPutInterface( pGobiDev->mpIntf );
+    }
+    #endif
+   if(pGobiDev->iQMUXEnable!=0)
+   {
+      int iPackets = iNumberOfQmuxPacket(pSKB,1);
+      NETDBG("RX:%d , Packets:%d\n",pSKB->len,iPackets);
+      NetHex(pSKB->data,pSKB->len);
+      if(pGobiDev->iPacketInComplete==0)
+      {      
+         if(iPackets>0)
+         {
+            PrintQmuxPacket(pSKB);
+            GobiNetDriverRxQMAPFixup(pDev,pSKB);
+         }
+         else
+         {
+            if((iIsZeroQMAPHeaderInSKBData(pSKB,0)!=1))
+            {
+               if(iIsCMDQMAPHeaderInSKBData(pSKB,0)!=1)
+               {
+                  printk("iPackets :0\n");
+                  ErrHex(pSKB->data,pSKB->len);
+               }
+               else
+               {
+                  //Handle Command;
+               }
+            }      
+         }
+      }
+      else if(pGobiDev->iPacketInComplete==1)
+      {
+         struct sk_buff *skb = NULL;
+         unsigned int offset = 0;
+         u32 length = 0;
+         u32 newlength = 0;
+         length = u32GetSKBQMAPPacketLength(pGobiDev->pLastSKB,0);
+         offset = pGobiDev->pLastSKB->len;
+         NETDBG("\nLast SKB Len:%d, MUX Length:%d\n",pGobiDev->pLastSKB->len, length);
+         newlength = pGobiDev->pLastSKB->len + pSKB->len;
+         if(((length+QMUX_HEADER_LENGTH)<=newlength)&&(length>0))
+         {
+             
+             skb =  skb_copy(pSKB,GFP_ATOMIC);
+             gobi_skb_push(pSKB,pGobiDev->pLastSKB->len);
+             memcpy(skb->data,pGobiDev->pLastSKB->data, pGobiDev->pLastSKB->len);
+             pGobiDev->iPacketInComplete = 0;
+             pGobiDev->pLastSKB->len=0;
+             NETDBG("\nResume length:%d/Last SKB Len:%d/Rx SKB Len%d\n",length,skb->len,pSKB->len);
+             PrintQmuxPacket(skb);
+             //NetHex (skb->data, skb->len);
+             GobiNetDriverRxQMAPFixup(pDev,skb);
+             dev_kfree_skb_any(skb);
+         }
+         else
+         {
+            memcpy(pGobiDev->pLastSKB->data+offset,pSKB->data, pSKB->len);
+            pGobiDev->pLastSKB->len = pGobiDev->pLastSKB->len + pSKB->len;
+            NETDBG("\nAppend length:%d/Last SKB Len:%d/Rx SKB Len%d\n",length,pGobiDev->pLastSKB->len,pSKB->len);
+            //NetHex (skb->data, skb->len);
+            pGobiDev->iPacketInComplete = 1;
+            pGobiDev->pLastSKB->dev = pDev->net;
+            PrintQmuxPacket(pGobiDev->pLastSKB);
+         }
+      }
+      else
+      {
+         if(iIsZeroQMAPHeaderInSKBData(pSKB,0)!=1)
+         {
+            if(iIsCMDQMAPHeaderInSKBData(pSKB,0)!=1)
+            {
+               NETDBG("QMAP CMD:");
+               NetHex (pSKB->data, pSKB->len);
+            }
+            else
+            {
+               printk("Unknown packet:\n");
+               ErrHex(pSKB->data,pSKB->len);
+               printk("\n");
+            }
+         }
+      }
+      return 1;
+   }
+   else if(pGobiDev->iNetLinkStatus!=eNetDeviceLink_Connected)
+   {
+      DBG( "Dropped Packet : Not Connected\n" );
+      return 0;
+   }
+
+    DBG( "RX From Device: ");
+    PrintHex (pSKB->data, pSKB->len);
+   
+   if(pSKB->truesize < ETH_HLEN+pSKB->len)
+   {
+      DBG( "DROP PACKET %d < %d\n",pSKB->truesize,ETH_HLEN+pSKB->len );
+      return 0;
+   }
+    /* Copy data section to a temporary buffer */
+    gobi_skb_push(pSKB,ETH_HLEN);
+    
+    if (((*(u8 *)(pSKB->data + ETH_HLEN)) & 0xF0) == 0x40)
+    {
+       ResetEthHeader(pDev,pSKB,1,0);
+       return 1;
+    }
+    else if(((*(u8 *)(pSKB->data + ETH_HLEN)) & 0xF0) == 0x60)
+    {
+       ResetEthHeader(pDev,pSKB,0,0);
+       return 1;
+    }
+    else
+    {
+       skb_reset_mac_header(pSKB);
+       skb_reset_network_header(pSKB);
+       skb_reset_transport_header(pSKB);
+    }
+
+
+    pSKB->dev = pDev->net;
+
+    /* If the packet is IPv4 then add corresponding Ethernet header */
+    if (((*(u8 *)(pSKB->data + ETH_HLEN)) & 0xF0) == 0x40)
+    {
+        /* IPV4 packet  */
+        memcpy(pSKB->data, pGobiDev->eth_hdr_tmpl_ipv4, ETH_HLEN);
+        pSKB->protocol = cpu_to_be16(ETH_P_IP);
+        DBG( "IPv4 header added: ");
+    }
+   else if (((*(u8 *)(pSKB->data + ETH_HLEN)) & 0xF0) == 0x60)
+    {
+        memcpy(pSKB->data, pGobiDev->eth_hdr_tmpl_ipv6, ETH_HLEN);
+        pSKB->protocol = cpu_to_be16(ETH_P_IPV6);
+        DBG( "IPv6 header added: ");
+    }
+
+    pIp = (struct iphdr *)((char *)pSKB->data + ETH_HLEN);
+    if(pIp->version == 6) 
+    {
+        pEth = (struct ethhdr *)pSKB->data;
+        pEth->h_proto = cpu_to_be16(ETH_P_IPV6);
+    }
+
+    else if(pIp->version == 4) 
+    {
+        pEth = (struct ethhdr *)pSKB->data;
+        pEth->h_proto = cpu_to_be16(ETH_P_IP);
+    }
+
+    PrintHex (pSKB->data, pSKB->len + ETH_HLEN);
+
+    return 1;
+}
+
+#ifdef CONFIG_PM
+/*===========================================================================
+METHOD:
+   GobiUSBNetURBCallback (Public Method)
+
+DESCRIPTION:
+   Write is complete, cleanup and signal that we're ready for next packet
+
+PARAMETERS
+   pURB     [ I ] - Pointer to sAutoPM struct
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void GobiUSBNetURBCallback( struct urb * pURB )
+{
+   unsigned long activeURBflags;
+   sAutoPM * pAutoPM = (sAutoPM *)pURB->context;
+   if (pAutoPM == NULL)
+   {
+      // Should never happen
+      DBG( "bad context\n" );
+      return;
+   }
+
+   if (pURB->status != 0)
+   {
+      // Note that in case of an error, the behaviour is no different
+      DBG( "urb finished with error %d\n", pURB->status );
+   }
+
+   // Remove activeURB (memory to be freed later)
+   spin_lock_irqsave( &pAutoPM->mActiveURBLock, activeURBflags );
+
+   // EAGAIN used to signify callback is done
+   pAutoPM->mpActiveURB = ERR_PTR( -EAGAIN );
+
+   spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+
+   complete( &pAutoPM->mThreadDoWork );
+
+   usb_free_urb( pURB );
+}
+
+/*===========================================================================
+METHOD:
+   GobiUSBNetTXTimeout (Public Method)
+
+DESCRIPTION:
+   Timeout declared by the net driver.  Stop all transfers
+
+PARAMETERS
+   pNet     [ I ] - Pointer to net device
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void GobiUSBNetTXTimeout( struct net_device * pNet )
+{
+   struct sGobiUSBNet * pGobiDev;
+   sAutoPM * pAutoPM;
+   sURBList * pURBListEntry;
+   unsigned long activeURBflags, URBListFlags;
+   struct usbnet * pDev = NULL;
+   struct urb * pURB;
+
+   if(pNet==NULL)
+   {
+      DBG( "GobiUSBNetTXTimeout failed to get Net\n" );
+      return;
+   }
+   pDev = netdev_priv( pNet );
+   if (pDev == NULL || pDev->net == NULL)
+   {
+      DBG( "failed to get usbnet device\n" );
+      return;
+   }
+
+   pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if (pGobiDev == NULL)
+   {
+      DBG( "failed to get QMIDevice\n" );
+      return;
+   }
+   pAutoPM = &pGobiDev->mAutoPM;
+
+   DBG( "\n" );
+
+   // Grab a pointer to active URB
+   spin_lock_irqsave( &pAutoPM->mActiveURBLock, activeURBflags );
+   pURB = pAutoPM->mpActiveURB;
+   spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+   // Stop active URB
+   if (pURB != NULL)
+   {
+      usb_kill_urb( pURB );
+   }
+
+   // Cleanup URB List
+   spin_lock_irqsave( &pAutoPM->mURBListLock, URBListFlags );
+
+   pURBListEntry = pAutoPM->mpURBList;
+   while (pURBListEntry != NULL)
+   {
+      pAutoPM->mpURBList = pAutoPM->mpURBList->mpNext;
+      atomic_dec( &pAutoPM->mURBListLen );
+      usb_free_urb( pURBListEntry->mpURB );
+      kfree( pURBListEntry );
+      pURBListEntry = pAutoPM->mpURBList;
+   }
+
+   spin_unlock_irqrestore( &pAutoPM->mURBListLock, URBListFlags );
+
+   complete( &pAutoPM->mThreadDoWork );
+
+   return;
+}
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,29 ))
+/*===========================================================================
+METHOD:
+   GobiUSBNetAutoPMThread (Public Method)
+
+DESCRIPTION:
+   Handle device Auto PM state asynchronously
+   Handle network packet transmission asynchronously
+
+PARAMETERS
+   pData     [ I ] - Pointer to sAutoPM struct
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+static int GobiUSBNetAutoPMThread( void * pData )
+{
+   unsigned long activeURBflags, URBListFlags;
+   sURBList * pURBListEntry;
+   int status;
+   struct usb_device * pUdev;
+   sAutoPM * pAutoPM = (sAutoPM *)pData;
+   struct urb * pURB;
+
+   if (pAutoPM == NULL)
+   {
+      DBG( "passed null pointer\n" );
+      return -EINVAL;
+   }
+
+   pUdev = interface_to_usbdev( pAutoPM->mpIntf );
+
+   DBG( "traffic thread started\n" );
+
+   while (pAutoPM->mbExit == false)
+   {
+      // Wait for someone to poke us
+      wait_for_completion_interruptible( &pAutoPM->mThreadDoWork );
+
+      // Time to exit?
+      if (pAutoPM->mbExit == true)
+      {
+         // Stop activeURB
+         spin_lock_irqsave( &pAutoPM->mActiveURBLock, activeURBflags );
+         pURB = pAutoPM->mpActiveURB;
+         spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+
+         // EAGAIN used to signify callback is done
+         if (IS_ERR( pAutoPM->mpActiveURB )
+                 &&  PTR_ERR( pAutoPM->mpActiveURB ) == -EAGAIN )
+         {
+             pURB = NULL;
+         }
+
+         if (pURB != NULL)
+         {
+            usb_kill_urb( pURB );
+         }
+         // Will be freed in callback function
+
+         // Cleanup URB List
+         spin_lock_irqsave( &pAutoPM->mURBListLock, URBListFlags );
+
+         pURBListEntry = pAutoPM->mpURBList;
+         while (pURBListEntry != NULL)
+         {
+            pAutoPM->mpURBList = pAutoPM->mpURBList->mpNext;
+            atomic_dec( &pAutoPM->mURBListLen );
+            usb_free_urb( pURBListEntry->mpURB );
+            kfree( pURBListEntry );
+            pURBListEntry = pAutoPM->mpURBList;
+         }
+
+         spin_unlock_irqrestore( &pAutoPM->mURBListLock, URBListFlags );
+
+         break;
+      }
+
+      // Is our URB active?
+      spin_lock_irqsave( &pAutoPM->mActiveURBLock, activeURBflags );
+
+      // EAGAIN used to signify callback is done
+      if (IS_ERR( pAutoPM->mpActiveURB )
+      &&  PTR_ERR( pAutoPM->mpActiveURB ) == -EAGAIN )
+      {
+         pAutoPM->mpActiveURB = NULL;
+
+         // Restore IRQs so task can sleep
+         spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+
+         // URB is done, decrement the Auto PM usage count
+         gobi_usb_autopm_put_interface( pAutoPM->mpIntf );
+
+         // Lock ActiveURB again
+         spin_lock_irqsave( &pAutoPM->mActiveURBLock, activeURBflags );
+      }
+
+      if (pAutoPM->mpActiveURB != NULL)
+      {
+         // There is already a URB active, go back to sleep
+         spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+         continue;
+      }
+
+      // Is there a URB waiting to be submitted?
+      spin_lock_irqsave( &pAutoPM->mURBListLock, URBListFlags );
+      if (pAutoPM->mpURBList == NULL)
+      {
+         // No more URBs to submit, go back to sleep
+         spin_unlock_irqrestore( &pAutoPM->mURBListLock, URBListFlags );
+         spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+         continue;
+      }
+
+      // Pop an element
+      pURBListEntry = pAutoPM->mpURBList;
+      pAutoPM->mpURBList = pAutoPM->mpURBList->mpNext;
+      atomic_dec( &pAutoPM->mURBListLen );
+      spin_unlock_irqrestore( &pAutoPM->mURBListLock, URBListFlags );
+
+      // Set ActiveURB
+      pAutoPM->mpActiveURB = pURBListEntry->mpURB;
+      spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+
+      // Tell autopm core we need device woken up
+      status = gobi_usb_autopm_get_interface( pAutoPM->mpIntf );
+      if (status < 0)
+      {
+         DBG( "unable to autoresume interface: %d\n", status );
+
+         // likely caused by device going from autosuspend -> full suspend
+         if (status == -EPERM)
+         {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,33 ))
+            pUdev->auto_pm = 0;
+#endif
+            GobiNetSuspend( pAutoPM->mpIntf, PMSG_SUSPEND );
+         }
+
+         // Add pURBListEntry back onto pAutoPM->mpURBList
+         spin_lock_irqsave( &pAutoPM->mURBListLock, URBListFlags );
+         pURBListEntry->mpNext = pAutoPM->mpURBList;
+         pAutoPM->mpURBList = pURBListEntry;
+         atomic_inc( &pAutoPM->mURBListLen );
+         spin_unlock_irqrestore( &pAutoPM->mURBListLock, URBListFlags );
+
+         spin_lock_irqsave( &pAutoPM->mActiveURBLock, activeURBflags );
+         pAutoPM->mpActiveURB = NULL;
+         spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+
+         // Go back to sleep
+         continue;
+      }
+
+      // Submit URB
+      status = usb_submit_urb( pAutoPM->mpActiveURB, GOBI_GFP_KERNEL );
+      if (status < 0)
+      {
+         // Could happen for a number of reasons
+         DBG( "Failed to submit URB: %d.  Packet dropped\n", status );
+         spin_lock_irqsave( &pAutoPM->mActiveURBLock, activeURBflags );
+         usb_free_urb( pAutoPM->mpActiveURB );
+         pAutoPM->mpActiveURB = NULL;
+         spin_unlock_irqrestore( &pAutoPM->mActiveURBLock, activeURBflags );
+         gobi_usb_autopm_put_interface( pAutoPM->mpIntf );
+
+         // Loop again
+         complete( &pAutoPM->mThreadDoWork );
+      }
+
+      kfree( pURBListEntry );
+   }
+
+   DBG( "traffic thread exiting\n" );
+   pAutoPM->mpThread = NULL;
+   return 0;
+}
+#endif //#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,29 ))
+/*===========================================================================
+METHOD:
+   GobiUSBNetStartXmit (Public Method)
+
+DESCRIPTION:
+   Convert sk_buff to usb URB and queue for transmit
+
+PARAMETERS
+   pNet     [ I ] - Pointer to net device
+
+RETURN VALUE:
+   NETDEV_TX_OK on success
+   NETDEV_TX_BUSY on error
+===========================================================================*/
+int GobiUSBNetStartXmit(
+   struct sk_buff *     pSKB,
+   struct net_device *  pNet )
+{
+   unsigned long URBListFlags;
+   struct sGobiUSBNet * pGobiDev;
+   sAutoPM * pAutoPM;
+   sURBList * pURBListEntry, ** ppURBListEnd;
+   void * pURBData;
+   struct usbnet * pDev = NULL;
+   struct driver_info *info;
+
+   DBG( "\n" );
+   if(pNet==NULL)
+   {
+      DBG( "GobiUSBNetStartXmit failed to get Net\n" );
+      return -ENXIO;
+   }   
+   pDev = netdev_priv( pNet );
+   if (pDev == NULL || pDev->net == NULL)
+   {
+      DBG( "failed to get usbnet device\n" );
+      return NETDEV_TX_BUSY;
+   }
+
+   pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if (pGobiDev == NULL)
+   {
+      DBG( "failed to get QMIDevice\n" );
+      return NETDEV_TX_BUSY;
+   }
+   /* send out the packet when data connection status is connected */
+   if ( pGobiDev->bLinkState == false)
+   {
+       return NET_XMIT_DROP;
+   }
+   pAutoPM = &pGobiDev->mAutoPM;
+
+   if( NULL == pSKB )
+   {
+       DBG( "Buffer is NULL \n" );
+       return NETDEV_TX_BUSY;
+   }
+
+   if (GobiTestDownReason( pGobiDev, DRIVER_SUSPENDED ) == true)
+   {
+      // Should not happen
+      DBG( "device is suspended\n" );
+      dump_stack();
+      return NETDEV_TX_BUSY;
+   }
+
+   // Convert the sk_buff into a URB
+
+   // Check if buffer is full
+   pGobiDev->tx_qlen  = atomic_read( &pAutoPM->mURBListLen );
+   if ( pGobiDev->tx_qlen >= txQueueLength)
+   {
+      DBG( "not scheduling request, buffer is full\n" );
+      return NETDEV_TX_BUSY;
+   }
+
+   if(pGobiDev->iDataMode==eDataMode_RAWIP)
+   {
+      info = pDev->driver_info;
+      if (info->tx_fixup)
+      {
+         pSKB = info->tx_fixup( pDev, pSKB, GOBI_GFP_ATOMIC);
+         if (pSKB == NULL)
+         {
+            DBG( "unable to tx_fixup skb\n" );
+            return NETDEV_TX_BUSY;
+         }
+      }
+   }
+   // Allocate URBListEntry
+   pURBListEntry = kmalloc( sizeof( sURBList ), GOBI_GFP_ATOMIC );
+   if (pURBListEntry == NULL)
+   {
+      DBG( "unable to allocate URBList memory\n" );
+      if (pSKB)
+         dev_kfree_skb_any ( pSKB );
+      return NETDEV_TX_BUSY;
+   }
+   pURBListEntry->mpNext = NULL;
+
+   // Allocate URB
+   pURBListEntry->mpURB = usb_alloc_urb( 0, GOBI_GFP_ATOMIC );
+   if (pURBListEntry->mpURB == NULL)
+   {
+      DBG( "unable to allocate URB\n" );
+      // release all memory allocated by now 
+      if (pURBListEntry)
+         kfree( pURBListEntry );
+      if (pSKB)
+         dev_kfree_skb_any ( pSKB );
+      return NETDEV_TX_BUSY; 
+   }
+   // Allocate URB transfer_buffer
+   pURBData = kmalloc( pSKB->len, GOBI_GFP_ATOMIC );
+   if (pURBData == NULL)
+   {
+      DBG( "unable to allocate URB data\n" );
+      // release all memory allocated by now
+      if (pURBListEntry)
+      {
+         usb_free_urb(pURBListEntry->mpURB);
+         kfree( pURBListEntry );
+      }
+      if (pSKB)
+         dev_kfree_skb_any ( pSKB );
+      return NETDEV_TX_BUSY; 
+ 
+   }
+   // Fill with SKB's data
+   memcpy( pURBData, pSKB->data, pSKB->len );
+
+   usb_fill_bulk_urb( pURBListEntry->mpURB,
+                      pGobiDev->mpNetDev->udev,
+                      pGobiDev->mpNetDev->out,
+                      pURBData,
+                      pSKB->len,
+                      GobiUSBNetURBCallback,
+                      pAutoPM );
+
+   /* Handle the need to send a zero length packet and release the
+    * transfer buffer
+    */
+    pURBListEntry->mpURB->transfer_flags |= (URB_ZERO_PACKET | URB_FREE_BUFFER);
+
+   // Aquire lock on URBList
+   spin_lock_irqsave( &pAutoPM->mURBListLock, URBListFlags );
+
+   // Add URB to end of list
+   ppURBListEnd = &pAutoPM->mpURBList;
+   while ((*ppURBListEnd) != NULL)
+   {
+      ppURBListEnd = &(*ppURBListEnd)->mpNext;
+   }
+   *ppURBListEnd = pURBListEntry;
+   atomic_inc( &pAutoPM->mURBListLen );
+
+   spin_unlock_irqrestore( &pAutoPM->mURBListLock, URBListFlags );
+
+   complete( &pAutoPM->mThreadDoWork );
+
+   // Free SKB
+   if (pSKB)
+      dev_kfree_skb_any ( pSKB );
+
+   return NETDEV_TX_OK;
+}
+#endif /* CONFIG_PM */
+
+int GobiUSBNetUpdateRxUrbSize(struct net_device *net, u32 target_rx_urb_size)
+{
+   struct usbnet   *dev = netdev_priv(net);
+   u32   old_rx_urb_size = dev->rx_urb_size;
+   u32   new_rx_urb_size = 4000;
+   if(target_rx_urb_size>new_rx_urb_size)
+      new_rx_urb_size = target_rx_urb_size;
+   if(new_rx_urb_size>QMAP_SIZE_OF_RX_BUFFER)
+   {
+      printk("WARN: rx_urb_size %u > %u",new_rx_urb_size,(u32)QMAP_SIZE_OF_RX_BUFFER);
+   }
+   if (dev->rx_urb_size < new_rx_urb_size) 
+   {
+      dev->rx_urb_size = new_rx_urb_size;
+      if (dev->rx_urb_size > old_rx_urb_size) {
+         #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,32 ))
+         usbnet_pause_rx(dev);
+         #endif
+         usbnet_unlink_rx_urbs(dev);
+         #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,32 ))
+         usbnet_resume_rx(dev);
+         #endif
+      }
+   }
+   NETDBG("old_rx_urb_size = %u,rx_urb_size = %zu\n",old_rx_urb_size, dev->rx_urb_size);
+   return 0;
+}
+
+#ifdef FIX_RX_BUFFER
+int GobiUSBNetChangeMTU(struct net_device *net, int new_mtu)
+{
+   struct usbnet   *dev = netdev_priv(net);
+   int             ll_mtu = new_mtu + net->hard_header_len;
+
+   // no second zero-length packet read wanted after mtu-sized packets
+   if ((ll_mtu % dev->maxpacket) == 0)
+      return -EDOM;
+   net->mtu = new_mtu;
+   DBG("old_hard_mtu = %d old_rx_urb_size = %zd\n", dev->hard_mtu, dev->rx_urb_size);
+   dev->hard_mtu = net->mtu + net->hard_header_len;
+     DBG("hard_mtu = %d new mtu = %d, hard_header_len = %d\n", dev->hard_mtu, net->mtu, net->hard_header_len);
+   #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,12,0 ))
+   /* max qlen depend on hard_mtu and rx_urb_size */
+   usbnet_update_max_qlen(dev);
+   #endif
+   return 0;
+}
+#endif
+
+/*===========================================================================
+METHOD:
+   GobiUSBNetOpen (Public Method)
+
+DESCRIPTION:
+   Wrapper to usbnet_open, correctly handling autosuspend
+   Start AutoPM thread (if CONFIG_PM is defined)
+
+PARAMETERS
+   pNet     [ I ] - Pointer to net device
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int GobiUSBNetOpen( struct net_device * pNet )
+{
+   int status = 0;
+   struct sGobiUSBNet * pGobiDev = NULL;
+   struct usbnet * pDev = NULL;
+   if(pNet==NULL)
+   {
+      DBG( "GobiUSBNetOpen failed to get Net device\n" );
+      return -ENXIO;
+   }
+   pDev = netdev_priv( pNet );
+
+   if (pDev == NULL)
+   {
+      DBG( "failed to get usbnet device\n" );
+      return -ENXIO;
+   }
+
+   pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if (pGobiDev == NULL)
+   {
+      DBG( "failed to get QMIDevice\n" );
+      return -ENXIO;
+   }
+
+   DBG( "\n" );
+
+#ifdef CONFIG_PM
+   #if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,29 ))
+   // Start the AutoPM thread
+   pGobiDev->mAutoPM.mpIntf = pGobiDev->mpIntf;
+   pGobiDev->mAutoPM.mbExit = false;
+   pGobiDev->mAutoPM.mpURBList = NULL;
+   pGobiDev->mAutoPM.mpActiveURB = NULL;
+   spin_lock_init( &pGobiDev->mAutoPM.mURBListLock );
+   spin_lock_init( &pGobiDev->mAutoPM.mActiveURBLock );
+   atomic_set( &pGobiDev->mAutoPM.mURBListLen, 0 );
+   init_completion( &pGobiDev->mAutoPM.mThreadDoWork );
+
+   pGobiDev->mAutoPM.mpThread = kthread_run( GobiUSBNetAutoPMThread,
+                                               &pGobiDev->mAutoPM,
+                                               "GobiUSBNetAutoPMThread" );
+   if (IS_ERR( pGobiDev->mAutoPM.mpThread ))
+   {
+      DBG( "AutoPM thread creation error\n" );
+      return PTR_ERR( pGobiDev->mAutoPM.mpThread );
+   }
+   #endif
+#endif /* CONFIG_PM */
+
+   if(pGobiDev->iNetLinkStatus==eNetDeviceLink_Connected)
+   {
+      // Allow traffic
+      GobiClearDownReason( pGobiDev, NET_IFACE_STOPPED );
+   }
+   else
+   {
+      #ifdef CONFIG_ANDROID // To prevnet packet traffic before data connection start.
+      GobiClearDownReason( pGobiDev, NET_IFACE_STOPPED );
+      #endif
+      GobiSetDownReason( pGobiDev, NO_NDIS_CONNECTION );
+   }
+
+   if(pGobiDev->iQMUXEnable)
+   {  //Force Enable traffic
+      GobiClearDownReason( pGobiDev, NET_IFACE_STOPPED );
+      GobiClearDownReason( pGobiDev, NO_NDIS_CONNECTION );   
+   }
+   // Pass to usbnet_open if defined
+   if (pGobiDev->mpUSBNetOpen != NULL)
+   {
+      status = pGobiDev->mpUSBNetOpen( pNet );
+#ifdef CONFIG_PM
+      // If usbnet_open was successful enable Auto PM
+      if (status == 0)
+      {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,33 ))
+         gobi_usb_autopm_enable( pGobiDev->mpIntf );
+#else
+         gobi_usb_autopm_put_interface( pGobiDev->mpIntf );
+#endif
+      }
+#endif /* CONFIG_PM */
+   }
+   else
+   {
+      DBG( "no USBNetOpen defined\n" );
+   }
+
+   return status;
+}
+
+/*===========================================================================
+METHOD:
+   GobiUSBNetStop (Public Method)
+
+DESCRIPTION:
+   Wrapper to usbnet_stop, correctly handling autosuspend
+   Stop AutoPM thread (if CONFIG_PM is defined)
+
+PARAMETERS
+   pNet     [ I ] - Pointer to net device
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int GobiUSBNetStop( struct net_device * pNet )
+{
+   struct sGobiUSBNet * pGobiDev;
+   struct usbnet * pDev = NULL;
+
+   if (pNet == NULL)
+   {
+      DBG( "GobiUSBNetStop failed to get Net\n" );
+      return -ENXIO;
+   }
+   pDev = netdev_priv( pNet );
+
+   if (pDev == NULL || pDev->net == NULL)
+   {
+      DBG( "failed to get netdevice\n" );
+      return -ENXIO;
+   }
+
+   pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if (pGobiDev == NULL)
+   {
+      DBG( "failed to get QMIDevice\n" );
+      return -ENXIO;
+   }
+
+   // Stop traffic
+   GobiSetDownReason( pGobiDev, NET_IFACE_STOPPED );
+
+#ifdef CONFIG_PM
+   #if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,29 ))
+   // Tell traffic thread to exit
+   pGobiDev->mAutoPM.mbExit = true;
+   complete( &pGobiDev->mAutoPM.mThreadDoWork );
+
+   // Wait for it to exit
+   while( pGobiDev->mAutoPM.mpThread != NULL )
+   {
+      set_current_state(TASK_INTERRUPTIBLE);
+      wait_ms(100);
+      if( (signal_pending(current))
+      {
+         break;
+      }
+   }
+   set_current_state(TASK_RUNNING);
+   DBG( "thread stopped\n" );
+   #endif
+#endif /* CONFIG_PM */
+
+   if(pGobiDev->iPacketInComplete==1)
+   {
+      pGobiDev->iPacketInComplete=0;
+   }
+   // Pass to usbnet_stop, if defined
+   if (pGobiDev->mpUSBNetStop != NULL)
+   {
+      return pGobiDev->mpUSBNetStop( pNet );
+   }
+   else
+   {
+      return 0;
+   }
+}
+
+/* reset the Ethernet header with correct destionation address and ip protocol */
+void ResetEthHeader(struct usbnet *dev, struct sk_buff *skb, int isIpv4, int isQMUXPacket)
+{
+     __be16 ip_type;
+
+     skb_reset_mac_header(skb);
+     skb_reset_network_header(skb);
+     skb_reset_transport_header(skb);
+          
+     if(isQMUXPacket)
+     {
+        memcpy(eth_hdr(skb)->h_dest, skb->dev->dev_addr, ETH_ALEN);
+        memcpy(eth_hdr(skb)->h_source, skb->dev->dev_addr, ETH_ALEN);
+     }
+     else
+     {
+        if(iEthSrcMACNonZero==0)
+        {
+           memset(eth_hdr(skb)->h_source, 0, ETH_ALEN);
+        }
+        else
+        {
+           //To workaround packet drop in bridge mode.
+           const unsigned char MacOctetXor = 0xC3;
+           memcpy(eth_hdr(skb)->h_source, dev->net->dev_addr, ETH_ALEN);
+           eth_hdr(skb)->h_source[ETH_ALEN - 1] ^= MacOctetXor;
+        }
+        memcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);
+     }
+     ip_type = isIpv4 == 1 ? ETH_P_IP : ETH_P_IPV6;
+     eth_hdr(skb)->h_proto = cpu_to_be16(ip_type);
+     
+     PrintHex (skb->data, skb->len);
+}
+
+/* check the packet if the Etherenet header is corrupted or not, if yes,
+ * correct the Ethernet header with replacing destination address and ip protocol.
+ * if no, do nothing
+ */
+int FixEthFrame(struct usbnet *dev, struct sk_buff *skb, int isIpv4)
+{
+    __be16 proto;
+    u16 total_len, payload_len;
+
+    /* All MAC-48 multicast identifiers prefixed "33-33", do not overwrite the MAC address if it is not corrupted */    
+    if ((skb->data[0] == MAC48_MULTICAST_ID) && (skb->data[1] == MAC48_MULTICAST_ID))
+    {
+        proto = ((skb->data[ETH_HLEN-2] << 8) & 0xff) |(skb->data[ETH_HLEN-1]);
+        /* check the IP type field, if it is correct, we can consider this is not a corrupted packet */
+        if (proto == skb->protocol)
+        {
+            DBG( "multicast MAC address: destination matched, pass through ");
+            /* correct packet, pass through */
+            return 1;
+        }
+        else
+        {
+            DBG( "multicast MAC address: destination mismatched, IPV%s header modified:", isIpv4 == 1 ? "4":"6");
+            ResetEthHeader(dev, skb, isIpv4,0);
+            return 1;
+        }
+    }
+    else if (memcmp(&skb->data[0], &dev->net->dev_addr[0], ETH_ALEN) == 0)
+    {
+        /* MAC address is correct, no need to overwrite, pass through */
+        DBG( "correct packet, pass through ");
+        return 1;
+    }
+    else
+    {
+        if (isIpv4)
+        {
+            /* ipv4 */
+            total_len = ((skb->data[ETH_HLEN+IPV4HDR_TOT_UPPER] << 8) & 0xff) | (skb->data[ETH_HLEN+IPV4HDR_TOT_LOWER]);
+            DBG( "ipv4 header: total length = %d\n", total_len);
+            /* total length includes IP header and payload, hence it plus Ethernet header length should be equal to
+               the skb buffer length if the Etherent header is presented in the skb buffer*/
+            if (skb->len >= (total_len+ETH_HLEN))
+            {
+                DBG( "IPv4 header modified: ");
+                ResetEthHeader(dev, skb, isIpv4,0);
+                return 1;
+            }
+        }
+        else
+        {
+            /* ipv6 */
+            payload_len = ((skb->data[ETH_HLEN+IPV6HDR_PAYLOAD_UPPER] << 8) & 0xff) | (skb->data[ETH_HLEN+IPV6HDR_PAYLOAD_LOWER]);
+            DBG( "ipv6 header: payload length = %d\n", payload_len);
+            /* for IPV6, the playload length does not include ipv6 header */
+            if (skb->len >= (payload_len+ETH_HLEN+IPV6HDR_LENGTH))
+            {
+                DBG( "IPv6 header modified: ");
+                ResetEthHeader(dev, skb, isIpv4,0);
+                return 1;
+            }
+        }
+    }
+    return 0;
+}
+
+/* Make up an ethernet header if the packet doesn't have one.
+ *
+ * A firmware bug common among several devices cause them to send raw
+ * IP packets under some circumstances.  There is no way for the
+ * driver/host to know when this will happen.  And even when the bug
+ * hits, some packets will still arrive with an intact header.
+ *
+ * The supported devices are only capably of sending IPv4, IPv6 and
+ * ARP packets on a point-to-point link. Any packet with an ethernet
+ * header will have either our address or a broadcast/multicast
+ * address as destination.  ARP packets will always have a header.
+ *
+ * This means that this function will reliably add the appropriate
+ * header iff necessary, provided our hardware address does not start
+ * with 4 or 6.
+ *
+ * Another common firmware bug results in all packets being addressed
+ * to 00:a0:c6:00:00:00 despite the host address being different.
+ * This function will also fixup such packets.
+ */
+static int GobiNetDriverLteRxFixup(struct usbnet *dev, struct sk_buff *skb)
+{
+   __be16 proto;
+   struct sGobiUSBNet * pGobiDev;
+   pGobiDev = (sGobiUSBNet *)dev->data[0];
+   if (pGobiDev == NULL)
+   {
+      DBG( "failed to get QMIDevice\n" );
+      return 0;
+   }
+   #ifdef CONFIG_PM
+   if(bIsSuspend(pGobiDev))
+   {
+      DBG("Suspended\n");
+      UsbAutopmGetInterface( pGobiDev->mpIntf );
+      UsbAutopmPutInterface( pGobiDev->mpIntf );
+   }
+   #endif
+   if(pGobiDev->iQMUXEnable!=0)
+   {
+      GobiNetDriverRxFixup(dev,skb);
+      //Consume this packet in driver(netif_rx), no need to forward back
+      //via usbnet_skb_return after fixup
+      return 0;
+   }
+   else if(pGobiDev->iNetLinkStatus!=eNetDeviceLink_Connected)
+   {
+      DBG( "Dropped Packet : Not Connected\n" );
+      return 0;
+   }
+   if(pGobiDev->iDataMode==eDataMode_RAWIP)
+   {
+      return GobiNetDriverRxFixup(dev,skb);
+   }
+   if (skb->len < dev->net->hard_header_len)
+   {
+      printk( "Packet Dropped \n" );
+      return 0;
+   }
+   DBG( "From Modem: ");
+   PrintHex (skb->data, skb->len);
+
+    /* special handling for corrupted Ethernet header packet if any */
+   if ((skb->data[ETH_HLEN] & 0xF0) == 0x40)
+   {
+       /* check if need to correct the IPV4 Ethernet header or not */
+       if (FixEthFrame(dev, skb, 1))
+       {
+          /* pass through */
+          return 1;
+       }
+   }
+   else if ((skb->data[ETH_HLEN] & 0xF0) == 0x60)
+   {
+       /* check if need to correct the IPV6 Ethernet header or not */
+       if (FixEthFrame(dev, skb, 0))
+       {
+          /* pass through */
+          return 1;
+       }
+   }
+
+    /* usbnet rx_complete guarantees that skb->len is at least
+     * hard_header_len, so we can inspect the dest address without
+     * checking skb->len
+     */
+    switch (skb->data[0] & 0xf0) {
+        case 0x40:
+            proto = htons(ETH_P_IP);
+            break;
+        case 0x60:
+            proto = htons(ETH_P_IPV6);
+            break;
+        case 0x00:
+            if (is_multicast_ether_addr(skb->data))
+                return 1;
+            /* possibly bogus destination - rewrite just in case */
+            skb_reset_mac_header(skb);
+            skb_reset_network_header(skb);
+            skb_reset_transport_header(skb);
+            goto fix_dest;
+        default:
+        {
+            /* pass along other packets without modifications */
+            return 1;
+        }
+    }
+    if (skb_headroom(skb) < ETH_HLEN)
+        return 0;
+    skb_push(skb, ETH_HLEN);
+    skb_reset_mac_header(skb);
+    skb_reset_network_header(skb);
+    skb_reset_transport_header(skb);
+    eth_hdr(skb)->h_proto = proto;
+    memset(eth_hdr(skb)->h_source, 0, ETH_ALEN);
+fix_dest:
+    memcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);
+    DBG( "To IP Stack: ");
+    PrintHex (skb->data, skb->len);
+    return 1;
+}
+
+/*=========================================================================*/
+// Struct driver_info
+/*=========================================================================*/
+static const struct driver_info GobiNetInfo_qmi = {
+   .description   = "QmiNet Ethernet Device",
+   .flags         = FLAG_ETHER,
+   .bind          = GobiNetDriverBind,
+   .unbind        = GobiNetDriverUnbind,
+//FIXME refactor below fixup handling at cases below
+   .rx_fixup      = GobiNetDriverLteRxFixup,
+   .tx_fixup      = GobiNetDriverTxFixup,
+   .data          = BIT(8) | BIT(19) |
+                     BIT(10), /* MDM9x15 PDNs */
+#ifdef CONFIG_PM
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,8,0 ))
+    .manage_power = usbnet_manage_power,
+#endif
+#endif
+};
+
+static const struct driver_info GobiNetInfo_gobi = {
+   .description   = "GobiNet Ethernet Device",
+   .flags         = FLAG_ETHER,
+   .bind          = GobiNetDriverBind,
+   .unbind        = GobiNetDriverUnbind,
+   .rx_fixup      = GobiNetDriverLteRxFixup,
+   .tx_fixup      = GobiNetDriverTxFixup,
+   .data          = BIT(0) | BIT(5),
+#ifdef CONFIG_PM
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,8,0 ))
+    .manage_power = usbnet_manage_power,
+#endif
+#endif
+};
+
+static const struct driver_info GobiNetInfo_9x15 = {
+   .description   = "GobiNet Ethernet Device",
+   .flags         = FLAG_ETHER,
+   .bind          = GobiNetDriverBind,
+   .unbind        = GobiNetDriverUnbind,
+   .rx_fixup      = GobiNetDriverLteRxFixup,
+   .tx_fixup      = GobiNetDriverTxFixup,
+   .data          = BIT(8) | BIT(10) | BIT(BIT_9X15),
+#ifdef CONFIG_PM
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,8,0 ))
+   .manage_power = usbnet_manage_power,
+#endif
+#endif
+};
+
+
+#define QMI_G3K_DEVICE(vend, prod) \
+   USB_DEVICE(vend, prod), \
+   .driver_info = (unsigned long)&GobiNetInfo_gobi
+
+#define QMI_9X15_DEVICE(vend, prod) \
+   USB_DEVICE(vend, prod), \
+   .driver_info = (unsigned long)&GobiNetInfo_9x15
+
+/*=========================================================================*/
+// Qualcomm Gobi 3000 VID/PIDs
+/*=========================================================================*/
+static const struct usb_device_id GobiVIDPIDTable [] =
+{
+   // Sierra Wireless MC7750 QMI Device VID/PID
+   {
+      USB_DEVICE( 0x1199, 0x68a2 ),
+      .driver_info = (unsigned long)&GobiNetInfo_qmi,
+   },
+
+   // Gobi 3000
+   {QMI_G3K_DEVICE(0x05c6, 0x920d)},
+   {QMI_G3K_DEVICE(0x1199, 0x9011)},
+   {QMI_G3K_DEVICE(0x1199, 0x9013)},
+   {QMI_G3K_DEVICE(0x1199, 0x9015)},
+   {QMI_G3K_DEVICE(0x1199, 0x9019)},
+   {QMI_G3K_DEVICE(0x03f0, 0x371d)},
+   // 9x15
+   {QMI_9X15_DEVICE(0x1199, 0x9071)}, /* consider 9x30 and 9x50 same as 9x15 at the moment, change it later if needed */
+   {QMI_9X15_DEVICE(0x1199, 0x68C0)},
+   {QMI_9X15_DEVICE(0x1199, 0x9041)},
+   {QMI_9X15_DEVICE(0x1199, 0x9051)},
+   {QMI_9X15_DEVICE(0x1199, 0x9053)},
+   {QMI_9X15_DEVICE(0x1199, 0x9054)},
+   {QMI_9X15_DEVICE(0x1199, 0x9055)},
+   {QMI_9X15_DEVICE(0x1199, 0x9056)},
+   {QMI_9X15_DEVICE(0x1199, 0x9061)},
+   {QMI_G3K_DEVICE(0x03f0, 0x4e1d)},
+
+   //9x30
+   {QMI_9X15_DEVICE(0x1199, 0x9070)},
+
+   //9x50
+   {QMI_9X15_DEVICE(0x1199, 0x9091)},
+   {QMI_9X15_DEVICE(0x1199, 0x90b1)},
+   {QMI_9X15_DEVICE(0x1199, 0x90c1)},
+
+   //AR759x
+   {QMI_9X15_DEVICE(0x1199, 0x9100)},
+   
+   //AR758x
+   {QMI_9X15_DEVICE(0x1199, 0x9102)},
+   
+   //AR758x
+   {QMI_9X15_DEVICE(0x1199, 0x9110)},
+   //Terminating entry
+   { }
+};
+
+MODULE_DEVICE_TABLE( usb, GobiVIDPIDTable );
+/*===========================================================================
+METHOD:
+   PrintCurrentUSBSpeed (Public Method)
+
+DESCRIPTION:
+   Print Current USB Speed
+
+PARAMETERS
+   pDev        [ I ] - Pointer to usbnet
+
+RETURN VALUE:
+    NULL
+===========================================================================*/
+
+void PrintCurrentUSBSpeed(struct usbnet * pDev)
+{
+   enum usb_device_speed {
+        USB_SPEED_UNKNOWN = 0,                  /* enumerating */
+        USB_SPEED_LOW, USB_SPEED_FULL,          /* usb 1.1 */
+        USB_SPEED_HIGH,                         /* usb 2.0 */
+        USB_SPEED_WIRELESS,                     /* wireless (usb 2.5) */
+        USB_SPEED_SUPER,                        /* usb 3.0 */
+   };
+   switch(pDev->udev->speed)
+    {
+        case USB_SPEED_LOW:
+            printk("USB Speed : USB 1.0 SPEED LOW\n");
+            break;
+        case USB_SPEED_FULL:
+            printk("USB Speed : USB 1.0 SPEED FULL\n");
+            break;
+        case USB_SPEED_HIGH:
+            printk("USB Speed : USB 2.0\n");
+            break;
+        case USB_SPEED_WIRELESS:
+            printk("USB Speed : USB 2.5\n");
+            break;
+        case USB_SPEED_SUPER:
+            printk("USB Speed : USB 3.0\n");
+            break;
+        case USB_SPEED_UNKNOWN:
+        default:
+            printk("USB Speed : USB SPEED UNKNOWN\n");
+            break;
+    }
+}
+
+/*===========================================================================
+METHOD:
+   gobi_work_handler (Private Method)
+
+DESCRIPTION:
+   Start work function
+
+PARAMETERS
+   w        [ I ] - Pointer to work_struct
+
+RETURN VALUE:
+    NULL
+===========================================================================*/
+static void gobi_work_handler(struct work_struct *w)
+{
+   struct delayed_work *dwork;
+   sGobiUSBNet *pGobiDev = NULL;
+   dwork = to_delayed_work(w);
+   pGobiDev = container_of(dwork, sGobiUSBNet, dwprobe);
+   if(pGobiDev!=NULL)
+   {
+      struct usb_device *dev = NULL;
+      char szQMIBusName[64]={0};
+      dev = interface_to_usbdev(pGobiDev->mUsb_Interface);
+      if(dev!=NULL)
+      snprintf(szQMIBusName,63,"qcqmi%d-%d-%s:%d.%d",   
+         (int)pGobiDev->mQMIDev.qcqmi,   
+         dev->bus->busnum, dev->devpath,    
+         dev->actconfig->desc.bConfigurationValue,   
+         pGobiDev->mUsb_Interface->cur_altsetting->desc.bInterfaceNumber);
+      DBG("gobi_work_handler szQMIBusName:%s\n",szQMIBusName);
+      work_function((void *)pGobiDev);
+   }
+   else
+   {
+      DBG("pGobiDev NULL\n");
+   }
+
+}
+
+/*===========================================================================
+METHOD:
+   GobiUSBNetProbe (Public Method)
+
+DESCRIPTION:
+   Run usbnet_probe
+   Setup QMI device
+
+PARAMETERS
+   pIntf        [ I ] - Pointer to interface
+   pVIDPIDs     [ I ] - Pointer to VID/PID table
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int GobiUSBNetProbe(
+   struct usb_interface *        pIntf,
+   const struct usb_device_id *  pVIDPIDs )
+{
+   int is9x15 = 0;
+   unsigned char    ifacenum;
+   int status;
+   struct usbnet * pDev;
+   sGobiUSBNet * pGobiDev;
+   struct ethhdr *eth;
+   int iNumberOfMUXIDSupported=0;
+
+#if 0
+   /* There exists a race condition in the firmware that sometimes results
+    * in the absence of Ethernet framing of packets received from the device.
+    * Therefore, a firmware work-around currently hard-codes the MAC address
+    * to ensure valid Ethernet frames are sent to the host. We therefore
+    * hard-code the network device MAC address to comply with the firmware
+    */
+   const char default_addr[6] = {0x00, 0xa0, 0xc6, 0x00, 0x00, 0x00};
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,29 ))
+   struct net_device_ops * pNetDevOps;
+#endif
+
+   ifacenum =  pIntf->cur_altsetting->desc.bInterfaceNumber;
+   if(ifacenum==8)
+   {
+      if(pIntf->cur_altsetting->string !=NULL)
+      {
+         char *numberptr = strstr(pIntf->cur_altsetting->string,RMNET_QMAP_STRING);
+         DBG("String %s\n", pIntf->cur_altsetting->string );
+         if((numberptr!=NULL)&&
+            (strlen(pIntf->cur_altsetting->string)> strlen(RMNET_QMAP_STRING)) )
+         {
+            long result =0;
+            numberptr = pIntf->cur_altsetting->string + strlen(RMNET_QMAP_STRING);
+            if(kstrtol (numberptr, 10,&result)==0)
+            {
+               iNumberOfMUXIDSupported = (int)result;
+            }
+            if(iNumberOfMUXIDSupported>MAX_MUX_NUMBER_SUPPORTED)
+            {
+               printk( KERN_INFO "Only supported MUXID(MAX:%d):%d",MAX_MUX_NUMBER_SUPPORTED,iNumberOfMUXIDSupported);
+               iNumberOfMUXIDSupported = iMaxQMUXSupported;
+            }
+            if ( iNumberOfMUXIDSupported <= 1 )
+            {
+                printk( KERN_INFO "QMAP Disabled");
+            }
+            else
+            {
+               // "at!netnum?" > 1
+               DBG("QMAP Enabled, number of RMNET supported : %d\n", iNumberOfMUXIDSupported );
+            }
+         }
+      }
+      else
+      {
+         DBG("String NULL\n");
+         iNumberOfMUXIDSupported = iMaxQMUXSupported;
+      }
+      if(iMaxQMUXSupported!=-1)
+      {
+         if(MAX_MUX_NUMBER_SUPPORTED<iMaxQMUXSupported)
+         {
+             iNumberOfMUXIDSupported = MAX_MUX_NUMBER_SUPPORTED;
+         }
+         else
+         {
+            iNumberOfMUXIDSupported = iMaxQMUXSupported;
+         }
+         printk( KERN_INFO "Override Number Of RMNET supported to :%d\n",iNumberOfMUXIDSupported);
+      }
+   }
+   status = usbnet_probe( pIntf, pVIDPIDs );
+   if (status < 0)
+   {
+      DBG( "usbnet_probe failed %d\n", status );
+      return status;
+   }
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,19 ))
+   pIntf->needs_remote_wakeup = 1;
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,23 ))
+   pDev = usb_get_intfdata( pIntf );
+#else
+   pDev = (struct usbnet *)pIntf->dev.platform_data;
+#endif
+
+   if (pDev == NULL || pDev->net == NULL)
+   {
+      DBG( "failed to get netdevice\n" );
+      usbnet_disconnect( pIntf );
+      usb_set_intfdata(pIntf, NULL);
+      return -ENXIO;
+   }
+   gobi_usbnet_stop(pDev->net);
+   
+   pGobiDev = kzalloc( sizeof( sGobiUSBNet ), GOBI_GFP_KERNEL );
+   if (pGobiDev == NULL)
+   {
+      DBG( "falied to allocate device buffers" );
+      usbnet_disconnect( pIntf );
+      usb_set_intfdata(pIntf, NULL);
+      return -ENOMEM;
+   }
+   atomic_set( &pGobiDev->mAutoPM.mURBListLen, 0 );
+   pGobiDev->tx_qlen  = 0;
+   pGobiDev->WDSClientID = (u16)-1;
+   pGobiDev->iDataMode = eDataMode_Ethernet;
+   pDev->data[0] = (unsigned long)pGobiDev;
+   pGobiDev->iUSBState = USB_STATE_ATTACHED;
+   pGobiDev->mpNetDev = pDev;
+
+   // Clearing endpoint halt is a magic handshake that brings 
+   // the device out of low power (airplane) mode
+   // NOTE: FCC verification should be done before this, if required
+   usb_clear_halt( pGobiDev->mpNetDev->udev, pDev->out );
+
+   // Overload PM related network functions
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,29 ))
+   pGobiDev->mpUSBNetOpen = pDev->net->open;
+   pDev->net->open = GobiUSBNetOpen;
+   pGobiDev->mpUSBNetStop = pDev->net->stop;
+   pDev->net->stop = GobiUSBNetStop;
+   pDev->net->hard_start_xmit = GobiUSBNetStartXmit;
+   pDev->net->tx_timeout = GobiUSBNetTXTimeout;
+#else
+   pNetDevOps = kmalloc( sizeof( struct net_device_ops ), GOBI_GFP_KERNEL );
+   if (pNetDevOps == NULL)
+   {
+      DBG( "falied to allocate net device ops" );
+      usbnet_disconnect( pIntf );
+      usb_set_intfdata(pIntf, NULL);
+      return -ENOMEM;
+   }
+   memcpy( pNetDevOps, pDev->net->netdev_ops, sizeof( struct net_device_ops ) );
+   pDev->net->hard_header_len = 0;
+
+   pGobiDev->mpUSBNetOpen = pNetDevOps->ndo_open;
+   pNetDevOps->ndo_open = GobiUSBNetOpen;
+#ifdef FIX_RX_BUFFER
+   pNetDevOps->ndo_change_mtu = GobiUSBNetChangeMTU;
+#endif
+   pGobiDev->mpUSBNetStop = pNetDevOps->ndo_stop;
+   pNetDevOps->ndo_stop = GobiUSBNetStop;
+#ifdef TX_XMIT_SIERRA
+#if (LINUX_VERSION_CODE == KERNEL_VERSION( 2,6,31 ) ||\
+       LINUX_VERSION_CODE == KERNEL_VERSION( 2,6,32 ))
+   pNetDevOps->ndo_start_xmit = gobi_usbnet_start_xmit_2_6_32;
+   pNetDevOps->ndo_tx_timeout = gobi_usbnet_tx_timeout_2_6_32;
+#elif (LINUX_VERSION_CODE == KERNEL_VERSION( 2,6,35 ))
+   pNetDevOps->ndo_start_xmit = gobi_usbnet_start_xmit_2_6_35;
+   pNetDevOps->ndo_tx_timeout = gobi_usbnet_tx_timeout_2_6_35;
+#elif (LINUX_VERSION_CODE == KERNEL_VERSION( 3,0,6 ))
+   pNetDevOps->ndo_start_xmit = gobi_usbnet_start_xmit_3_0_6;
+   pNetDevOps->ndo_tx_timeout = gobi_usbnet_tx_timeout_3_0_6;
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,10,1 ) &&\
+       LINUX_VERSION_CODE <= KERNEL_VERSION( 3,10,39 ))
+   pNetDevOps->ndo_start_xmit = gobi_usbnet_start_xmit_3_10_21;
+   pNetDevOps->ndo_tx_timeout = gobi_usbnet_tx_timeout_3_10_21;
+
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,12,0 ) &&\
+          LINUX_VERSION_CODE < KERNEL_VERSION( 3,13,0 ))
+   pNetDevOps->ndo_start_xmit = gobi_usbnet_start_xmit_3_12_xx;
+   pNetDevOps->ndo_tx_timeout = gobi_usbnet_tx_timeout_3_12_xx;
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION( 4,4,0 ) &&\
+          LINUX_VERSION_CODE < KERNEL_VERSION( 4,5,0 ))
+   pNetDevOps->ndo_start_xmit = gobi_usbnet_start_xmit_4_4_xx;
+   pNetDevOps->ndo_tx_timeout = gobi_usbnet_tx_timeout_4_4_xx;
+#endif /* #if (LINUX_VERSION_CODE == KERNEL_VERSION( 2,6,31 ) */
+#else
+   pNetDevOps->ndo_start_xmit = usbnet_start_xmit;
+   pNetDevOps->ndo_tx_timeout = usbnet_tx_timeout;
+#endif /* TX_XMIT_SIERRA */
+
+   pDev->net->netdev_ops = pNetDevOps;
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,31 ))
+   memset( &(pGobiDev->mpNetDev->stats), 0, sizeof( struct net_device_stats ) );
+#else
+   memset( &(pGobiDev->mpNetDev->net->stats), 0, sizeof( struct net_device_stats ) );
+#endif
+
+   pGobiDev->mpIntf = pIntf;
+   memset( &(pGobiDev->mMEID), '0', MAX_DEVICE_MEID_SIZE );
+
+   /* change MAC addr to include, ifacenum, and to be unique */
+   pGobiDev->mpNetDev->net->dev_addr[ETH_ALEN-1] = ifacenum;
+
+   DBG( "Mac Address:\n" );
+   PrintHex( &pGobiDev->mpNetDev->net->dev_addr[0], 6 );
+#if 0 /* interfers with multiple interface support and no longer appears to be necessary */
+   /* Hard-code the host MAC address to comply with the firmware workaround */
+   memcpy(&pGobiDev->mpNetDev->net->dev_addr[0], &default_addr[0], 6);
+   DBG( "Default Mac Address:\n" );
+   PrintHex( &pGobiDev->mpNetDev->net->dev_addr[0], 6 );
+#endif
+   /* Create ethernet header for IPv4 packets */
+   eth = (struct ethhdr *)pGobiDev->eth_hdr_tmpl_ipv4;
+   memcpy(&eth->h_dest, &pGobiDev->mpNetDev->net->dev_addr[0], ETH_ALEN);
+   memcpy(&eth->h_source, &pGobiDev->mpNetDev->net->dev_addr[0], ETH_ALEN);
+   eth->h_proto = cpu_to_be16(ETH_P_IP);
+
+   /* Create ethernet header for IPv6 packets */
+   eth = (struct ethhdr *)pGobiDev->eth_hdr_tmpl_ipv6;
+   memcpy(&eth->h_dest, &pGobiDev->mpNetDev->net->dev_addr[0], ETH_ALEN);
+   memcpy(&eth->h_source, &pGobiDev->mpNetDev->net->dev_addr[0], ETH_ALEN);
+   eth->h_proto = cpu_to_be16(ETH_P_IPV6);
+
+   pGobiDev->mbQMIValid = false;
+   memset( &pGobiDev->mQMIDev, 0, sizeof( sQMIDev ) );
+   pGobiDev->mQMIDev.mbCdevIsInitialized = false;
+   pGobiDev->mQMIDev.iInterfaceNumber = pIntf->cur_altsetting->desc.bInterfaceNumber;
+   pGobiDev->mQMIDev.mpDevClass = gpClass;
+
+#ifdef CONFIG_PM
+   init_completion( &pGobiDev->mAutoPM.mThreadDoWork );
+   spin_lock_init(&pGobiDev->sSuspendLock);
+   SetCurrentSuspendStat(pGobiDev, false);
+#endif /* CONFIG_PM */
+   spin_lock_init( &pGobiDev->mQMIDev.mClientMemLock );
+
+   // Default to device down
+   pGobiDev->mDownReason = 0;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 3,11,0 ))
+   GobiSetDownReason( pGobiDev, NO_NDIS_CONNECTION );
+   GobiSetDownReason( pGobiDev, NET_IFACE_STOPPED );
+#else
+   GobiSetDownReason( pGobiDev, NO_NDIS_CONNECTION );
+#endif
+   pGobiDev->iQMUXEnable = 0;
+   pGobiDev->iStoppingNetDev = 0;
+   pGobiDev->nRmnet = 0;
+   if(ifacenum==8)// only allow interface 8 to allow qmux
+   {
+      if ( (iQMAPEnable != 0) && ( iNumberOfMUXIDSupported > 1 ) )
+      {
+         int index=0;
+         pGobiDev->iQMUXEnable = 1;
+         if (gobi_rtnl_trylock())
+         {
+            if (!netif_running(pDev->net)) 
+            {
+               printk( KERN_INFO "QMAP Enabled\n");
+               for(index=0;index<MAX_QCQMI;index++)
+               {
+                   if (qmux_table[index] == 0)
+                   {
+                       qmux_table[index]=1;
+                       break;
+                   }
+               }
+               pGobiDev->iDeviceMuxID = index;
+               
+               if(iNumberOfMUXIDSupported>MAX_MUX_NUMBER_SUPPORTED)
+               {
+                  pGobiDev->iMaxMuxID = MAX_MUX_NUMBER_SUPPORTED;
+               }
+               else
+               {
+                  pGobiDev->iMaxMuxID = iNumberOfMUXIDSupported;
+               }
+               pGobiDev->nRmnet = pGobiDev->iMaxMuxID;
+               pGobiDev->iIPAlias = iIPAlias;
+               if(pGobiDev->iIPAlias==0)
+               {
+                  int iMuxID=0;
+                  for(iMuxID=MUX_ID_START;iMuxID<(pGobiDev->iMaxMuxID+MUX_ID_START);iMuxID++)
+                  {
+                     pGobiDev->pNetDevice[iMuxID-MUX_ID_START] = gobi_qmimux_register_device(pDev->net,index,iMuxID);
+                  }
+               }
+            }
+            else
+            {
+               printk("running\n");
+            }
+            rtnl_unlock();
+         }
+         GobiClearDownReason( pGobiDev, NO_NDIS_CONNECTION );
+      }
+   }
+   
+   // Register QMI
+   if (pDev->driver_info->data &&
+          test_bit(BIT_9X15, &pDev->driver_info->data)) {
+       is9x15 = 1;
+   }
+   sema_init( &(pGobiDev->taskIDSem), SEMI_INIT_DEFAULT_VALUE );
+
+   spin_lock_init(&(pGobiDev->urb_lock));
+   spin_lock_init(&(pGobiDev->notif_lock));
+   pGobiDev->task=NULL;
+   pGobiDev->mIs9x15= is9x15;
+   pGobiDev->mUsb_Interface = pIntf;
+   pGobiDev->iTaskID = 0;
+   if(pGobiDev->iTaskID>=0)
+   {      
+      GobiInitWorkQueue(pGobiDev);
+      if(pGobiDev->wqprobe!=NULL)
+      {
+         unsigned long onesec =0;
+         onesec = msecs_to_jiffies(1000);
+         INIT_DELAYED_WORK(&pGobiDev->dwprobe,
+            gobi_work_handler);
+         queue_delayed_work(pGobiDev->wqprobe, &pGobiDev->dwprobe, onesec);
+      }
+      else
+      {
+         printk("GobiNet WorkQueue Fail\n");
+      }
+   }
+   else
+   {
+      DBG(KERN_INFO"GobiNet Thread : Error\n");
+   }
+
+   PrintCurrentUSBSpeed(pDev);
+   // Success
+   return 0;
+}
+
+
+void GobiUSBDisconnect(struct usb_interface *pIntf)
+{
+   sGobiUSBNet * pGobiDev;
+   struct usbnet * pDev;
+   DBG("GobiUSBDisconnect\n");
+   #if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,23 ))
+   pDev = usb_get_intfdata( pIntf );
+   #else
+   pDev = (struct usbnet *)pIntf->dev.platform_data;
+   #endif
+   if(pDev==NULL)
+   {
+      DBG( "failed to get interface\n" );
+      return ;
+   }
+   else
+   {
+       pGobiDev = (sGobiUSBNet *)pDev->data[0];
+       if (pGobiDev == NULL)
+       {
+          DBG( "failed to get QMIDevice\n" );
+          return;
+       }
+       pGobiDev->mbUnload = eStatUnloading;
+   }
+   gobi_usbnet_stop(pDev->net);//IPV6 lock error
+   gobi_dev_deactivate(pDev->net);
+   StopQMUXNet(pGobiDev);
+   DestroyQMAPRxBuffer(pGobiDev);
+   usbnet_disconnect(pIntf);
+   usb_set_intfdata(pIntf, NULL);
+}
+
+static struct usb_driver GobiNet =
+{
+   .name       = "GobiNet",
+   .id_table   = GobiVIDPIDTable,
+   .probe      = GobiUSBNetProbe,
+   .disconnect = GobiUSBDisconnect,
+#ifdef CONFIG_PM
+   .suspend    = GobiNetSuspend,
+   .resume     = GobiNetResume,
+   .supports_autosuspend = true,
+   .reset_resume = GobiNetResetResume,
+#else
+   .suspend    = NULL,
+   .resume     = NULL,
+   .supports_autosuspend = false,
+#endif /* CONFIG_PM */
+};
+
+/*===========================================================================
+METHOD:
+   GobiUSBNetModInit (Public Method)
+
+DESCRIPTION:
+   Initialize module
+   Create device class
+   Register out usb_driver struct
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+bool isModuleUnload(sGobiUSBNet *    pDev)
+{
+   if(iModuleExit)
+      return true;
+   if(pDev!=NULL)
+   {
+      if(pDev->mbUnload != eStatRegister)
+         return true;
+   } 
+   return false;
+}
+static int __init GobiUSBNetModInit( void )
+{
+   int i;
+   int j;
+   iModuleExit = 0;
+   gpClass = class_create( THIS_MODULE, "GobiQMI" );
+   if (IS_ERR( gpClass ) == true)
+   {
+      DBG( "error at class_create %ld\n",
+           PTR_ERR( gpClass ) );
+      return -ENOMEM;
+   }
+
+   // This will be shown whenever driver is loaded
+   printk( KERN_INFO "%s: %s\n", DRIVER_DESC, DRIVER_VERSION );
+#ifdef TX_URB_MONITOR
+   printk( KERN_INFO "with TX_URB_MONITOR defined\n");
+#endif
+
+   for(i=0;i<MAX_QCQMI;i++)
+   {
+      qcqmi_table[i] = 0;
+      qmux_table[i] = 0;
+      for(j=0;j<MAX_QCQMI_PER_INTF;j++)
+      {
+         memset(&GobiPrivateWorkQueues[i][j],0,sizeof(sGobiPrivateWorkQueues));
+      }
+   }
+   #if _PROBE_LOCK_
+   sema_init( &taskLoading, SEMI_INIT_DEFAULT_VALUE );
+   up(&taskLoading);
+   #endif
+   return usb_register( &GobiNet );
+}
+module_init( GobiUSBNetModInit );
+
+/*===========================================================================
+METHOD:
+   GobiUSBNetModExit (Public Method)
+
+DESCRIPTION:
+   Deregister module
+   Destroy device class
+
+RETURN VALUE:
+   void
+===========================================================================*/
+static void __exit GobiUSBNetModExit( void )
+{
+   int index = 0;
+   iModuleExit = 1;
+   usb_deregister( &GobiNet );
+   for(index=0;index<MAX_QCQMI;index++)
+   {
+      iClearWorkQueuesByTableIndex(index);
+   }
+   class_destroy( gpClass );
+}
+
+
+/*===========================================================================
+METHOD:
+   SendWakeupControlMsg (Private Method)
+
+DESCRIPTION:
+   Send Devie Weak Up Message
+
+PARAMETERS
+   pIntf          [ I ] - Pointer to interface
+   oldPowerState  [ I ] - Old Power State
+
+RETURN VALUE:
+   NULL
+===========================================================================*/
+void SendWakeupControlMsg(
+   struct usb_interface * pIntf,
+   int oldPowerState)
+{
+   struct usbnet * pDev;
+   sGobiUSBNet * pGobiDev;
+   int nRet= 0;
+   if (pIntf == 0)
+   {
+      return ;
+   }
+   DBG("\n");
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,23 ))
+   pDev = usb_get_intfdata( pIntf );
+#else
+   pDev = (struct usbnet *)pIntf->dev.platform_data;
+#endif
+
+   if (pDev == NULL || pDev->net == NULL)
+   {
+      DBG( "failed to get netdevice\n" );
+      return ;
+   }
+
+   pGobiDev = (sGobiUSBNet *)pDev->data[0];
+   if (pGobiDev == NULL)
+   {
+      DBG( "failed to get QMIDevice\n" );
+      return ;
+   }
+   #if defined(USB_INTRF_FUNC_SUSPEND) && defined(USB_INTRF_FUNC_SUSPEND_RW)
+   if ( pDev->udev->speed >= USB_SPEED_SUPER )
+   {
+      nRet = Gobi_usb_control_msg(pIntf,pDev->udev, usb_sndctrlpipe(pDev->udev, 0),
+                               USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
+                               USB_INTRF_FUNC_SUSPEND,
+                               pIntf->cur_altsetting->desc.bInterfaceNumber, /* two bytes in this field, suspend option(1 byte) | interface number(1 byte) */
+                               NULL, 0, USB_CTRL_SET_TIMEOUT);
+      if (nRet != 0)
+      {
+         DBG("[line:%d] send usb_control_msg failed!nRet = %d\n", __LINE__, nRet);
+      }
+   }
+#endif
+   if( iIsRemoteWakeupSupport(pDev) )
+   {
+      //USB/xhci: Enable remote wakeup for USB3 devices
+      nRet = Gobi_usb_control_msg(pIntf,pDev->udev, usb_sndctrlpipe(pDev->udev, 0),
+                                            USB_REQ_CLEAR_FEATURE,
+                                                    USB_RECIP_DEVICE,
+                                            USB_DEVICE_REMOTE_WAKEUP, 
+                                            0,//Don't care about which interface
+                                            NULL, 
+                                            0,
+                                            USB_CTRL_SET_TIMEOUT);
+      if (nRet != 0)
+      {
+          DBG("[line:%d] send usb_control_msg failed!nRet = %d\n", __LINE__, nRet);
+      }
+   }
+   // 9x30(EM74xx) needs this when resume
+   nRet = Gobi_usb_control_msg(pIntf, pDev->udev,
+           usb_sndctrlpipe( pDev->udev, 0 ),
+           SET_CONTROL_LINE_STATE_REQUEST,
+           SET_CONTROL_LINE_STATE_REQUEST_TYPE,
+           CONTROL_DTR,
+           pIntf->cur_altsetting->desc.bInterfaceNumber,
+           NULL, 0, USB_CTRL_SET_TIMEOUT);
+   if (nRet != 0)
+   {
+       DBG( "fail at sending DTR during resume %d\n", nRet );
+   }
+
+   
+}
+
+int _dev_forward_skb(struct net_device *dev, struct sk_buff *skb)
+{
+   skb_orphan(skb);
+   if (!(dev->flags & IFF_UP))
+   {
+      DBG("IFF_UP\n");
+      return NET_RX_DROP;
+   }
+   if (skb->len > (dev->mtu + dev->hard_header_len))
+   {
+      DBG("LENGTH\n");
+   }
+
+   skb_dst_drop(skb);
+   #if (LINUX_VERSION_CODE < KERNEL_VERSION( 4,10,0 ))
+   skb->tstamp.tv64 = 0;
+   #endif
+   skb->pkt_type =  PACKET_HOST;
+   skb->protocol = eth_type_trans(skb, dev);
+   skb->mark = 0;
+   secpath_reset(skb);
+   nf_reset(skb);
+   if (!list_empty(&skb->dev->napi_list))
+   {
+      DBG("napi_list\n");
+   }
+   #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,36 ))
+   skb_defer_rx_timestamp(skb);
+   #endif
+   return netif_rx(skb);
+}
+
+/*===========================================================================
+METHOD:
+   gobi_dev_forward_skb (Private Method)
+
+DESCRIPTION:
+   Forward SKB to other network device
+
+PARAMETERS
+   dev          [ I ] - Pointer to target net_device
+   skb          [ I ] - SKB buffer
+
+RETURN VALUE:
+   int - 0 for success
+         1 for error
+===========================================================================*/
+int gobi_dev_forward_skb(struct net_device *dev, struct sk_buff *skb)
+{
+   struct sk_buff *nskb;
+   int result = 0;
+   if(dev==NULL)
+      return 0;
+   nskb = skb;
+   nskb->dev = dev;
+   secpath_reset(nskb);
+   skb_dst_drop(nskb);
+   nf_reset(nskb);
+   nskb->ip_summed = CHECKSUM_NONE;
+   nskb->dev = dev;
+   #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,36 ))
+   skb_defer_rx_timestamp(skb);
+   #endif
+   result = _dev_forward_skb(dev, nskb);
+   if ( result != NET_RX_SUCCESS)
+   {
+      DBG( "Forword fail:%d\n",result );
+      dev->stats.rx_errors++;
+      return 1;
+   }
+   else
+   {
+      dev->stats.rx_packets++;
+      dev->stats.rx_bytes+= skb->len;
+      DBG( "NET_RX_SUCCESS\n" );
+      dev->stats.rx_packets++;
+      dev->stats.rx_bytes+= skb->len;
+   }
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   gobi_skb_push (Private Method)
+
+DESCRIPTION:
+   add data to the start of a buffer
+
+PARAMETERS
+   skb          [ I ] - SKB buffer
+   dev          [ I ] - amount of data to add
+
+RETURN VALUE:
+   NULL
+===========================================================================*/
+void *gobi_skb_push(struct sk_buff *pSKB, unsigned int len)
+{
+   if (pSKB->head +len > pSKB->data )
+    {
+       memmove(pSKB->data+len,pSKB->data, pSKB->len);
+       pSKB->len = pSKB->len + len;
+       pSKB->tail = pSKB->tail + len;
+    }
+    else
+    {
+       skb_push(pSKB,len);
+    }
+    return pSKB->data;
+}
+
+/*===========================================================================
+METHOD:
+   GobiUSBLockReset (Private Method)
+
+DESCRIPTION:
+   add data to the start of a buffer
+
+PARAMETERS
+   pIntf          [ I ] - usb interface
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int GobiUSBLockReset( struct usb_interface * pIntf )
+{
+   int ret =-1;
+   struct usb_device *udev;
+   if(!pIntf)
+   {
+      printk(KERN_ERR "NULL Intf\n");
+      return -1;
+   }
+   udev = interface_to_usbdev(pIntf);
+   if(!udev)
+   {
+      printk(KERN_ERR "NULL usb_device\n");
+      return -1;
+   }
+   ret = usb_lock_device_for_reset(udev, NULL);
+   if (ret < 0) 
+   {
+      printk(KERN_ERR "Err Reset Device\n");
+      return -1;
+   }
+   printk(KERN_INFO "Reset Device\n");
+   udev = interface_to_usbdev(pIntf);
+   usb_reset_device(udev);
+   usb_unlock_device(udev);
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   gobi_dev_deactivate (Private Method)
+
+DESCRIPTION:
+   Deactivate net device.
+
+PARAMETERS
+   dev          [ I ] - net device pointer
+
+RETURN VALUE:
+   NULL
+===========================================================================*/
+void gobi_dev_deactivate(struct net_device *dev)
+{
+   if (dev->flags & IFF_UP)
+   {
+      DBG("gobi_dev_deactivate\n");
+      if (!gobi_rtnl_trylock()) 
+      {
+         DBG("!gobi_rtnl_trylock\n");
+         return;
+      }
+      if (netif_carrier_ok(dev))
+      {
+         DBG("netif_carrier_off\n");
+         netif_carrier_off(dev);
+      }
+      DBG("netif_tx_stop_all_queues\n");
+      gobi_netif_stop_queue(dev);
+      #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,0,0 ))
+      DBG("dev_deactivate\n");
+      dev_deactivate(dev);
+      #endif
+      netdev_state_change(dev);
+      rtnl_unlock();
+   }
+}
+
+/*===========================================================================
+METHOD:
+   gobi_netif_stop_queue (Private Method)
+
+DESCRIPTION:
+   Stop all net device tx queue.
+
+PARAMETERS
+   dev          [ I ] - net device pointer
+
+RETURN VALUE:
+   NULL
+===========================================================================*/
+void gobi_netif_stop_queue(struct net_device *dev)
+{
+   netif_stop_queue(dev);
+   netif_tx_stop_all_queues(dev);
+}
+
+/*===========================================================================
+METHOD:
+   gobi_usbnet_stop (Private Method)
+
+DESCRIPTION:
+   Stop usbnet net deivce.
+
+PARAMETERS
+   dev          [ I ] - net device pointer
+
+RETURN VALUE:
+   NULL
+===========================================================================*/
+void gobi_usbnet_stop(struct net_device *dev)
+{
+   if(netif_running(dev))
+   {
+      DBG("gobi_usbnet_stop\n");
+      if (!gobi_rtnl_trylock()) 
+      {
+         DBG("!rtnl_trylock\n");
+         return;
+      }
+      if (netif_carrier_ok(dev))
+      {
+         DBG("netif_carrier_off\n");
+         netif_carrier_off(dev);
+      }
+      DBG("netif_tx_stop_all_queues\n");
+      gobi_netif_stop_queue(dev);
+      usbnet_stop(dev);
+      netdev_state_change(dev);
+      rtnl_unlock();
+   }
+}
+
+/*===========================================================================
+METHOD:
+   gobi_rtnl_trylock (Private Method)
+
+DESCRIPTION:
+   Stop usbnet net deivce.
+
+PARAMETERS
+   NULL
+
+RETURN VALUE:
+   int - 1 for success to lock
+         0 fail to lock
+===========================================================================*/
+int gobi_rtnl_trylock(void)
+{
+   int iCount= 0;
+   do
+   {
+      if (rtnl_trylock()) 
+      {
+         return 1;
+      }
+      wait_ms(100);
+   }while(iCount++<10);
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   stop_virtual_netdev (Private Method)
+
+DESCRIPTION:
+   Stop virtual adaptor net device.
+
+PARAMETERS
+   dev          [ I ] - net device pointer
+
+RETURN VALUE:
+   NULL
+===========================================================================*/
+void stop_virtual_netdev(struct net_device *dev)
+{
+   if (!gobi_rtnl_trylock()) 
+   {
+      DBG("!rtnl_trylock\n");
+      return;
+   }
+   gobi_netif_stop_queue(dev);
+   netif_carrier_off(dev);
+   netif_stop_queue(dev);
+   netdev_state_change(dev);
+   rtnl_unlock();
+}
+
+/*===========================================================================
+METHOD:
+   iIsRemoteWakeupSupport (Private Method)
+
+DESCRIPTION:
+   Check device remote wakeup is supported.
+
+PARAMETERS
+   pDev          [ I ] - net device pointer
+
+RETURN VALUE:
+   int - 0 not supported.
+       - 1 supported.
+===========================================================================*/
+int iIsRemoteWakeupSupport(struct usbnet *pDev)
+{
+   if( (pDev) &&
+       (pDev->udev) && 
+       (pDev->udev->config))
+   {
+      if(USB_CONF_ATTRIBUTE_REMOTE_WAKEUP_ENABLE & 
+         pDev->udev->config->desc.bmAttributes)
+      {
+         DBG("Remote WakeUp Enable\n");
+         return 1;
+      }
+      
+   }
+   return 0;
+}
+
+module_exit( GobiUSBNetModExit );
+
+MODULE_VERSION( DRIVER_VERSION );
+MODULE_AUTHOR( DRIVER_AUTHOR );
+MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_LICENSE( "Dual BSD/GPL" );
+
+#ifdef bool
+#undef bool
+#endif
+
+module_param( debug, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( debug, "Debuging enabled or not" );
+module_param( qos_debug, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( qos_debug, "QoS Debuging enabled or not" );
+
+module_param( interruptible, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( interruptible, "Listen for and return on user interrupt" );
+module_param( txQueueLength, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( txQueueLength, 
+                  "Number of IP packets which may be queued up for transmit" );
+module_param( iTEEnable, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( iTEEnable, "-1 : Ignore TE flow Control, 0 : TE Flow Control disabled, 1 : TE Flow Control enabled" );
+module_param( iRAWIPEnable, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( iRAWIPEnable, "RAWIP enabled or not" );
+MODULE_PARM_DESC( iQMAPEnable, "-1: Auto, 0 : QMAP disabled, 1 : QMAP enabled" );
+module_param( iQMAPEnable, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( iQMAPEnable, "QMAP enabled or not" );
+
+module_param( iMaxQMUXSupported, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( iMaxQMUXSupported, "-1: Auto, Max QMUX instance support" );
+
+module_param( iIPAlias, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( iIPAlias, "0 = virtual adapter , 1 (default) = IP alias" );
+
+module_param( iEthSrcMACNonZero, int, S_IRUGO | S_IWUSR );
+MODULE_PARM_DESC( iEthSrcMACNonZero, "0(default) = Ethernet Header Source Address : Zeros , 1  = Ethernet Header Source Address: Non-zero" );
+
diff --git a/drivers/net/usb/Kconfig b/drivers/net/usb/Kconfig
index f28bd74a..e711aaaa 100644
--- a/drivers/net/usb/Kconfig
+++ b/drivers/net/usb/Kconfig
@@ -612,4 +612,16 @@ config USB_NET_CH9200
 	  To compile this driver as a module, choose M here: the
 	  module will be called ch9200.
 
+config USB_NET_GOBINET
+	tristate "Qualcomm USB Network device for Gobi 3000"
+	select USB_NET_GOBISER
+	help
+	  Choose this option if you want to use GobiNet to drive a Sierra
+	  Wireless USB-to-WWAN device.
+
+config USB_NET_GOBISER
+	tristate "Qualcomm USB device for Gobi 3000 Serial"
+	help
+	  Choose this option if you want to use GobiSerial
+
 endif # USB_NET_DRIVERS
diff --git a/drivers/net/usb/Makefile b/drivers/net/usb/Makefile
index 27307a4a..152756c7 100644
--- a/drivers/net/usb/Makefile
+++ b/drivers/net/usb/Makefile
@@ -40,3 +40,7 @@ obj-$(CONFIG_USB_VL600)		+= lg-vl600.o
 obj-$(CONFIG_USB_NET_QMI_WWAN)	+= qmi_wwan.o
 obj-$(CONFIG_USB_NET_CDC_MBIM)	+= cdc_mbim.o
 obj-$(CONFIG_USB_NET_CH9200)	+= ch9200.o
+obj-$(CONFIG_USB_NET_GOBISER)	+= GobiSerial.o
+obj-$(CONFIG_USB_NET_GOBINET)   += GobiNet.o
+GobiNet-objs := GobiUSBNet.o QMIDevice.o QMI.o usbnet_2_6_32.o usbnet_3_0_6.o \
+	            usbnet_2_6_35.o usbnet_3_10_21.o usbnet_3_12_xx.o usbnet_4_4_xx.o
diff --git a/drivers/net/usb/QMI.c b/drivers/net/usb/QMI.c
new file mode 100644
index 00000000..c9593fe3
--- /dev/null
+++ b/drivers/net/usb/QMI.c
@@ -0,0 +1,2232 @@
+/*===========================================================================
+FILE:
+   QMI.c
+
+DESCRIPTION:
+   Qualcomm QMI driver code
+
+FUNCTIONS:
+   Generic QMUX functions
+      ParseQMUX
+      FillQMUX
+
+   Generic QMI functions
+      GetTLV
+      ValidQMIMessage
+      GetQMIMessageID
+
+   Fill Buffers with QMI requests
+      QMICTLGetClientIDReq
+      QMICTLReleaseClientIDReq
+      QMICTLReadyReq
+      QMIWDSSetEventReportReq
+      QMIWDSGetPKGSRVCStatusReq
+      QMIDMSGetMEIDReq
+      QMIDMSSWISetFCCAuthReq
+      QMIWDASetDataFormatReq
+      QMICTLSetDataFormatReq
+      QMICTLSyncReq
+
+   Parse data from QMI responses
+      QMICTLGetClientIDResp
+      QMICTLReleaseClientIDResp
+      QMIWDSEventResp
+      QMIDMSGetMEIDResp
+      QMIWDASetDataFormatResp
+      QMICTLSetDataFormatResp
+      QMICTLSyncResp
+
+Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Code Aurora Forum nor
+      the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+Alternatively, provided that this notice is retained in full, this software
+may be relicensed by the recipient under the terms of the GNU General Public
+License version 2 ("GPL") and only version 2, in which case the provisions of
+the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
+software under the GPL, then the identification text in the MODULE_LICENSE
+macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
+recipient changes the license terms to the GPL, subsequent recipients shall
+not relicense under alternate licensing terms, including the BSD or dual
+BSD/GPL terms.  In addition, the following license statement immediately
+below and between the words START and END shall also then apply when this
+software is relicensed under the GPL:
+
+START
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License version 2 and only version 2 as
+published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+END
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+#include <asm/unaligned.h>
+#include <linux/kernel.h>
+#include "Structs.h"
+#include "QMI.h"
+
+extern int debug;
+
+#define QMIWDASETDATAFORMATQMAPREQSIZE 39
+/*=========================================================================*/
+// Get sizes of buffers needed by QMI requests
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   QMUXHeaderSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX
+
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMUXHeaderSize( void )
+{
+   return sizeof( sQMUX );
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLGetClientIDReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMICTLGetClientIDReq
+
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMICTLGetClientIDReqSize( void )
+{
+   return sizeof( sQMUX ) + 10;
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLReleaseClientIDReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMICTLReleaseClientIDReq
+
+RETURN VALUE:
+   u16 - size of header
+===========================================================================*/
+u16 QMICTLReleaseClientIDReqSize( void )
+{
+   return sizeof( sQMUX ) + 11;
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLReadyReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMICTLReadyReq
+
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMICTLReadyReqSize( void )
+{
+   return sizeof( sQMUX ) + 6;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDSSetEventReportReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMIWDSSetEventReportReq
+
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMIWDSSetEventReportReqSize( void )
+{
+   return sizeof( sQMUX ) + 15;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDSGetPKGSRVCStatusReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMIWDSGetPKGSRVCStatusReq
+
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMIWDSGetPKGSRVCStatusReqSize( void )
+{
+   return sizeof( sQMUX ) + 7;
+}
+
+/*===========================================================================
+METHOD:
+   QMIDMSGetMEIDReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMIDMSGetMEIDReq
+
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMIDMSGetMEIDReqSize( void )
+{
+   return sizeof( sQMUX ) + 7;
+}
+
+/*===========================================================================
+METHOD:
+   QMIDMSSWISetFCCAuthReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMIDMSSWISetFCCAuthReq
+
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMIDMSSWISetFCCAuthReqSize( void )
+{
+   return sizeof( sQMUX ) + 7;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDASetDataFormatReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMIWDASetDataFormatReq
+
+PARAMETERS
+   te_flow_control [ I ] - TE Flow Control Flag
+                          - eSKIP_TE_FLOW_CONTROL_TLV - Not Set TE Flow control.
+                          - eTE_FLOW_CONTROL_TLV_0 - Set TE Flow Control disabled.
+                          - eTE_FLOW_CONTROL_TLV_1 - Set TE Flow Control enabled.
+
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMIWDASetDataFormatReqSize( int te_flow_control ,int qmuxenable)
+{
+   u16 uQmuxLength =0;
+   if(qmuxenable!=0)
+   {
+      uQmuxLength = QMIWDASETDATAFORMATQMAPREQSIZE;
+   }
+   if(te_flow_control!=eSKIP_TE_FLOW_CONTROL_TLV)
+   {
+      return sizeof( sQMUX ) + 29 + uQmuxLength; /* TE_FLOW_CONTROL */
+   }
+   else
+   {
+      return sizeof( sQMUX ) + 25 + uQmuxLength;
+   }
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLSetDataFormatReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMICTLSetDataFormatReq
+ 
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16  QMICTLSetDataFormatReqSize( void )
+{
+   return sizeof( sQMUX ) + 15; 
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLSyncReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMICTLSyncReq
+ 
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16  QMICTLSyncReqSize( void )
+{
+   return sizeof( sQMUX ) + 6; 
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLGetVersionInfoReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMICTLGetVersionInfoReq
+ 
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16  QMICTLGetVersionInfoReqSize( void )
+{
+   return sizeof( sQMUX ) + 6; 
+}
+
+/*=========================================================================*/
+// Generic QMUX functions
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   ParseQMUX (Public Method)
+
+DESCRIPTION:
+   Remove QMUX headers from a buffer
+
+PARAMETERS
+   pClientID       [ O ] - On success, will point to Client ID
+   pBuffer         [ I ] - Full Message passed in
+   buffSize        [ I ] - Size of pBuffer
+
+RETURN VALUE:
+   int - Positive for size of QMUX header
+         Negative errno for error
+===========================================================================*/
+int ParseQMUX(
+   u16 *    pClientID,
+   void *   pBuffer,
+   u16      buffSize )
+{
+   sQMUX * pQMUXHeader;
+
+   if (pBuffer == 0 || buffSize < 12)
+   {
+      return -ENOMEM;
+   }
+
+   // QMUX Header
+   pQMUXHeader = (sQMUX *)pBuffer;
+
+   if (pQMUXHeader->mTF != 1
+   ||  le16_to_cpu(get_unaligned(&pQMUXHeader->mLength)) != buffSize - 1
+   ||  pQMUXHeader->mCtrlFlag != 0x80 )
+   {
+      return -EINVAL;
+   }
+
+   // Client ID
+   *pClientID = (pQMUXHeader->mQMIClientID << 8) + pQMUXHeader->mQMIService;
+
+   return sizeof( sQMUX );
+}
+
+/*===========================================================================
+METHOD:
+   FillQMUX (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMUX headers
+
+PARAMETERS
+   clientID        [ I ] - Client ID
+   pBuffer         [ O ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer (must be at least 6)
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int FillQMUX(
+   u16      clientID,
+   void *   pBuffer,
+   u16      buffSize )
+{
+   sQMUX * pQMUXHeader;
+
+   if (pBuffer == 0 ||  buffSize < sizeof( sQMUX ))
+   {
+      return -ENOMEM;
+   }
+
+   // QMUX Header
+   pQMUXHeader = (sQMUX *)pBuffer;
+
+   pQMUXHeader->mTF = 1;
+   put_unaligned(cpu_to_le16(buffSize - 1), &pQMUXHeader->mLength);
+   DBG("pQMUXHeader->mLength = 0x%x, buffSize - 1 = 0x%x\n",pQMUXHeader->mLength, buffSize - 1);
+   pQMUXHeader->mCtrlFlag = 0;
+
+   // Service and Client ID
+   pQMUXHeader->mQMIService = clientID & 0xff;
+   pQMUXHeader->mQMIClientID = clientID >> 8;
+
+   return 0;
+}
+
+/*=========================================================================*/
+// Generic QMI functions
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   GetTLV (Public Method)
+
+DESCRIPTION:
+   Get data buffer of a specified TLV from a QMI message
+
+   QMI Message shall NOT include SDU
+
+PARAMETERS
+   pQMIMessage    [ I ] - QMI Message buffer
+   messageLen     [ I ] - Size of QMI Message buffer
+   type           [ I ] - Desired Type
+   pOutDataBuf    [ O ] - Buffer to be filled with TLV
+   messageLen     [ I ] - Size of QMI Message buffer
+
+RETURN VALUE:
+   u16 - Size of TLV for success
+         Negative errno for error
+===========================================================================*/
+u16 GetTLV(
+   void *   pQMIMessage,
+   u16      messageLen,
+   u8       type,
+   void *   pOutDataBuf,
+   u16      bufferLen )
+{
+   u16 pos;
+   u16 tlvSize = 0;
+   u16 cpyCount;
+
+   if (pQMIMessage == 0 || pOutDataBuf == 0)
+   {
+      return -ENOMEM;
+   }
+
+   for (pos = 4;
+        pos + 3 < messageLen;
+        pos += tlvSize + 3)
+   {
+      tlvSize = le16_to_cpu( get_unaligned(((u16 *)(pQMIMessage + pos + 1) )) );
+      if (*(u8 *)(pQMIMessage + pos) == type)
+      {
+         if (bufferLen < tlvSize)
+         {
+            return -ENOMEM;
+         }
+
+         for (cpyCount = 0; cpyCount < tlvSize; cpyCount++)
+         {
+            *((char*)(pOutDataBuf + cpyCount)) = *((char*)(pQMIMessage + pos + 3 + cpyCount));
+         }
+         
+         return tlvSize;
+      }
+   }
+
+   return -ENOMSG;
+}
+
+void PrintIPAddr(char *msg, unsigned int addr)
+{
+   DBG("%s : %d.%d.%d.%d",
+        msg,
+        addr >> 24,
+        (addr >> 16) & 0xff,
+        (addr >> 8) & 0xff,
+        (addr ) & 0xff
+        );
+}
+
+/*===========================================================================
+METHOD:
+   ValidQMIMessage (Public Method)
+
+DESCRIPTION:
+   Check mandatory TLV in a QMI message
+
+   QMI Message shall NOT include SDU
+
+PARAMETERS
+   pQMIMessage    [ I ] - QMI Message buffer
+   messageLen     [ I ] - Size of QMI Message buffer
+
+RETURN VALUE:
+   int - 0 for success (no error)
+         Negative errno for error
+         Positive for QMI error code
+===========================================================================*/
+int ValidQMIMessage(
+   void *   pQMIMessage,
+   u16      messageLen )
+{
+   char mandTLV[4];
+
+   if (GetTLV( pQMIMessage, messageLen, 2, &mandTLV[0], 4 ) == 4)
+   {
+      // Found TLV
+      if (*(u16 *)&mandTLV[0] != 0)
+      {
+         return le16_to_cpu( get_unaligned(&mandTLV[2]) );
+      }
+      else
+      {
+         return 0;
+      }
+   }
+   else
+   {
+      return -ENOMSG;
+   }
+}
+
+/*===========================================================================
+METHOD:
+   GetQMIMessageID (Public Method)
+
+DESCRIPTION:
+   Get the message ID of a QMI message
+
+   QMI Message shall NOT include SDU
+
+PARAMETERS
+   pQMIMessage    [ I ] - QMI Message buffer
+   messageLen     [ I ] - Size of QMI Message buffer
+
+RETURN VALUE:
+   int - Positive for message ID
+         Negative errno for error
+===========================================================================*/
+int GetQMIMessageID(
+   void *   pQMIMessage,
+   u16      messageLen )
+{
+   if (messageLen < 2)
+   {
+      return -ENODATA;
+   }
+   else
+   {
+      return le16_to_cpu( get_unaligned((u16 *)pQMIMessage) );
+   }
+}
+
+/*=========================================================================*/
+// Fill Buffers with QMI requests
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   QMICTLGetClientIDReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI CTL Get Client ID Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+   serviceType     [ I ] - Service type requested
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMICTLGetClientIDReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID,
+   u8       serviceType )
+{
+   if (pBuffer == 0 || buffSize < QMICTLGetClientIDReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   // QMI CTL GET CLIENT ID
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))= 0x00;
+   // Transaction ID
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 1) = transactionID;
+   // Message ID
+   put_unaligned(cpu_to_le16(0x0022), (u16 *)(pBuffer + sizeof( sQMUX ) + 2));
+   // Size of TLV's
+   put_unaligned(cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + 4));
+   // QMI Service Type
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 6)  = 0x01;
+   // Size
+   put_unaligned(cpu_to_le16(0x0001), (u16 *)(pBuffer + sizeof( sQMUX ) + 7));
+   // QMI svc type
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 9)  = serviceType;
+
+  // success
+  return sizeof( sQMUX ) + 10;
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLReleaseClientIDReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI CTL Release Client ID Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+   clientID        [ I ] - Service type requested
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMICTLReleaseClientIDReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID,
+   u16      clientID )
+{
+   if (pBuffer == 0 || buffSize < QMICTLReleaseClientIDReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   DBG(  "buffSize: 0x%x, transactionID: 0x%x, clientID: 0x%x,\n",
+         buffSize, transactionID, clientID );
+
+   // QMI CTL RELEASE CLIENT ID REQ
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00;
+   // Transaction ID
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 1 ) = transactionID;
+   // Message ID
+   put_unaligned( cpu_to_le16(0x0023), (u16 *)(pBuffer + sizeof( sQMUX ) + 2) );
+   // Size of TLV's
+   put_unaligned( cpu_to_le16(0x0005), (u16 *)(pBuffer + sizeof( sQMUX ) + 4) );
+   // Release client ID
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 6)  = 0x01;
+   // Size
+   put_unaligned( cpu_to_le16(0x0002), (u16 *)(pBuffer + sizeof( sQMUX ) + 7));
+   // QMI svs type / Client ID
+   put_unaligned(cpu_to_le16(clientID), (u16 *)(pBuffer + sizeof( sQMUX ) + 9));
+
+   // success
+   return sizeof( sQMUX ) + 11;
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLReadyReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI CTL Get Version Info Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMICTLReadyReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID )
+{
+   if (pBuffer == 0 || buffSize < QMICTLReadyReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   DBG("buffSize: 0x%x, transactionID: 0x%x\n", buffSize, transactionID);
+
+   // QMI CTL GET VERSION INFO REQ
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00;
+   // Transaction ID
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 1) = transactionID;
+   // Message ID
+   put_unaligned( cpu_to_le16(0x0021), (u16 *)(pBuffer + sizeof( sQMUX ) + 2) );
+   // Size of TLV's
+   put_unaligned( cpu_to_le16(0x0000), (u16 *)(pBuffer + sizeof( sQMUX ) + 4) );
+
+  // success
+  return sizeof( sQMUX ) + 6;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDSSetEventReportReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI WDS Set Event Report Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMIWDSSetEventReportReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID )
+{
+   if (pBuffer == 0 || buffSize < QMIWDSSetEventReportReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   // QMI WDS SET EVENT REPORT REQ
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00;
+   // Transaction ID
+   put_unaligned( cpu_to_le16(transactionID), (u16 *)(pBuffer + sizeof( sQMUX ) + 1));
+   // Message ID
+   put_unaligned( cpu_to_le16(0x0001), (u16 *)(pBuffer + sizeof( sQMUX ) + 3));
+   // Size of TLV's
+   put_unaligned(cpu_to_le16(0x0008), (u16 *)(pBuffer + sizeof( sQMUX ) + 5));
+   // Report channel rate TLV
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 7)  = 0x11;
+   // Size
+   put_unaligned( cpu_to_le16(0x0005), (u16 *)(pBuffer + sizeof( sQMUX ) + 8));
+   // Stats period
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 10)  = 0x01;
+   // Stats mask
+   put_unaligned( cpu_to_le32(0x000000ff), (u32 *)(pBuffer + sizeof( sQMUX ) + 11) );
+
+  // success
+  return sizeof( sQMUX ) + 15;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDSGetPKGSRVCStatusReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI WDS Get PKG SRVC Status Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMIWDSGetPKGSRVCStatusReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID )
+{
+   if (pBuffer == 0 || buffSize < QMIWDSGetPKGSRVCStatusReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   // QMI WDS Get PKG SRVC Status REQ
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00;
+   // Transaction ID
+   put_unaligned(cpu_to_le16(transactionID), (u16 *)(pBuffer + sizeof( sQMUX ) + 1));
+   // Message ID
+   put_unaligned(cpu_to_le16(0x0022), (u16 *)(pBuffer + sizeof( sQMUX ) + 3));
+   // Size of TLV's
+   put_unaligned(cpu_to_le16(0x0000), (u16 *)(pBuffer + sizeof( sQMUX ) + 5));
+
+   // success
+   return sizeof( sQMUX ) + 7;
+}
+
+/*===========================================================================
+METHOD:
+   QMIDMSGetMEIDReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI DMS Get Serial Numbers Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMIDMSGetMEIDReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID )
+{
+   if (pBuffer == 0 || buffSize < QMIDMSGetMEIDReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   // QMI DMS GET SERIAL NUMBERS REQ
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00;
+   // Transaction ID
+   put_unaligned( cpu_to_le16(transactionID), (u16 *)(pBuffer + sizeof( sQMUX ) + 1) );
+   // Message ID
+   put_unaligned( cpu_to_le16(0x0025), (u16 *)(pBuffer + sizeof( sQMUX ) + 3) );
+   // Size of TLV's
+   put_unaligned( cpu_to_le16(0x0000), (u16 *)(pBuffer + sizeof( sQMUX ) + 5));
+
+   // success
+   return sizeof( sQMUX ) + 7;
+}
+
+
+/*===========================================================================
+METHOD:
+   QMIDMSSWISetFCCAuthReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI DMS Get FCC Authentication Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMIDMSSWISetFCCAuthReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID )
+{
+   if (pBuffer == 0 || buffSize < QMIDMSSWISetFCCAuthReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   // QMI DMS SET FCC AUTH REQ
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00;
+   // Transaction ID
+   put_unaligned( cpu_to_le16(transactionID), (u16 *)(pBuffer + sizeof( sQMUX ) + 1) );
+   // Message ID
+   put_unaligned( cpu_to_le16(0x555F), (u16 *)(pBuffer + sizeof( sQMUX ) + 3) );
+   // Size of TLV's
+   put_unaligned( cpu_to_le16(0x0000), (u16 *)(pBuffer + sizeof( sQMUX ) + 5));
+
+   // success
+   return QMIDMSSWISetFCCAuthReqSize();
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDASetDataFormatReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI WDA Set Data Format Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+   te_flow_control [ I ] - TE Flow Control Flag
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMIWDASetDataFormatReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID,
+   int     te_flow_control,
+   int      iDataMode,
+   unsigned mIntfNum,
+   int      iqmuxenable)
+{
+   u32 uTotalTlvLength = 0;
+   int iIndex = 25;
+
+   if (pBuffer == 0 || buffSize < QMIWDASetDataFormatReqSize(te_flow_control,iqmuxenable) )
+   {
+      return -ENOMEM;
+   }
+
+   // QMI WDA SET DATA FORMAT REQ
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00;
+
+   // Transaction ID
+   put_unaligned( cpu_to_le16(transactionID), (u16 *)(pBuffer + sizeof( sQMUX ) + 1) );
+
+   // Message ID
+   put_unaligned( cpu_to_le16(0x0020), (u16 *)(pBuffer + sizeof( sQMUX ) + 3) );
+   if(iqmuxenable!=0)
+   {
+      uTotalTlvLength = QMIWDASETDATAFORMATQMAPREQSIZE;
+   }
+   // Size of TLV's
+   if(te_flow_control!=eSKIP_TE_FLOW_CONTROL_TLV)
+   {
+      /* TE_FLOW_CONTROL */
+      put_unaligned( cpu_to_le16(0x0016 + uTotalTlvLength), (u16 *)(pBuffer + sizeof( sQMUX ) + 5));
+      uTotalTlvLength += 0x0016;
+   }
+   else
+   {
+      put_unaligned( cpu_to_le16(0x0012 + uTotalTlvLength), (u16 *)(pBuffer + sizeof( sQMUX ) + 5));
+      uTotalTlvLength += 0x0012;
+   } 
+   
+   // Tlv 0x10 QOS Data Format
+   /* TLVType QOS Data Format 1 byte  */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) +  7) = 0x10; // type data format
+
+   /* TLVLength  2 bytes - see spec */
+   put_unaligned( cpu_to_le16(0x0001), (u16 *)(pBuffer + sizeof( sQMUX ) + 8)); 
+
+   /* DataFormat: 0-default; 1-QoS hdr present 2 bytes */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 10) = 0; /* no-QOS header */
+   uTotalTlvLength -= (1+2+1);
+   //End Tlv 0x10
+   
+   //Tlv 0x11 Link protocol used by the client
+   /* TLVType Link-Layer Protocol  (Optional) 1 byte */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 11) = 0x11;
+
+   /* TLVLength 2 bytes */
+   put_unaligned( cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + 12));
+
+   /* LinkProt: 0x1 - ETH; 0x2 - rawIP  4 bytes */
+   if(iDataMode==eDataMode_RAWIP)
+   {
+      /* Set RawIP mode */
+      put_unaligned( cpu_to_le32(0x00000002), (u32 *)(pBuffer + sizeof( sQMUX ) + 14));
+      DBG("Request RawIP Data Format\n");
+   }
+   else
+   {
+      /* Set Ethernet  mode */
+      put_unaligned( cpu_to_le32(0x00000001), (u32 *)(pBuffer + sizeof( sQMUX ) + 14));
+      DBG("Request Ethernet Data Format\n");
+   }
+   uTotalTlvLength -= (1+2+4);
+   //End Tlv 0x11
+
+   //Tlv 0x13 Downlink Data Aggregation Protocol
+   /* TLVType Uplink Data Aggression Protocol - 1 byte */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 18) = 0x13;
+
+   /* TLVLength 2 bytes */
+   put_unaligned( cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + 19));
+
+   /* TLV Data */
+   if(iqmuxenable!=0)
+   {
+      //DL QMAP is enabled
+      put_unaligned( cpu_to_le32(0x00000005), (u32 *)(pBuffer + sizeof( sQMUX ) + 21));
+   }
+   else
+   {
+      //DL data aggregation is disabled
+      put_unaligned( cpu_to_le32(0x00000000), (u32 *)(pBuffer + sizeof( sQMUX ) + 21));
+   }
+   uTotalTlvLength -= (1+2+4);
+   //End 0x13
+
+   //Tlv 0x1A TE Flow Control
+   if(te_flow_control!=eSKIP_TE_FLOW_CONTROL_TLV)
+   {
+      /* TLVType Flow Control - 1 byte */
+      *(u8 *)(pBuffer + sizeof( sQMUX ) + iIndex) = 0x1A;
+      iIndex++;
+      /* TLVLength 2 bytes */
+      put_unaligned( cpu_to_le16(0x0001), (u16 *)(pBuffer + sizeof( sQMUX ) + iIndex));
+      iIndex+=2;
+      /* Flow Control: 0 - not done by TE; 1 - done by TE  1 byte */
+      if(te_flow_control==eTE_FLOW_CONTROL_TLV_0)
+      {
+         *(u8 *)(pBuffer + sizeof( sQMUX ) + 28) = 0; /* flow control done by TE */
+      }
+      else
+      {
+         *(u8 *)(pBuffer + sizeof( sQMUX ) + 28) = 1; /* flow control done by TE */
+      }
+      iIndex+=1;
+      uTotalTlvLength -= (1+2+1);
+   } /* TE_FLOW_CONTROL */
+   //End Tlv 0x1A
+   // success
+   if(iqmuxenable==0)
+   {
+      if(uTotalTlvLength!=0)
+      {
+         printk(KERN_WARNING "uTotalTlvLength:0x%x",uTotalTlvLength);
+      }
+      return QMIWDASetDataFormatReqSize(te_flow_control,iqmuxenable);
+   }
+   //Tlv 0x12 Uplink Data Aggregation Protocol
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + iIndex)  = 0x12;
+   iIndex++;
+   // Size
+   put_unaligned( cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + iIndex));
+   iIndex+=2;
+   // UL QMAP is enabled
+   put_unaligned( cpu_to_le32(0x00000005), (u32 *)(pBuffer + sizeof( sQMUX ) + iIndex));
+   iIndex+=4;
+   uTotalTlvLength -= (1+2+4);
+   //End Tlv 0x12
+   
+   
+   //Tlv 0x15 Downlink Data Aggregation Max Datagrams
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + iIndex)  = 0x15;
+   iIndex++;
+   // Size
+   put_unaligned( cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + iIndex));
+   iIndex+=2;
+   // Datagram is set as 32768
+   put_unaligned( cpu_to_le32(0x00000020), (u32 *)(pBuffer + sizeof( sQMUX ) + iIndex));
+   iIndex+=4;
+   uTotalTlvLength -= (1+2+4);
+   //End Tlv 0x15
+   
+
+   //Tlv 0x16 Downlink Data Aggregation Max Size
+   // DL Data aggregation Max datagrams
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + iIndex)  = 0x16;
+   iIndex++;
+   // Size
+   put_unaligned( cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + iIndex));
+   iIndex+=2;
+   // Datagram is set as 32768
+   put_unaligned( cpu_to_le32(QMAP_SIZE_OF_RX_BUFFER), (u32 *)(pBuffer + sizeof( sQMUX ) + iIndex));
+   DBG("Datagramsize:%d\n",QMAP_SIZE_OF_RX_BUFFER);
+
+   iIndex+=4;
+   uTotalTlvLength -= (1+2+4);
+   //End Tlv 0x16
+   //Tlv 0x17 Peripheral End Point ID
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + iIndex)  = 0x17;
+   iIndex++;
+   // Size
+   put_unaligned( cpu_to_le16(0x0008), (u16 *)(pBuffer + sizeof( sQMUX ) + iIndex));
+   iIndex+=2;
+   // Datagram is set as 32768
+   put_unaligned( cpu_to_le32(0x00000002), (u32 *)(pBuffer + sizeof( sQMUX ) + iIndex));
+   iIndex+=4;
+   put_unaligned( cpu_to_le32(mIntfNum), (u32 *)(pBuffer + sizeof( sQMUX ) + iIndex));
+   iIndex+=4;
+   uTotalTlvLength -= (1+2+8);
+   //End Tlv 0x17
+
+   //Tlv 0x19 QMAP Downlink Minimum Padding
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + iIndex)  = 0x19;
+   iIndex++;
+   // Size
+   put_unaligned( cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + iIndex));
+   iIndex+=2;
+   // Set padding length to zero
+   put_unaligned(cpu_to_le32(0x00000000), (u32 *)(pBuffer + sizeof( sQMUX ) + iIndex));
+   iIndex+=4;
+   uTotalTlvLength -= (1+2+4);
+   //End Tlv 0x19
+   if(uTotalTlvLength!=0)
+   {
+      printk(KERN_WARNING "uTotalTlvLength:0x%x",uTotalTlvLength);
+   }
+   return iIndex;
+}
+
+
+
+/*===========================================================================
+METHOD:
+   QMICTLSetDataFormatReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI CTL Set Data Format Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMICTLSetDataFormatReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID ,
+   int      iDataMode)
+{
+   if (pBuffer == 0 || buffSize < QMICTLSetDataFormatReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   /* QMI CTL Set Data Format Request */
+   /* Request */
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00; // QMICTL_FLAG_REQUEST
+   
+   /* Transaction ID 1 byte */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 1) = transactionID; /* 1 byte as in spec */
+
+   /* QMICTLType  2 bytes */
+   put_unaligned( cpu_to_le16(0x0026), (u16 *)(pBuffer + sizeof( sQMUX ) + 2));
+
+   /* Length  2 bytes  of 2 TLVs  each - see spec */
+   put_unaligned( cpu_to_le16(0x0009), (u16 *)(pBuffer + sizeof( sQMUX ) + 4));
+
+   /* TLVType Data Format (Mandatory)  1 byte  */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) +  6) = 0x01; // type data format
+
+   /* TLVLength  2 bytes - see spec */
+   put_unaligned( cpu_to_le16(0x0001), (u16 *)(pBuffer + sizeof( sQMUX ) + 7)); 
+
+   /* DataFormat: 0-default; 1-QoS hdr present 2 bytes */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 9) = 0; /* no-QOS header */
+
+    /* TLVType Link-Layer Protocol  (Optional) 1 byte */
+    *(u8 *)(pBuffer + sizeof( sQMUX ) + 10) = TLV_TYPE_LINK_PROTO;
+
+    /* TLVLength 2 bytes */
+    put_unaligned( cpu_to_le16(0x0002), (u16 *)(pBuffer + sizeof( sQMUX ) + 11));
+
+   /* LinkProt: 0x1 - ETH; 0x2 - rawIP  2 bytes */
+   if(iDataMode==eDataMode_RAWIP)
+   {
+      /* Set RawIP mode */
+      put_unaligned( cpu_to_le16(0x0002), (u16 *)(pBuffer + sizeof( sQMUX ) + 13));
+      DBG("Request RawIP Data Format\n");
+   }
+   else
+   {
+      /* Set Ethernet  mode */
+      put_unaligned( cpu_to_le16(0x0001), (u16 *)(pBuffer + sizeof( sQMUX ) + 13));
+      DBG("Request Ethernet Data Format\n");
+   }
+
+   /* success */
+   return sizeof( sQMUX ) + 15;
+
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLSyncReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI CTL Sync Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMICTLSyncReq(
+   void *pBuffer,
+   u16  buffSize,
+   u16  transactionID )
+{
+   if (pBuffer == 0 || buffSize < QMICTLSyncReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00;
+   // Transaction ID
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 1) = transactionID;
+   // Message ID
+   put_unaligned( cpu_to_le16(0x0027), (u16 *)(pBuffer + sizeof( sQMUX ) + 2) );
+   // Size of TLV's
+   put_unaligned( cpu_to_le16(0x0000), (u16 *)(pBuffer + sizeof( sQMUX ) + 4) );
+
+  // success
+  return sizeof( sQMUX ) + 6;
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLGetVersionInfoReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI CTL Version Info Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMICTLGetVersionInfoReq(
+   void *pBuffer,
+   u16  buffSize,
+   u16  transactionID )
+{
+   if (pBuffer == 0 || buffSize < QMICTLGetVersionInfoReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00;
+   // Transaction ID
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 1) = transactionID;
+   // Message ID
+   put_unaligned( cpu_to_le16(0x0021), (u16 *)(pBuffer + sizeof( sQMUX ) + 2) );
+   // Size of TLV's
+   put_unaligned( cpu_to_le16(0x0000), (u16 *)(pBuffer + sizeof( sQMUX ) + 4) );
+
+  // success
+  return sizeof( sQMUX ) + 6;
+}
+
+/*=========================================================================*/
+// Parse data from QMI responses
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   QMICTLGetClientIDResp (Public Method)
+
+DESCRIPTION:
+   Parse the QMI CTL Get Client ID Resp
+
+PARAMETERS
+   pBuffer         [ I ] - Buffer to be parsed
+   buffSize        [ I ] - Size of pBuffer
+   pClientID       [ 0 ] - Recieved client ID
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int QMICTLGetClientIDResp(
+   void * pBuffer,
+   u16    buffSize,
+   u16 *  pClientID )
+{
+   int result;
+
+   // Ignore QMUX and SDU
+   //    QMI CTL SDU is 2 bytes, not 3
+   u8 offset = sizeof( sQMUX ) + 2;
+
+   if (pBuffer == 0 || buffSize < offset )
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   if (result != 0x22)
+   {
+      return -EFAULT;
+   }
+
+   result = ValidQMIMessage( pBuffer, buffSize );
+   if (result != 0)
+   {
+      return -EFAULT;
+   }
+
+   result = GetTLV( pBuffer, buffSize, 0x01, pClientID, 2 );
+   if (result != 2)
+   {
+      return -EFAULT;
+   }
+
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLReleaseClientIDResp (Public Method)
+
+DESCRIPTION:
+   Verify the QMI CTL Release Client ID Resp is valid
+
+PARAMETERS
+   pBuffer         [ I ] - Buffer to be parsed
+   buffSize        [ I ] - Size of pBuffer
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int QMICTLReleaseClientIDResp(
+   void *   pBuffer,
+   u16      buffSize )
+{
+   int result;
+
+   // Ignore QMUX and SDU
+   //    QMI CTL SDU is 2 bytes, not 3
+   u8 offset = sizeof( sQMUX ) + 2;
+
+   if (pBuffer == 0 || buffSize < offset)
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   if (result != 0x23)
+   {
+      return -EFAULT;
+   }
+
+   result = ValidQMIMessage( pBuffer, buffSize );
+   if (result != 0)
+   {
+      return -EFAULT;
+   }
+
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDSEventResp (Public Method)
+
+DESCRIPTION:
+   Parse the QMI WDS Set Event Report Resp/Indication or
+      QMI WDS Get PKG SRVC Status Resp/Indication
+
+   Return parameters will only be updated if value was received
+
+PARAMETERS
+   pBuffer         [ I ] - Buffer to be parsed
+   buffSize        [ I ] - Size of pBuffer
+   pTXOk           [ O ] - Number of transmitted packets without errors
+   pRXOk           [ O ] - Number of recieved packets without errors
+   pTXErr          [ O ] - Number of transmitted packets with framing errors
+   pRXErr          [ O ] - Number of recieved packets with framing errors
+   pTXOfl          [ O ] - Number of transmitted packets dropped due to overflow
+   pRXOfl          [ O ] - Number of recieved packets dropped due to overflow
+   pTXBytesOk      [ O ] - Number of transmitted bytes without errors
+   pRXBytesOk      [ O ] - Number of recieved bytes without errors
+   pbLinkState     [ 0 ] - Is the link active?
+   pbReconfigure   [ 0 ] - Must interface be reconfigured? (reset IP address)
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int QMIWDSEventResp(
+   void *   pBuffer,
+   u16      buffSize,
+   u32 *    pTXOk,
+   u32 *    pRXOk,
+   u32 *    pTXErr,
+   u32 *    pRXErr,
+   u32 *    pTXOfl,
+   u32 *    pRXOfl,
+   u64 *    pTXBytesOk,
+   u64 *    pRXBytesOk,
+   bool *   pbLinkState,
+   bool *   pbReconfigure )
+{
+   int result;
+   u8 pktStatusRead[2];
+
+   // Ignore QMUX and SDU
+   u8 offset = sizeof( sQMUX ) + 3;
+
+   if (pBuffer == 0
+   || buffSize < offset
+   || pTXOk == 0
+   || pRXOk == 0
+   || pTXErr == 0
+   || pRXErr == 0
+   || pTXOfl == 0
+   || pRXOfl == 0
+   || pTXBytesOk == 0
+   || pRXBytesOk == 0
+   || pbLinkState == 0
+   || pbReconfigure == 0 )
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   // Note: Indications.  No Mandatory TLV required
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   // QMI WDS Set Event Report Resp
+   if (result == 0x01)
+   {
+      // TLV's are not mandatory
+      GetTLV( pBuffer, buffSize, 0x10, (void*)pTXOk, 4 );
+      put_unaligned( le32_to_cpu(*pTXOk), pTXOk);
+      GetTLV( pBuffer, buffSize, 0x11, (void*)pRXOk, 4 );
+      put_unaligned( le32_to_cpu(*pRXOk), pRXOk);
+      GetTLV( pBuffer, buffSize, 0x12, (void*)pTXErr, 4 );
+      put_unaligned( le32_to_cpu(*pTXErr), pTXErr);
+      GetTLV( pBuffer, buffSize, 0x13, (void*)pRXErr, 4 );
+      put_unaligned( le32_to_cpu(*pRXErr), pRXErr);
+      GetTLV( pBuffer, buffSize, 0x14, (void*)pTXOfl, 4 );
+      put_unaligned( le32_to_cpu(*pTXOfl), pTXOfl);
+      GetTLV( pBuffer, buffSize, 0x15, (void*)pRXOfl, 4 );
+      put_unaligned( le32_to_cpu(*pRXOfl), pRXOfl);
+      GetTLV( pBuffer, buffSize, 0x19, (void*)pTXBytesOk, 8 );
+      put_unaligned( le64_to_cpu(*pTXBytesOk), pTXBytesOk);
+      GetTLV( pBuffer, buffSize, 0x1A, (void*)pRXBytesOk, 8 );
+      put_unaligned( le64_to_cpu(*pRXBytesOk), pRXBytesOk);
+   }
+   // QMI WDS Get PKG SRVC Status Resp
+   else if (result == 0x22)
+   {
+      result = GetTLV( pBuffer, buffSize, 0x01, &pktStatusRead[0], 2 );
+      // 1 or 2 bytes may be received
+      if (result >= 1)
+      {
+         if (pktStatusRead[0] == 0x02)
+         {
+            *pbLinkState = true;
+         }
+         else
+         {
+            *pbLinkState = false;
+         }
+      }
+      if (result == 2)
+      {
+         if (pktStatusRead[1] == 0x01)
+         {
+            *pbReconfigure = true;
+         }
+         else
+         {
+            *pbReconfigure = false;
+         }
+      }
+
+      if (result < 0)
+      {
+         return result;
+      }
+   }
+   else
+   {
+      return -EFAULT;
+   }
+
+   return 0;
+}
+
+int QMIQOSEventResp(
+   sGobiUSBNet *    pDev,
+   void *   pBuffer,
+   u16      buffSize)
+{
+   int result;
+
+   // Ignore QMUX and SDU
+   u8 offset = sizeof( sQMUX ) + 3;
+
+   if (pBuffer == 0
+   || buffSize < offset)
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   if (result == QOS_NET_SUPPORT)
+   {
+      u16 tlv_rtn;
+      u8 supported = (u8)-1;
+      tlv_rtn = GetTLV( pBuffer, buffSize, 0x01, (void*)&supported, 1 );
+      QDBG(" %d\n", tlv_rtn);
+
+      if (supported != (u8)-1)
+      {
+          QDBG("supported %d", supported);
+      }
+   }
+   else if (result == QOS_STATUS)
+   {
+      int j;
+      sQosFlow flow;
+      u16 tlv_rtn;
+
+      tlv_rtn = GetTLV( pBuffer, buffSize, 0x01, (void*)&flow, 6 );
+      put_unaligned( le32_to_cpu(flow.id), &flow.id);
+      QDBG("tlv_rtn %d\n", tlv_rtn);
+      QDBG("flow.id 0x%x\n", flow.id);
+      QDBG("flow.status 0x%x\n", flow.status);
+      QDBG("flow.event 0x%x\n", flow.event);
+
+      for(j=0;j<MAX_MAP;j++)
+      {
+          //TODO this only update flow status when mapped
+          //share we always update even when user has not assign a map for this qos id
+          if (pDev->maps.table[j].qosId== flow.id)
+          {
+              pDev->maps.table[j].state = flow.status;
+          }
+      }
+
+   }
+   else
+   {
+      QDBG("unhandled indication 0x%x\n", result);
+      return -EFAULT;
+   }
+
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   QMIDMSGetMEIDResp (Public Method)
+
+DESCRIPTION:
+   Parse the QMI DMS Get Serial Numbers Resp
+
+PARAMETERS
+   pBuffer         [ I ] - Buffer to be parsed
+   buffSize        [ I ] - Size of pBuffer
+   pMEID           [ O ] - Device MEID
+   meidSize        [ I ] - Size of MEID buffer (at least 14)
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int QMIDMSGetMEIDResp(
+   void *   pBuffer,
+   u16      buffSize,
+   char *   pMEID,
+   int      meidSize )
+{
+   int result;
+
+   // Ignore QMUX and SDU
+   u8 offset = sizeof( sQMUX ) + 3;
+
+   if (pBuffer == 0 || buffSize < offset || meidSize < 14)
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   if (result != 0x25)
+   {
+      return -EFAULT;
+   }
+
+   result = ValidQMIMessage( pBuffer, buffSize );
+   if (result != 0)
+   {
+      return -EFAULT;
+   }
+
+   result = GetTLV( pBuffer, buffSize, 0x12, (void*)pMEID, 14 );
+   if (result != 14)
+   {
+      return -EFAULT;
+   }
+
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDASetDataFormatResp (Public Method)
+
+DESCRIPTION:
+   Parse the QMI WDA Set Data Format Response
+
+PARAMETERS
+   pBuffer         [ I ] - Buffer to be parsed
+   buffSize        [ I ] - Size of pBuffer
+   iDataMode       [ I ] - Data Mode
+   ULDatagram      [ I ] - Downlink Data Aggregation Max Datagrams
+   ULDatagramSize  [ I ] - Downlink Data Aggregation Max Size
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int QMIWDASetDataFormatResp(
+   void *   pBuffer,
+   u16      buffSize,
+   int      iDataMode,
+   u32 *    ULDatagram,
+   u32 *    ULDatagramSize)
+{
+
+   int result;
+   u32 u32DlminPadding = (u32)-1;
+   u8 pktLinkProtocol[4];
+
+   // Ignore QMUX and SDU
+   // QMI SDU is 3 bytes
+   u8 offset = sizeof( sQMUX ) + 3;
+
+   if (pBuffer == 0 || buffSize < offset)
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   if (result != 0x20)
+   {
+      return -EFAULT;
+   }
+
+   /* Check response message result TLV */
+   result = ValidQMIMessage( pBuffer, buffSize );
+   if (result != 0)
+   {
+      DBG("EFAULT: Data Format Mode Bad Response\n"); 
+//      return -EFAULT;
+      return 0;
+   }
+
+   if(ULDatagram!=NULL)
+   {
+      result = GetTLV( pBuffer, buffSize, 0x15, (void*)ULDatagram, 4 );
+      if (result != 4)
+      {
+         printk(KERN_WARNING"FAIL: ULDatagram\n");
+      }
+      else
+      {
+         put_unaligned( le32_to_cpu(*ULDatagram), ULDatagram);
+         if(*ULDatagram>QMAP_SIZE_OF_RX_BUFFER)
+         {
+            printk(KERN_WARNING"WARN: ULDatagram:%u\n",*ULDatagram); 
+         }
+      }
+   }
+   if(ULDatagramSize!=NULL)
+   {
+      result = GetTLV( pBuffer, buffSize, 0x16, (void*)ULDatagramSize, 4 );
+      if (result != 4)
+      {
+         printk(KERN_WARNING"FAIL: ULDatagramSize\n"); 
+      }
+      else
+      {
+         put_unaligned( le32_to_cpu(*ULDatagramSize), ULDatagramSize);
+         if(*ULDatagramSize>QMAP_SIZE_OF_RX_BUFFER)
+         {
+            printk(KERN_WARNING"WARN: ULDatagramSize:%u\n",*ULDatagramSize); 
+         }
+      }
+   }
+   /* Check response message link protocol */
+   result = GetTLV( pBuffer, buffSize, 0x11,
+                     &pktLinkProtocol[0], 4);
+   if (result != 4)
+   {
+      DBG("EFAULT: Wrong TLV format\n"); 
+      return 0;
+      
+   }
+
+   result = GetTLV( pBuffer, buffSize, 0x1A,
+                        &u32DlminPadding, 4);
+   if (result == 4)
+   {
+      DBG("u32DlminPadding :%u\n",u32DlminPadding);
+   }
+
+   if(iDataMode==eDataMode_RAWIP)
+   {
+      if (pktLinkProtocol[0] != 2)
+      {
+         DBG("EFAULT: Data Format Cannot be set to RawIP Mode\n"); 
+         return -EFAULT;
+      }
+      DBG("Data Format Set to RawIP\n");
+   }
+   else
+   {
+      if (pktLinkProtocol[0] != 1)
+      {
+         DBG("EFAULT: Data Format Cannot be set to Ethernet Mode\n"); 
+         return -EFAULT;
+      }
+      DBG("Data Format Set to Ethernet Mode \n");
+   }
+
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLSetDataFormatResp (Public Method)
+
+DESCRIPTION:
+   Parse the QMI CTL Set Data Format Response
+
+PARAMETERS
+   pBuffer         [ I ] - Buffer to be parsed
+   buffSize        [ I ] - Size of pBuffer
+   iDataMode       [ I ] - Data Mode
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int QMICTLSetDataFormatResp(
+   void *   pBuffer,
+   u16      buffSize,
+   int      iDataMode)
+{
+
+   int result;
+
+   u8 pktLinkProtocol[2];
+
+   // Ignore QMUX and SDU
+   //    QMI CTL SDU is 2 bytes, not 3
+   u8 offset = sizeof( sQMUX ) + 2;
+
+   if (pBuffer == 0 || buffSize < offset)
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   if (result != 0x26)
+   {
+      return -EFAULT;
+   }
+
+   /* Check response message result TLV */
+   result = ValidQMIMessage( pBuffer, buffSize );
+   if (result != 0)
+   {
+      DBG("EFAULT: Data Format Mode Bad Response\n"); 
+      return -EFAULT;
+   }
+
+   /* Check response message link protocol */
+   result = GetTLV( pBuffer, buffSize, TLV_TYPE_LINK_PROTO,
+                     &pktLinkProtocol[0], 2);
+   if (result != 2)
+   {
+      DBG("EFAULT: Wrong TLV format\n"); 
+      return -EFAULT;
+   }
+
+   if(iDataMode==eDataMode_RAWIP)
+   {
+      if (pktLinkProtocol[0] != 2)
+      {
+         DBG("EFAULT: Data Format Cannot be set to RawIP Mode\n"); 
+         return -EFAULT;
+      }
+      DBG("Data Format Set to RawIP\n");
+   }
+   else
+   {
+      if (pktLinkProtocol[0] != 1)
+      {
+         DBG("EFAULT: Data Format Cannot be set to Ethernet Mode\n"); 
+         return -EFAULT;
+      }
+      DBG("Data Format Set to Ethernet Mode \n");
+   }
+
+   return 0;
+}
+
+
+/*===========================================================================
+METHOD:
+   QMICTLSyncResp (Public Method)
+
+DESCRIPTION:
+   Validate the QMI CTL Sync Response
+
+PARAMETERS
+   pBuffer         [ I ] - Buffer to be parsed
+   buffSize        [ I ] - Size of pBuffer
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int QMICTLSyncResp(
+   void *pBuffer,
+   u16  buffSize )
+{
+   int result;
+
+   // Ignore QMUX (2 bytes for QMI CTL) and SDU
+   u8 offset = sizeof( sQMUX ) + 2;
+
+   if (pBuffer == 0 || buffSize < offset)
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   if (result != 0x27)
+   {
+      return -EFAULT;
+   }
+
+   result = ValidQMIMessage( pBuffer, buffSize );
+
+   return result;
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLGetVersionInfoResp (Public Method)
+
+DESCRIPTION:
+   Validate the QMI CTL Version Info Response
+
+PARAMETERS
+   pBuffer         [ I ] - Buffer to be parsed
+   buffSize        [ I ] - Size of pBuffer
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int QMICTLGetVersionInfoResp(
+   void *pBuffer,
+   u16   buffSize,
+   u8 *  pSvcVersion,
+   int   versionInfoSize )
+{
+   int result;
+
+   // Ignore QMUX (2 bytes for QMI CTL) and SDU
+   u8 offset = sizeof( sQMUX ) + 2;
+
+   if (pBuffer == 0 || buffSize < offset)
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   if (result != 0x21)
+   {
+      return -EFAULT;
+   }
+
+   result = ValidQMIMessage( pBuffer, buffSize );
+   if (result != 0)
+   {
+      DBG("EFAULT: Get Version Info Bad Response\n"); 
+      return -EFAULT;
+   }
+
+   result = GetTLV( pBuffer, buffSize, 0x01, (void*)pSvcVersion, versionInfoSize );
+   if (result < 0)
+   {
+      return result;
+   }
+   return 0;
+}
+
+
+/*===========================================================================
+METHOD:
+   QMICTLSetPowerSaveModeReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMICTLSetPowerSaveModeReq
+
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMICTLSetPowerSaveModeReqSize( void )
+{
+   return sizeof( sQMUX ) + 13; 
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLSetPowerSaveModeReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI CTL Set Power Save Mode Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMICTLSetPowerSaveModeReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID,
+   u8       mode)
+{
+   if (pBuffer == 0 || buffSize < QMICTLSetPowerSaveModeReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   /* QMI CTL Set Power Save Mode Request */
+   /* Request */
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00; // QMICTL_FLAG_REQUEST
+   
+   /* Transaction ID 1 byte */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 1) = transactionID; /* 1 byte as in spec */
+
+   /* Message ID  2 bytes */
+   put_unaligned( cpu_to_le16(0x002A), (u16 *)(pBuffer + sizeof( sQMUX ) + 2));
+
+   /* Length  2 bytes  of 1 TLV = 7 bytes */
+   put_unaligned( cpu_to_le16(0x0007), (u16 *)(pBuffer + sizeof( sQMUX ) + 4));
+    
+   /* TLVType Power save state 1 byte  */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) +  6) = 0x01;
+
+   /* TLVLength  2 bytes - see spec */
+   put_unaligned( cpu_to_le16(0x0004), (u16 *)(pBuffer + sizeof( sQMUX ) + 7)); 
+
+   /* pwrsave_state  4 byptes */
+   //*(u8 *)(pBuffer + sizeof( sQMUX ) + 9) = mode; 
+   
+   /* pwrsave_state  4 byptes */
+   put_unaligned( cpu_to_le32(mode), (u32 *)(pBuffer + sizeof( sQMUX ) + 9) );
+
+   /* success */
+   return sizeof( sQMUX ) + 13;
+
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLSetPowerSaveModeResp (Public Method)
+
+DESCRIPTION:
+   Parse the QMI CTL Set Power Save Mode Response
+
+PARAMETERS
+   pBuffer         [ I ] - Buffer to be parsed
+   buffSize        [ I ] - Size of pBuffer
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int QMICTLSetPowerSaveModeResp(
+   void *   pBuffer,
+   u16      buffSize )
+{
+   int result;
+   
+   // Ignore QMUX and SDU
+   //    QMI CTL SDU is 2 bytes, not 3
+   u8 offset = sizeof( sQMUX ) + 2;
+
+   if (pBuffer == 0 || buffSize < offset)
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   if (result != 0x2A)
+   {
+      return -EFAULT;
+   }
+
+   /* Check response message result TLV */
+   result = ValidQMIMessage( pBuffer, buffSize );
+   if (result != 0)
+   {
+      DBG("EFAULT: Set Power Save Mode Bad Response\n"); 
+      return -EFAULT;
+   }
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLConfigPowerSaveSettingsReqSize (Public Method)
+
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMICTLConfigPowerSaveSettingsReq
+
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMICTLConfigPowerSaveSettingsReqSize( void )
+{
+   return sizeof( sQMUX ) + 19; 
+}
+
+
+/*===========================================================================
+METHOD:
+   QMICTLConfigPowerSaveSettingsReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI CTL Config Power Save Settings Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMICTLConfigPowerSaveSettingsReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID,
+   u8       service,
+   u8       indication)
+{
+   if (pBuffer == 0 || buffSize < QMICTLConfigPowerSaveSettingsReqSize() )
+   {
+      return -ENOMEM;
+   }
+
+   /* QMI CTL Set Power Save Mode Request */
+   /* Request */
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0x00; // QMICTL_FLAG_REQUEST
+   
+   /* Transaction ID 1 byte */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 1) = transactionID; /* 1 byte as in spec */
+
+   /* Message ID  2 bytes */
+   put_unaligned( cpu_to_le16(0x0029), (u16 *)(pBuffer + sizeof( sQMUX ) + 2));
+
+   /* Length  2 bytes  of 2 TLVs = 13 bytes */
+   put_unaligned( cpu_to_le16(0x000D), (u16 *)(pBuffer + sizeof( sQMUX ) + 4));
+    
+   /* TLVType Power save state 1 byte  */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) +  6) = 0x01;
+
+   /* TLVLength  2 bytes - see spec */
+   put_unaligned( cpu_to_le16(0x0005), (u16 *)(pBuffer + sizeof( sQMUX ) + 7)); 
+
+   /* pwrsave_state  4 byptes */
+   put_unaligned( cpu_to_le32(0x00000001), (u32 *)(pBuffer + sizeof( sQMUX ) + 9) );
+   
+   /* qmi_service 1 byptes */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) +  13) = service;
+   
+   /* TLVType Permitted Indication set 1 byte  */
+   *(u8 *)(pBuffer + sizeof( sQMUX ) +  14) = 0x11;
+   
+   /* TLVLength  2 bytes*/
+   put_unaligned( cpu_to_le16(0x0002), (u16 *)(pBuffer + sizeof( sQMUX ) + 15)); 
+
+   /* indication_set 2 bytes*/
+   put_unaligned( cpu_to_le16(indication), (u16 *)(pBuffer + sizeof( sQMUX ) + 17)); 
+
+   /* success */
+   return sizeof( sQMUX ) + 19;
+
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLConfigPowerSaveSettingsResp (Public Method)
+
+DESCRIPTION:
+   Parse the QMI CTL Config Power Save Settings Request
+
+PARAMETERS
+   pBuffer         [ I ] - Buffer to be parsed
+   buffSize        [ I ] - Size of pBuffer
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int QMICTLConfigPowerSaveSettingsResp(
+   void *   pBuffer,
+   u16      buffSize )
+{
+   int result;
+   
+   // Ignore QMUX and SDU
+   //    QMI CTL SDU is 2 bytes, not 3
+   u8 offset = sizeof( sQMUX ) + 2;
+
+   if (pBuffer == 0 || buffSize < offset)
+   {
+      return -ENOMEM;
+   }
+
+   pBuffer = pBuffer + offset;
+   buffSize -= offset;
+
+   result = GetQMIMessageID( pBuffer, buffSize );
+   if (result != 0x29)
+   {
+      return -EFAULT;
+   }
+
+   /* Check response message result TLV */
+   result = ValidQMIMessage( pBuffer, buffSize );
+   if (result != 0)
+   {
+      DBG("EFAULT: Config Power Save Settings Request\n"); 
+      return -EFAULT;
+   }
+   return 0;
+}
+
+/*===========================================================================
+DESCRIPTION:
+   Get size of buffer needed for QMUX + QMIWDASetDataFormatReqSettings
+
+RETURN VALUE:
+   u16 - size of buffer
+===========================================================================*/
+u16 QMIWDASetDataFormatReqSettingsSize( void )
+{
+   return sizeof( sQMUX ) + 11;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDASetDataFormatReqSettingsReq (Public Method)
+
+DESCRIPTION:
+   Fill buffer with QMI Set QMAP Settings Request
+
+PARAMETERS
+   pBuffer         [ 0 ] - Buffer to be filled
+   buffSize        [ I ] - Size of pBuffer
+   transactionID   [ I ] - Transaction ID
+
+RETURN VALUE:
+   int - Positive for resulting size of pBuffer
+         Negative errno for error
+===========================================================================*/
+int QMIWDASetDataFormatReqSettingsReq(
+      void *   pBuffer,
+      u16      buffSize,
+      u16      transactionID )
+{
+   if (pBuffer == 0 || buffSize < QMIWDASetDataFormatReqSettingsSize() )
+   {
+      return -ENOMEM;
+   }
+
+   // QMI WDA SET DATA FORMAT REQ
+   // Request
+   *(u8 *)(pBuffer + sizeof( sQMUX ))  = 0;
+   // Transaction ID
+   *(u16 *)(pBuffer + sizeof( sQMUX ) + 1) = cpu_to_le16(transactionID);
+   // Message ID
+   *(u16 *)(pBuffer + sizeof( sQMUX ) + 3) = cpu_to_le16(0x2B);
+   // Size of TLV's
+   *(u16 *)(pBuffer + sizeof( sQMUX ) + 5) = cpu_to_le16(4);
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 7)  = 0x10;
+   *(u16 *)(pBuffer + sizeof( sQMUX ) + 8) = cpu_to_le16(1);
+   *(u8 *)(pBuffer + sizeof( sQMUX ) + 10)  = 1;
+
+   // success
+   return sizeof( sQMUX ) + 11;
+}
+
+
+void PrintIPV6Addr(ipv6_addr * addr)
+{   
+   if(debug & DEBUG_NETMASK)
+   {
+      char str[40];
+      snprintf(str,40,"%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x",
+      (int)addr->ipv6addr[0], (int)addr->ipv6addr[1],
+      (int)addr->ipv6addr[2], (int)addr->ipv6addr[3],
+      (int)addr->ipv6addr[4], (int)addr->ipv6addr[5],
+      (int)addr->ipv6addr[6], (int)addr->ipv6addr[7],
+      (int)addr->ipv6addr[8], (int)addr->ipv6addr[9],
+      (int)addr->ipv6addr[10], (int)addr->ipv6addr[11],
+      (int)addr->ipv6addr[12], (int)addr->ipv6addr[13],
+      (int)addr->ipv6addr[14], (int)addr->ipv6addr[15]);
+      NETDBG("IPv6 Addr:%s\n",str);
+      return ;
+   }
+}
+
diff --git a/drivers/net/usb/QMI.h b/drivers/net/usb/QMI.h
new file mode 100644
index 00000000..2f46a4c0
--- /dev/null
+++ b/drivers/net/usb/QMI.h
@@ -0,0 +1,518 @@
+/*===========================================================================
+FILE:
+   QMI.h
+
+DESCRIPTION:
+   Qualcomm QMI driver header
+   
+FUNCTIONS:
+   Generic QMUX functions
+      ParseQMUX
+      FillQMUX
+   
+   Generic QMI functions
+      GetTLV
+      ValidQMIMessage
+      GetQMIMessageID
+
+   Get sizes of buffers needed by QMI requests
+      QMUXHeaderSize
+      QMICTLGetClientIDReqSize
+      QMICTLReleaseClientIDReqSize
+      QMICTLReadyReqSize
+      QMIWDSSetEventReportReqSize
+      QMIWDSGetPKGSRVCStatusReqSize
+      QMIDMSGetMEIDReqSize
+      QMICTLSyncReqSize
+      QMICTLGetVersionInfoReqSize
+
+   Fill Buffers with QMI requests
+      QMICTLGetClientIDReq
+      QMICTLReleaseClientIDReq
+      QMICTLReadyReq
+      QMIWDSSetEventReportReq
+      QMIWDSGetPKGSRVCStatusReq
+      QMIDMSGetMEIDReq
+      QMICTLSetDataFormatReq
+      QMICTLSyncReq
+      QMICTLGetVersionInfoReq
+
+   Parse data from QMI responses
+      QMICTLGetClientIDResp
+      QMICTLReleaseClientIDResp
+      QMIWDSEventResp
+      QMIDMSGetMEIDResp
+      QMICTLSetDataFormatResp
+      QMICTLGetVersionInfoResp
+
+Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Code Aurora Forum nor
+      the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+Alternatively, provided that this notice is retained in full, this software
+may be relicensed by the recipient under the terms of the GNU General Public
+License version 2 ("GPL") and only version 2, in which case the provisions of
+the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
+software under the GPL, then the identification text in the MODULE_LICENSE
+macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
+recipient changes the license terms to the GPL, subsequent recipients shall
+not relicense under alternate licensing terms, including the BSD or dual
+BSD/GPL terms.  In addition, the following license statement immediately
+below and between the words START and END shall also then apply when this
+software is relicensed under the GPL:
+
+START
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License version 2 and only version 2 as
+published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+END
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+#pragma once
+
+/*=========================================================================*/
+// Definitions
+/*=========================================================================*/
+#define DEBUG_QMI         1
+#define DEBUG_NETMASK     DEBUG_QMI << 1
+
+extern int netdebug;
+extern int debug;
+extern int qos_debug;
+
+// DBG macro
+#define DBG( format, arg... )\
+if(debug & DEBUG_QMI)\
+{\
+      printk( KERN_INFO "GobiNet::%s(%d) " format, __FUNCTION__,task_pid_nr(current), ## arg );\
+}
+
+//QMAP DBG macro
+#define NETDBG( format, arg... )\
+if(debug & DEBUG_NETMASK)\
+{\
+      printk( KERN_INFO "GobiNet::%s(%d) " format, __FUNCTION__,task_pid_nr(current), ## arg );\
+}
+
+#define QDBG( format, arg... )\
+if(qos_debug == 1)\
+{\
+   printk( KERN_INFO "GobiNet[QoS]::%s " format, __FUNCTION__, ## arg );\
+}
+
+/* The following definition is disabled (commented out) by default.
+ * When uncommented it enables raw IP data format mode of operation */
+/*#define DATA_MODE_RP*/
+
+#ifdef QOS_MODE
+#ifdef DATA_MODE_RP
+#error "defining both QOS_MODE & DATA_MODE_RP is not supported"
+#endif
+#endif
+
+// QMI Service Types
+#define QMICTL 0
+#define QMIWDS 1
+#define QMIDMS 2
+#define QMIQOS 4
+#define QMIWDA 0x1A
+#define QMINAS   3
+#define QMIWMS   5
+#define QMIVOICE 9
+
+#define QMI_WMS_EVENT_REPORT_IND        0x01
+#define QMI_NAS_SERVING_SYSTEM_IND      0x24
+#define QMI_VOICE_ALL_CALL_STATUS_IND   0x2E
+#define QMI_WDS_GET_PKT_SRVC_STATUS_IND 0x22
+
+#define u8        unsigned char
+#define u16       unsigned short
+#define u32       unsigned int
+#define u64       unsigned long long
+
+#define bool      u8
+#define true      1
+#define false     0
+
+#define ENOMEM    12
+#define EFAULT    14
+#define EINVAL    22
+// #define ENOMSG    42
+#define ENODATA   61
+
+#define TLV_TYPE_LINK_PROTO 0x10
+
+#define QOS_STATUS (0x26)
+#define QOS_NET_SUPPORT (0x27)
+
+// throttle rx/tx briefly after some faults, so khubd might disconnect()
+// us (it polls at HZ/4 usually) before we report too many false errors.
+#define THROTTLE_JIFFIES   (HZ/8)
+#define RX_MAX_QUEUE_MEMORY (60 * 1518)
+#define TX_QLEN(dev) (((dev)->udev->speed == USB_SPEED_HIGH) ? \
+        (RX_MAX_QUEUE_MEMORY/(dev)->hard_mtu) : 4)
+
+#define SET_CONTROL_LINE_STATE_REQUEST_TYPE \
+       (USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE)
+#define SET_CONTROL_LINE_STATE_REQUEST             0x22
+#define CONTROL_DTR                     0x01
+#define CONTROL_RTS                     0x02
+
+#define MAX_TASK_ID 16
+
+#define QMUX_HEADER_LENGTH 4
+
+#define QMAP_SIZE_OF_RX_BUFFER 32768
+
+#define QMAP_MAX_PADDING_BYTES 64
+//Register State
+enum {
+   eStatRegister=0,
+   eStatUnloading,
+   eStatUnloaded
+};
+
+/* The following definition is disabled (commented out) by default.
+ * When uncommented it enables a feature that provides 'feedback' to an 
+ * application about allocated and freed resources on transmit path  provided
+ * CONFIG_PM is enabled in the kernel*/
+/*#define TX_URB_MONITOR*/
+
+/*=========================================================================*/
+// Struct sQMUX
+//
+//    Structure that defines a QMUX header
+/*=========================================================================*/
+typedef struct sQMUX
+{
+   /* T\F, always 1 */
+   u8         mTF;
+
+   /* Size of message */
+   u16        mLength;
+
+   /* Control flag */
+   u8         mCtrlFlag;
+   
+   /* Service Type */
+   u8         mQMIService;
+   
+   /* Client ID */
+   u8         mQMIClientID;
+
+}__attribute__((__packed__)) sQMUX;
+
+typedef struct
+{
+   u32  id;
+   u8   status;
+   u8   event;
+}__attribute__((__packed__)) sQosFlow;
+
+/*=========================================================================*/
+// Generic QMUX functions
+/*=========================================================================*/
+
+// Remove QMUX headers from a buffer
+int ParseQMUX(
+   u16 *    pClientID,
+   void *   pBuffer,
+   u16      buffSize );
+
+// Fill buffer with QMUX headers
+int FillQMUX(
+   u16      clientID,
+   void *   pBuffer,
+   u16      buffSize );
+
+/*=========================================================================*/
+// Generic QMI functions
+/*=========================================================================*/
+
+// Get data buffer of a specified TLV from a QMI message
+u16 GetTLV(
+   void *   pQMIMessage,
+   u16      messageLen,
+   u8       type,
+   void *   pOutDataBuf,
+   u16      bufferLen );
+
+// Check mandatory TLV in a QMI message
+int ValidQMIMessage(
+   void *   pQMIMessage,
+   u16      messageLen );
+
+// Get the message ID of a QMI message
+int GetQMIMessageID(
+   void *   pQMIMessage,
+   u16      messageLen );
+
+/*=========================================================================*/
+// Get sizes of buffers needed by QMI requests
+/*=========================================================================*/
+
+// Get size of buffer needed for QMUX
+u16 QMUXHeaderSize( void );
+
+// Get size of buffer needed for QMUX + QMICTLGetClientIDReq
+u16 QMICTLGetClientIDReqSize( void );
+
+// Get size of buffer needed for QMUX + QMICTLReleaseClientIDReq
+u16 QMICTLReleaseClientIDReqSize( void );
+
+// Get size of buffer needed for QMUX + QMICTLReadyReq
+u16 QMICTLReadyReqSize( void );
+
+// Get size of buffer needed for QMUX + QMIWDSSetEventReportReq
+u16 QMIWDSSetEventReportReqSize( void );
+
+// Get size of buffer needed for QMUX + QMIWDSGetPKGSRVCStatusReq
+u16 QMIWDSGetPKGSRVCStatusReqSize( void );
+
+// Get size of buffer needed for QMUX + QMIDMSGetMEIDReq
+u16 QMIDMSGetMEIDReqSize( void );
+
+// Get size of buffer needed for QMUX + QMIDMSSWISetFCCAuthReq
+u16 QMIDMSSWISetFCCAuthReqSize( void );
+
+// Get size of buffer needed for QMUX + QMIWDASetDataFormatReq
+u16 QMIWDASetDataFormatReqSize( int te_flow_control ,int qmuxmode);
+
+// Get size of buffer needed for QMUX + QMICTLSetDataFormatReq
+u16  QMICTLSetDataFormatReqSize( void );
+
+// Get size of buffer needed for QMUX + QMICTLSyncReq
+u16 QMICTLSyncReqSize( void );
+
+// Get size of buffer needed for QMUX + QMICTLGetVersionInfo
+u16 QMICTLGetVersionInfoReqSize( void );
+
+/*=========================================================================*/
+// Fill Buffers with QMI requests
+/*=========================================================================*/
+
+// Fill buffer with QMI CTL Get Client ID Request
+int QMICTLGetClientIDReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID,
+   u8       serviceType );
+
+// Fill buffer with QMI CTL Release Client ID Request
+int QMICTLReleaseClientIDReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID,
+   u16      clientID );
+
+// Fill buffer with QMI CTL Get Version Info Request
+int QMICTLReadyReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID );
+
+// Fill buffer with QMI WDS Set Event Report Request
+int QMIWDSSetEventReportReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID );
+
+// Fill buffer with QMI WDS Get PKG SRVC Status Request
+int QMIWDSGetPKGSRVCStatusReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID );
+
+// Fill buffer with QMI DMS Get Serial Numbers Request
+int QMIDMSGetMEIDReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID );
+
+// Fill buffer with QMI DMS Set FCC Authentication Request
+int QMIDMSSWISetFCCAuthReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID );
+
+// Fill buffer with QMI WDA Set Data Format Request
+int QMIWDASetDataFormatReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u16      transactionID,
+   int     te_flow_control,
+   int      iDataMode,
+   unsigned mIntfNum,
+   int      iqmuxenable);
+
+// Fill buffer with QMI CTL Set Data Format Request
+int QMICTLSetDataFormatReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID ,
+   int      iDataMode);
+
+int QMICTLSyncReq(
+   void *pBuffer,
+   u16  buffSize,
+   u16  transactionID );
+
+// Fill buffer with QMI CTL Get version Info Request
+int QMICTLGetVersionInfoReq(
+   void *pBuffer,
+   u16  buffSize,
+   u16  transactionID );
+
+/*=========================================================================*/
+// Parse data from QMI responses
+/*=========================================================================*/
+
+// Parse the QMI CTL Get Client ID Resp
+int QMICTLGetClientIDResp(
+   void * pBuffer,
+   u16    buffSize,
+   u16 *  pClientID );
+
+// Verify the QMI CTL Release Client ID Resp is valid
+int QMICTLReleaseClientIDResp(
+   void *   pBuffer,
+   u16      buffSize );
+
+// Parse the QMI WDS Set Event Report Resp/Indication or
+//    QMI WDS Get PKG SRVC Status Resp/Indication
+int QMIWDSEventResp(
+   void *   pBuffer,
+   u16      buffSize,
+   u32 *    pTXOk,
+   u32 *    pRXOk,
+   u32 *    pTXErr,
+   u32 *    pRXErr,
+   u32 *    pTXOfl,
+   u32 *    pRXOfl,
+   u64 *    pTXBytesOk,
+   u64 *    pRXBytesOk,
+   bool *   pbLinkState,
+   bool *   pbReconfigure );
+
+int QMIQOSEventResp(
+   sGobiUSBNet *    pDev,
+   void *   pBuffer,
+   u16      buffSize);
+
+// Parse the QMI DMS Get Serial Numbers Resp
+int QMIDMSGetMEIDResp(
+   void *   pBuffer,
+   u16      buffSize,
+   char *   pMEID,
+   int      meidSize );
+
+// Parse the QMI DMS Get Serial Numbers Resp
+int QMIWDASetDataFormatResp(
+   void *   pBuffer,
+   u16      buffSize,
+   int      iDataMode,
+   u32 *    ULDatagram,
+   u32 *    ULDatagramSize);
+
+// Parse the QMI Set Data Format Resp
+int QMICTLSetDataFormatResp(
+   void *   pBuffer,
+   u16      buffSize,
+   int      iDataMode);
+
+// Pasre the QMI CTL Sync Response
+int QMICTLSyncResp(
+   void *pBuffer,
+   u16  buffSize );
+
+// Parse the QMI CTL Version Info Response
+int QMICTLGetVersionInfoResp(
+   void *pBuffer,
+   u16   buffSize,
+   u8 *  pSvcVersion,
+   int   versionInfoSize );
+
+// Get size of buffer needed for QMUX + QMICTLSetPowerSaveModeReq
+u16  QMICTLSetPowerSaveModeReqSize( void );
+
+// Fill buffer with QMI CTL Set Power Save Mode Request
+int QMICTLSetPowerSaveModeReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID,
+   u8       mode);
+
+// Parse the QMI Set Power Save Mode Resp   
+int QMICTLSetPowerSaveModeResp(
+   void *   pBuffer,
+   u16      buffSize );
+
+int QMICTLConfigPowerSaveSettingsReq(
+   void *   pBuffer,
+   u16      buffSize,
+   u8       transactionID,
+   u8       service,
+   u8       indication);
+
+// Get size of buffer needed for QMUX + QMICTLPowerSaveSettingsReq
+u16 QMICTLConfigPowerSaveSettingsReqSize( void );
+
+// Parse the QMI Config Power Save Settings Resp      
+int QMICTLConfigPowerSaveSettingsResp(
+   void *   pBuffer,
+   u16      buffSize );
+
+// Get size of buffer needed for QMUX + QMIWDASetDataFormatReqSettingsReq
+u16 QMIWDASetDataFormatReqSettingsSize( void );
+
+int QMIWDASetDataFormatReqSettingsReq(
+      void *   pBuffer,
+      u16      buffSize,
+      u16      transactionID );
+
+void PrintIPAddr(char *msg, unsigned int addr);
+
+enum{
+   eSKIP_TE_FLOW_CONTROL_TLV=-1,
+   eTE_FLOW_CONTROL_TLV_0=0,
+   eTE_FLOW_CONTROL_TLV_1=1,
+};
+
+#define GOBI_GFP_ATOMIC     GFP_ATOMIC|GFP_NOWAIT
+#define GOBI_GFP_KERNEL     GFP_KERNEL|GFP_NOWAIT
+
+void PrintIPV6Addr(ipv6_addr * addr);
+int iIsZeroIPv6Addr(ipv6_addr *pAddr);
diff --git a/drivers/net/usb/QMIDevice.c b/drivers/net/usb/QMIDevice.c
new file mode 100644
index 00000000..f3411550
--- /dev/null
+++ b/drivers/net/usb/QMIDevice.c
@@ -0,0 +1,9860 @@
+/*===========================================================================
+FILE:
+   QMIDevice.c
+
+DESCRIPTION:
+   Functions related to the QMI interface device
+
+FUNCTIONS:
+   Generic functions
+      IsDeviceValid
+      PrintHex
+      GobiSetDownReason
+      GobiClearDownReason
+      GobiTestDownReason
+
+   Driver level asynchronous read functions
+      ResubmitIntURB
+      ReadCallback
+      IntCallback
+      StartRead
+      KillRead
+
+   Internal read/write functions
+      ReadAsync
+      UpSem
+      ReadSync
+      WriteSync
+
+   Internal memory management functions
+      GetClientID
+      ReleaseClientID
+      FindClientMem
+      AddToReadMemList
+      PopFromReadMemList
+      AddToNotifyList
+      NotifyAndPopNotifyList
+
+   Internal userspace wrapper functions
+      UserspaceunlockedIOCTL
+
+   Userspace wrappers
+      UserspaceOpen
+      UserspaceIOCTL
+      UserspaceClose
+      UserspaceRead
+      UserspaceWrite
+      UserspacePoll
+
+   Initializer and destructor
+      RegisterQMIDevice
+      DeregisterQMIDevice
+
+   Driver level client management
+      QMIReady
+      QMIWDSCallback
+      SetupQMIWDSCallback
+      QMIDMSGetMEID
+
+Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Code Aurora Forum nor
+      the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+Alternatively, provided that this notice is retained in full, this software
+may be relicensed by the recipient under the terms of the GNU General Public
+License version 2 ("GPL") and only version 2, in which case the provisions of
+the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
+software under the GPL, then the identification text in the MODULE_LICENSE
+macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
+recipient changes the license terms to the GPL, subsequent recipients shall
+not relicense under alternate licensing terms, including the BSD or dual
+BSD/GPL terms.  In addition, the following license statement immediately
+below and between the words START and END shall also then apply when this
+software is relicensed under the GPL:
+
+START
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License version 2 and only version 2 as
+published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+END
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+#include <asm/unaligned.h>
+#include "QMIDevice.h"
+#include "Structs.h"
+#include <linux/module.h>
+#include <linux/proc_fs.h> // for the proc filesystem
+#include <linux/device.h>
+#include <linux/file.h>
+#include <linux/rtnetlink.h>
+#include <linux/netdevice.h>
+#include <net/sch_generic.h>
+#include <linux/if_arp.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 4,11,0 ))
+#include <linux/sched/signal.h>
+#endif
+
+#if (LINUX_VERSION_CODE == KERNEL_VERSION( 2,6,35 ))
+#warning "Fix compilation error 'include/linux/compat.h:233: error: in /usr/src/linux-headers-2.6.35-22-generic/include/linux/compat.h, line 233, the variable name of second parameter,  replace *u32 to *u"
+#endif
+#include <linux/usbdevice_fs.h>
+#ifdef CONFIG_PROVE_RCU
+#define _SIG_LOCK_ 1
+#else
+#define _SIG_LOCK_ 0
+#endif
+#include <linux/sched.h>
+#include <linux/dnotify.h>
+//-----------------------------------------------------------------------------
+// Definitions
+//-----------------------------------------------------------------------------
+
+extern int debug;
+extern int is9x15;
+extern int interruptible;
+extern int iTEEnable;
+extern void *gobi_skb_push(struct sk_buff *pSKB, unsigned int len);
+const bool clientmemdebug = 0;
+enum {
+ eNotifyListEmpty=-1,
+ eNotifyListNotFound=0,
+ eNotifyListFound=1,
+};
+
+#define SEND_ENCAPSULATED_COMMAND (0)
+#define GET_ENCAPSULATED_RESPONSE (1)
+#define USB_WRITE_TIMEOUT 500   // must be less than AM timeout
+#define USB_WRITE_RETRY (2)
+#define USB_READ_TIMEOUT (500)
+#define MAX_RETRY 5
+#define ENABLE_MAX_RETRY_LOCK_MSLEEP_TIME 10
+#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,33 ))
+#define raw_spin_is_locked(x) (&(x)->raw_lock == 0)
+#endif
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 4,15,0 ))
+#define gobi_setup_timer(timer, fn, data) setup_timer(timer, fn, data) 
+#else
+#define gobi_setup_timer(timer, fn, data) timer_setup(timer, fn, 0) 
+#endif
+
+/* initially all zero */
+int qcqmi_table[MAX_QCQMI];
+int qmux_table[MAX_QCQMI];
+
+//Store all work queues per device per interface
+sGobiPrivateWorkQueues GobiPrivateWorkQueues[MAX_QCQMI][MAX_QCQMI_PER_INTF];
+
+extern bool isModuleUnload(sGobiUSBNet *pDev);
+extern int iRAWIPEnable;
+extern int iQMUXEnable;
+static inline bool IsDeviceValid( sGobiUSBNet * pDev );
+static void gobiProcessReadURB(sGobiUSBNet *pGobiDev);
+static void ProcessReadWorkFunction(struct work_struct *w);
+int IsOtherTaskUsingFilp(struct file *pFilp);
+int IsOpenTaskIsCurrent(struct file *pFilp);
+int IsCurrentTaskExit(void);
+int ClientTransactionIDExist(sGobiUSBNet * pDev, u16 clientID,u16 u16TransactionID);
+
+int GenerateProcessName(const char *pPrefix,char *szProcessName,unsigned sizeofName,sGobiUSBNet *pGobiDev );
+int GetPrivateWorkQueuesInterfaceTableIndex(sGobiUSBNet *pGobiDev);
+int AddPrivateWorkQueues(sGobiUSBNet *pGobiDev);
+int GetPrivateWorkQueuesIndex(sGobiUSBNet *pGobiDev);
+int SetPrivateWorkQueuesWQByTableIndex(int i,int j,struct workqueue_struct *wq,int type);
+struct workqueue_struct *GetPrivateWorkQueuesWQByTableIndex(int i,int j,int type);
+int ClearPrivateWorkQueuesProcessByTableIndex(int i,int j);
+void GobiCancelReadCallBackWorkQueue(sGobiUSBNet *pGobiDev);
+void GobiCancelProbeWorkQueue(sGobiUSBNet *pGobiDev);
+bool TransceiveReleaseClientID(
+   sGobiUSBNet *    pDev,
+   u16                clientID);
+void GobiCancelDelayWorkWorkQueue(
+   sGobiUSBNet *pGobiDev,
+   struct workqueue_struct *wq, 
+   struct delayed_work *dw);
+
+#define CLIENT_READMEM_SNAPSHOT(clientID, pdev)\
+   if( (debug & DEBUG_QMI) && clientmemdebug )\
+   {\
+      sClientMemList *pclnt;\
+      sReadMemList *plist;\
+      pclnt = FindClientMem((pdev), (clientID));\
+      plist = pclnt->mpList;\
+      if( (pdev) != NULL){\
+          while(plist != NULL)\
+          {\
+             DBG(  "clientID 0x%x, mDataSize = %u, mpData = 0x%p, mTransactionID = %u,  \
+                    mpNext = 0x%p\n", (clientID), plist->mDataSize, plist->mpData, \
+                    plist->mTransactionID, plist->mpNext  ) \
+             /* advance to next entry */\
+             plist = plist->mpNext;\
+          }\
+      }\
+   }
+
+#ifdef CONFIG_PM
+// Prototype to GobiNetSuspend function
+int GobiNetSuspend(
+   struct usb_interface *     pIntf,
+   pm_message_t               powerEvent );
+#endif /* CONFIG_PM */
+
+int wakeup_inode_process(struct file *pFilp,struct task_struct * pTask);
+void gobi_try_wake_up_process(struct task_struct * pTask);
+int gobi_work_busy(struct delayed_work *dw);
+extern int GobiUSBLockReset( struct usb_interface *pIntf );
+extern int iIsRemoteWakeupSupport(struct usbnet *pDev);
+
+// IOCTL to generate a client ID for this service type
+#define IOCTL_QMI_GET_SERVICE_FILE 0x8BE0 + 1
+
+// IOCTL to get the VIDPID of the device
+#define IOCTL_QMI_GET_DEVICE_VIDPID 0x8BE0 + 2
+
+// IOCTL to get the MEID of the device
+#define IOCTL_QMI_GET_DEVICE_MEID 0x8BE0 + 3
+
+#define IOCTL_QMI_RELEASE_SERVICE_FILE_IOCTL  (0x8BE0 + 4)
+
+#define IOCTL_QMI_ADD_MAPPING 0x8BE0 + 5
+#define IOCTL_QMI_DEL_MAPPING 0x8BE0 + 6
+#define IOCTL_QMI_CLR_MAPPING 0x8BE0 + 7
+
+#define IOCTL_QMI_QOS_SIMULATE 0x8BE0 + 8
+#define IOCTL_QMI_GET_TX_Q_LEN 0x8BE0 + 9
+
+#define IOCTL_QMI_EDIT_MAPPING 0x8BE0 + 10
+#define IOCTL_QMI_READ_MAPPING 0x8BE0 + 11
+#define IOCTL_QMI_DUMP_MAPPING 0x8BE0 + 12
+#define IOCTL_QMI_GET_USBNET_STATS 0x8BE0 + 13
+#define IOCTL_QMI_SET_DEVICE_MTU 0x8BE0 + 14
+#define IOCTL_QMI_GET_QMAP_SUPPORT 0x8BE0 + 15
+#define IOCTL_QMI_SET_IP_ADDRESS   0x8BE0 + 16
+#define IOCTL_QMI_SET_IPV6_ADDRESS   0x8BE0 + 17
+#define IOCTL_QMI_GET_IPALIAS_MODE   0x8BE0 + 18
+#define IOCTL_QMI_GET_SVC_VERSION_INFO   0x8BE0 + 19
+
+// CDC GET_ENCAPSULATED_RESPONSE packet
+#define CDC_GET_ENCAPSULATED_RESPONSE_LE 0x01A1ll
+#define CDC_GET_ENCAPSULATED_RESPONSE_BE 0xA101000000000000ll
+/* The following masks filter the common part of the encapsulated response
+ * packet value for Gobi and QMI devices, ie. ignore usb interface number
+ */
+#define CDC_RSP_MASK_BE 0xFFFFFFFF00FFFFFFll
+#define CDC_RSP_MASK_LE 0xFFFFFFE0FFFFFFFFll
+
+#define _IGNORE_DISCONNECT_SPIN_LOCK_CHECK_ 1
+
+const int i = 1;
+#define is_bigendian() ( (*(char*)&i) == 0 )
+#define CDC_GET_ENCAPSULATED_RESPONSE(pcdcrsp, pmask)\
+{\
+   *pcdcrsp  = is_bigendian() ? CDC_GET_ENCAPSULATED_RESPONSE_BE \
+                          : CDC_GET_ENCAPSULATED_RESPONSE_LE ; \
+   *pmask = is_bigendian() ? CDC_RSP_MASK_BE \
+                           : CDC_RSP_MASK_LE; \
+}
+
+// CDC CONNECTION_SPEED_CHANGE indication packet
+#define CDC_CONNECTION_SPEED_CHANGE_LE 0x2AA1ll
+#define CDC_CONNECTION_SPEED_CHANGE_BE 0xA12A000000000000ll
+/* The following masks filter the common part of the connection speed change
+ * packet value for Gobi and QMI devices
+ */
+#define CDC_CONNSPD_MASK_BE 0xFFFFFFFFFFFF7FFFll
+#define CDC_CONNSPD_MASK_LE 0XFFF7FFFFFFFFFFFFll
+#define CDC_GET_CONNECTION_SPEED_CHANGE(pcdccscp, pmask)\
+{\
+   *pcdccscp  = is_bigendian() ? CDC_CONNECTION_SPEED_CHANGE_BE \
+                          : CDC_CONNECTION_SPEED_CHANGE_LE ; \
+   *pmask = is_bigendian() ? CDC_CONNSPD_MASK_BE \
+                           : CDC_CONNSPD_MASK_LE; \
+}
+
+#define SPIN_LOCK_DEBUG 0
+
+/*=========================================================================*/
+// QMAP netdev define
+/*=========================================================================*/
+#define ARPHRD_NONE     0xFFFE
+#ifndef netdev_tx_t
+#define netdev_tx_t int
+#endif
+
+#if (__GNUC__ > 7 && defined(_ASM_X86_ATOMIC_H))|| \
+    (__GNUC__ == 7 && defined(_ASM_X86_ATOMIC_H) && (__GNUC_MINOR__ > 0 || \
+                       (__GNUC_MINOR__ == 0 && \
+                        __GNUC_PATCHLEVEL__ > 0)))
+#define gobi_atomic_read(x) atomic_read((const atomic_t *)x)
+#else
+#define gobi_atomic_read(x) atomic_read((atomic_t *)x)
+#endif
+#define in_serving_hardirq() (hardirq_count() &  HARDIRQ_OFFSET)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,37 ))
+
+#define in_serving_softirq()	(softirq_count() & SOFTIRQ_OFFSET)
+#endif
+
+static int gobi_qmimux_open(struct net_device *dev)
+{
+   struct gobi_qmimux_priv *priv = netdev_priv(dev);
+   struct net_device *real_dev = priv->real_dev;
+   unsigned short oflags;
+   DBG("\n");
+   if (!(priv->real_dev->flags & (IFF_UP|IFF_RUNNING)))
+   {
+      printk("Adaptor Not Up\n");
+      oflags = dev->flags;
+      if (dev_change_flags(real_dev, oflags | IFF_UP | IFF_RUNNING) < 0) {
+          printk("IP-Config: Failed to open %s\n",
+          dev->name);
+      }
+      netif_carrier_on(real_dev);
+   }
+   
+   netif_carrier_on(real_dev);
+   netif_start_queue(real_dev);
+   netif_carrier_on(dev);
+   netif_start_queue(dev);
+   return 0;
+}
+
+static int gobi_qmimux_stop(struct net_device *dev)
+{
+   NETDBG("\n");
+   netif_carrier_off(dev);
+   return 0;
+}
+
+struct sk_buff *GobiNetDriverQmuxTxFixup(
+   struct sk_buff *pSKB,
+   gfp_t flags,
+   u8 mux_id)
+{
+
+   DBG( "\n" );
+   if (pSKB->len >= 4)
+   {
+
+      // Skip Ethernet header from message
+      NETDBG( "Before sending to device modified: Len:0x%x",pSKB->len);
+      NetHex (pSKB->data, pSKB->len);
+      return pSKB;
+   }
+   else
+   {
+      NETDBG( "Packet Dropped Length");
+   }
+
+   // Filter the packet out, release it
+   dev_kfree_skb_any(pSKB);
+   return NULL;
+}
+
+static netdev_tx_t gobi_qmimux_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+   struct gobi_qmimux_priv *priv = netdev_priv(dev);
+   unsigned int len = skb->len;
+   struct gobi_qmimux_hdr *hdr;
+
+   skb->dev = priv->real_dev;
+   if(dev->type == ARPHRD_ETHER)
+   {
+      NETDBG("Remove ETH Header\n");
+      NetHex (skb->data, skb->len);
+      skb_pull(skb,ETH_HLEN);
+      hdr = (struct gobi_qmimux_hdr *)gobi_skb_push(skb, sizeof(struct gobi_qmimux_hdr));
+      len = skb->len - sizeof(struct gobi_qmimux_hdr);
+   }
+   else
+   {
+      hdr = (struct gobi_qmimux_hdr *)gobi_skb_push(skb, sizeof(struct gobi_qmimux_hdr));
+   }
+   hdr->pad = 0;
+   hdr->mux_id = priv->mux_id;
+   hdr->pkt_len = cpu_to_be16(len);
+   skb->dev = priv->real_dev;
+   NETDBG("mux_id:0x%x\n",priv->mux_id);
+   if(iIsValidQmuxSKB(skb)==0)
+   {
+      NETDBG( "Invalid Packet\n" );
+      return NETDEV_TX_BUSY;
+   }
+   skb = GobiNetDriverQmuxTxFixup( skb, GFP_ATOMIC,priv->mux_id);
+   if (skb == NULL)
+   {
+      NETDBG( "unable to tx_fixup skb\n" );
+      return NETDEV_TX_BUSY;
+   }
+   dev->stats.tx_packets++;
+   dev->stats.tx_bytes += skb->len;
+   #if (LINUX_VERSION_CODE < KERNEL_VERSION( 4,7,0 ))
+   dev->trans_start = jiffies;
+   #else
+   netif_trans_update(dev);
+   #endif
+   return dev_queue_xmit(skb);
+}
+
+static const struct net_device_ops gobi_qmimux_netdev_ops = {
+   .ndo_open       = gobi_qmimux_open,
+   .ndo_stop       = gobi_qmimux_stop,
+   .ndo_start_xmit = gobi_qmimux_start_xmit,
+};
+
+/*=========================================================================*/
+
+
+/*=========================================================================*/
+// UserspaceQMIFops
+//    QMI device's userspace file operations
+/*=========================================================================*/
+static const struct file_operations UserspaceQMIFops =
+{
+   .owner     = THIS_MODULE,
+   .read      = UserspaceRead,
+   .write     = UserspaceWrite,
+#ifdef CONFIG_COMPAT
+   .compat_ioctl = UserspaceunlockedIOCTL,
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,36 ))
+   .unlocked_ioctl = UserspaceunlockedIOCTL,
+#else
+   .ioctl     = UserspaceIOCTL,
+#endif
+   .open      = UserspaceOpen,
+   .flush     = UserspaceClose,
+   .poll      = UserspacePoll,
+   .release   = UserspaceRelease,
+   .lock      = UserSpaceLock
+};
+
+void RemoveProcessFile(sGobiUSBNet * pDev);
+void RemoveCdev(sGobiUSBNet * pDev);
+void wakeup_target_process(struct task_struct * pTask);
+
+inline int wait_preempt(void)
+{
+   int count = 0;
+   while (preempt_count()>0)
+   {
+      msleep_interruptible(50);
+      if(count>10)
+      {
+         return 0;
+      }
+   }
+   return 1;
+}
+
+inline void wait_interrupt(void)
+{
+   int count = 0;
+   while(in_interrupt()||
+      in_softirq()|| //Soft IRQ
+      in_irq()|| //Hard IRQ
+      in_serving_softirq()||
+      in_serving_hardirq())
+   {
+
+      #if defined(cpu_relax)
+      cpu_relax();
+      #elif defined(rep_nop)
+      rep_nop();
+      #else
+      wait_ms(50);
+      #endif
+      if(count++>1000)
+      {
+         printk(KERN_ERR "timeout");
+         break;
+      }
+   }
+}
+
+int isPreempt(void)
+{
+   return in_atomic();
+}
+
+void GobiSyncRcu(void)
+{
+   if(isPreempt()!=0)
+   {
+      printk("preempt_enabled");
+   }
+   mb();
+}
+/*=========================================================================*/
+// Generic functions
+/*=========================================================================*/
+u8 QMIXactionIDGet( sGobiUSBNet *pDev)
+{
+   u8 transactionID;
+
+   if( 0 == (transactionID = atomic_add_return( 1, &pDev->mQMIDev.mQMICTLTransactionID)) )
+   {
+      transactionID = atomic_add_return( 1, &pDev->mQMIDev.mQMICTLTransactionID );
+   }
+   
+   return transactionID;
+}
+
+static struct usb_endpoint_descriptor *GetEndpoint(
+    struct usb_interface *pintf,
+    int type,
+    int dir )
+{
+   int i;
+   struct usb_host_interface *iface = pintf->cur_altsetting;
+   struct usb_endpoint_descriptor *pendp;
+
+   for( i = 0; i < iface->desc.bNumEndpoints; i++)
+   {
+      pendp = &iface->endpoint[i].desc;
+      if( ((pendp->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == dir)
+          &&
+          (usb_endpoint_type(pendp) == type) )
+      {
+         return pendp;
+      }
+   }
+
+   return NULL;
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 3,9,0 ))
+static inline struct inode *file_inode(const struct file *f)
+{
+   return f->f_path.dentry->d_inode;
+}
+#endif
+
+int gobi_filp_close(struct file *filp, fl_owner_t id)
+{
+   int retval = 0;
+   struct inode *inode = NULL;
+   if(filp==NULL)
+      return -EIO;
+   inode = file_inode(filp);
+   if(inode == NULL)
+      return -EIO;
+   if (is_bad_inode(inode))
+      return -EIO;
+   if (!file_count(filp)) 
+   {
+      printk(KERN_ERR "VFS: Close: file count is 0\n");
+      return 0;
+   }
+
+   if (filp->f_op->flush)
+      retval = filp->f_op->flush(filp, id);
+   fput(filp);
+   return retval;
+}
+
+int ForceFilpClose(struct file *pFilp)
+{
+   int iRet = -1;
+   if(pFilp==NULL)
+   {
+      printk("NULL Inode\n");
+      return 0;
+   }
+   if (file_count(pFilp)>0)
+   {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,9,0 ))
+      if(file_inode(pFilp)!=NULL)
+      {
+         sQMIFilpStorage * pFilpData = NULL;
+         pFilpData = (sQMIFilpStorage *)pFilp->private_data;
+         if(file_inode(pFilp)!=NULL)
+         {
+            DBG("ino:%lu\n",file_inode(pFilp)->i_ino);
+         }
+         else
+         {
+            DBG("ino:NULL\n");
+            return -EIO;
+         }
+         
+            
+         if(pFilpData ==NULL)
+         {
+            printk( KERN_INFO "bad file data\n" );
+            return -EBADF;
+         }
+         if(pFilpData->iIsClosing == 1)
+         {
+            printk( KERN_INFO "Closing\n" );
+            return -EBADF;
+         }  
+         iRet = gobi_filp_close(pFilp, NULL);
+      }
+      else
+      {
+         printk("NULL Inode\n");
+      }
+
+#else
+      iRet = gobi_filp_close(pFilp, NULL);
+#endif
+   }
+   GobiSyncRcu();
+   mb();
+   return iRet;
+}
+
+static inline int LocalClientMemLockSpinIsLock( sGobiUSBNet * pDev)
+{
+    if(pDev!=NULL)
+    {
+        return spin_is_locked(&pDev->mQMIDev.mClientMemLock);
+    }
+    return 0;
+}
+
+static inline unsigned long LocalClientMemLockSpinLockIRQSave( sGobiUSBNet * pDev, int line)
+{
+   #if SPIN_LOCK_DEBUG
+   printk("(%d)%s :%d\n",task_pid_nr(current),__FUNCTION__,line);
+   #endif
+   mb();
+
+   if(pDev!=NULL)
+   {
+      spin_lock_irq(&pDev->mQMIDev.mClientMemLock);
+      mb();
+      #if SPIN_LOCK_DEBUG
+      printk("(%d)%s :%d Locked\n",task_pid_nr(current),__FUNCTION__,line);
+      #endif
+      pDev->mQMIDev.pTask = current;
+      return 0;
+   }
+   mb();
+   return 0;
+}
+
+static inline int LocalClientMemUnLockSpinLockIRQRestore( sGobiUSBNet * pDev, unsigned long ulFlags, int line)
+{
+   mb();
+   if(pDev!=NULL)
+   {
+      if(LocalClientMemLockSpinIsLock(pDev)==0)
+      {
+         
+         #if SPIN_LOCK_DEBUG
+         printk(KERN_WARNING "(%d)%s :%d Not Locked\n",task_pid_nr(current),__FUNCTION__,line);         
+         #endif
+         return 0;
+      }
+      #if SPIN_LOCK_DEBUG
+      printk("(%d)%s %d :%d\n",task_pid_nr(current),__FUNCTION__,__LINE__,line);
+      #endif
+      pDev->mQMIDev.pTask = NULL;
+      spin_unlock_irq( &pDev->mQMIDev.mClientMemLock);
+   }
+   else
+   {
+      #if SPIN_LOCK_DEBUG
+      printk("(%d)%s %d :%d\n",task_pid_nr(current),__FUNCTION__,__LINE__,line);
+      #endif
+   }
+   mb();
+   return 0;
+}
+
+int gobi_down_interruptible(struct semaphore *sem, sGobiUSBNet *pDev)
+{   
+   return down_interruptible(sem);
+}
+
+
+/*===========================================================================
+METHOD:
+   IsDeviceValid (Public Method)
+
+DESCRIPTION:
+   Basic test to see if device memory is valid
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   bool
+===========================================================================*/
+static inline bool IsDeviceValid( sGobiUSBNet * pDev )
+{
+   if (pDev == NULL)
+   {
+      return false;
+   }
+
+   if (pDev->mbQMIValid == false)
+   {
+      return false;
+   }
+
+   return true;
+}
+
+/*===========================================================================
+METHOD:
+   PrintHex (Public Method)
+
+DESCRIPTION:
+   Print Hex data, for debug purposes
+
+PARAMETERS:
+   pBuffer       [ I ] - Data buffer
+   bufSize       [ I ] - Size of data buffer
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void PrintHex(
+   void *      pBuffer,
+   u16         bufSize )
+{
+   char * pPrintBuf;
+   u16 pos;
+   int status;
+
+   if (!(debug & DEBUG_QMI))
+   {
+       return;
+   }
+   if(bufSize==(u16)(-1))
+   {
+       DBG( "No Data\n" );
+   }
+   pPrintBuf = kmalloc( bufSize * 3 + 1, GOBI_GFP_ATOMIC );
+   if (pPrintBuf == NULL)
+   {
+      DBG( "Unable to allocate buffer\n" );
+      return;
+   }
+   memset( pPrintBuf, 0 , bufSize * 3 + 1 );
+
+   for (pos = 0; pos < bufSize; pos++)
+   {
+      status = snprintf( (pPrintBuf + (pos * 3)),
+                         4,
+                         "%02X ",
+                         *(u8 *)(pBuffer + pos) );
+      if (status != 3)
+      {
+         DBG( "snprintf error %d\n", status );
+         kfree( pPrintBuf );
+         return;
+      }
+   }
+
+   DBG( "   : %s\n", pPrintBuf );
+
+   kfree( pPrintBuf );
+   pPrintBuf = NULL;
+   return;
+}
+
+/*===========================================================================
+METHOD:
+   GobiSetDownReason (Public Method)
+
+DESCRIPTION:
+   Sets mDownReason and turns carrier off
+
+PARAMETERS
+   pDev     [ I ] - Device specific memory
+   reason   [ I ] - Reason device is down
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void GobiSetDownReason(
+   sGobiUSBNet *    pDev,
+   u8                 reason )
+{
+   set_bit( reason, &pDev->mDownReason );
+   if(reason==NO_NDIS_CONNECTION)
+   {
+      pDev->iNetLinkStatus = eNetDeviceLink_Disconnected;
+   }
+   netif_carrier_off( pDev->mpNetDev->net );
+}
+
+/*===========================================================================
+METHOD:
+   GobiClearDownReason (Public Method)
+
+DESCRIPTION:
+   Clear mDownReason and may turn carrier on
+
+PARAMETERS
+   pDev     [ I ] - Device specific memory
+   reason   [ I ] - Reason device is no longer down
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void GobiClearDownReason(
+   sGobiUSBNet *    pDev,
+   u8                 reason )
+{
+   clear_bit( reason, &pDev->mDownReason );
+   if(reason==NO_NDIS_CONNECTION)
+   {
+      pDev->iNetLinkStatus = eNetDeviceLink_Connected;
+   }
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,11,0 ))
+    netif_carrier_on( pDev->mpNetDev->net );
+#else
+   if (pDev->mDownReason == 0)
+   {
+      netif_carrier_on( pDev->mpNetDev->net );
+   }
+#endif
+}
+
+/*===========================================================================
+METHOD:
+   GobiTestDownReason (Public Method)
+
+DESCRIPTION:
+   Test mDownReason and returns whether reason is set
+
+PARAMETERS
+   pDev     [ I ] - Device specific memory
+   reason   [ I ] - Reason device is down
+
+RETURN VALUE:
+   bool
+===========================================================================*/
+bool GobiTestDownReason(
+   sGobiUSBNet *    pDev,
+   u8                 reason )
+{
+   return test_bit( reason, &pDev->mDownReason );
+}
+
+/*=========================================================================*/
+// Driver level asynchronous read functions
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   ResubmitIntURB (Public Method)
+
+DESCRIPTION:
+   Resubmit interrupt URB, re-using same values
+
+PARAMETERS
+   pIntURB       [ I ] - Interrupt URB
+
+RETURN VALUE:
+   int - 0 for success
+         negative errno for failure
+===========================================================================*/
+int ResubmitIntURB(sGobiUSBNet * pDev, struct urb * pIntURB )
+{
+   int status;
+   int interval;
+
+   // Sanity test
+   if ( (pIntURB == NULL)
+   ||   (pIntURB->dev == NULL) )
+   {
+      return -EINVAL;
+   }
+   if( atomic_read(&pIntURB->reject))
+   {
+      DBG( "%s reject!\n" ,__FUNCTION__);
+      return -EINVAL;
+   }
+
+   // Interval needs reset after every URB completion
+   // QC suggestion, 4ms per poll:
+   //   bInterval 6 = 2^5 = 32 frames = 4 ms per poll
+   interval = (pIntURB->dev->speed == USB_SPEED_HIGH) ?
+                 6 : max((int)(pIntURB->ep->desc.bInterval), 3);
+   mb();
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return -EINVAL;
+   }
+   if(IsDeviceDisconnect(pDev))
+   {
+      DBG( "Disconnected!\n" );
+      usb_unlink_urb(pIntURB);
+      return -EINVAL;
+   }
+   spin_lock_irq(&(pDev->urb_lock));
+   // Reschedule interrupt URB
+   usb_fill_int_urb( pIntURB,
+                     pIntURB->dev,
+                     pIntURB->pipe,
+                     pIntURB->transfer_buffer,
+                     pIntURB->transfer_buffer_length,
+                     pIntURB->complete,
+                     pIntURB->context,
+                     interval );
+   mb();
+   status = usb_submit_urb( pIntURB, GOBI_GFP_ATOMIC );
+   spin_unlock_irq(&(pDev->urb_lock));
+   if (status != 0)
+   {
+      DBG( "Error re-submitting Int URB %d\n", status );
+   }
+
+   return status;
+}
+
+/*===========================================================================
+METHOD:
+   ReadCallback (Public Method)
+
+DESCRIPTION:
+   Put the data in storage and notify anyone waiting for data
+
+PARAMETERS
+   pReadURB       [ I ] - URB this callback is run for
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void ReadCallback( struct urb * pReadURB )
+{
+   int result;
+   u16 clientID;
+   sClientMemList * pClientMem;
+   void * pData = NULL;
+   void * pDataCopy = NULL;
+   u16 dataSize;
+   sGobiUSBNet * pDev;
+   unsigned long flags = 0;
+   u16 transactionID;
+   int iResult = 0;
+
+   if (pReadURB == NULL)
+   {
+      DBG( "bad read URB\n" );
+      return;
+   }
+
+   pDev = pReadURB->context;
+   del_timer(&pDev->read_tmr);
+   
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      usb_unlink_urb(pReadURB);
+      return;
+   }
+   
+   if(IsDeviceDisconnect(pDev))
+   {
+      DBG( "%s Disconnected!\n" ,__FUNCTION__);
+      usb_unlink_urb(pReadURB);
+      return;
+   }
+   if( atomic_read(&pReadURB->reject))
+   {
+      DBG( "%s reject!\n" ,__FUNCTION__);
+      return;
+   }
+   if (pReadURB->status != 0)
+   {
+      DBG( "Read status = %d\n", pReadURB->status );
+      if ((pReadURB->status == -ECONNRESET) && (pReadURB->actual_length > 0))
+      {
+          pDev->readTimeoutCnt++;
+          // Read URB unlinked after receiving data, send data to client
+          DBG( "Read URB timeout/kill after recv data\n" );
+          printk(KERN_WARNING "Read URB timeout/kill, recv data len (%d), cnt (%d)\n",
+                  pReadURB->actual_length, pDev->readTimeoutCnt);
+          ResubmitIntURB(pDev, pDev->mQMIDev.mpIntURB );
+          return;
+      }
+      else
+      {
+          // Resubmit the interrupt URB
+          if (IsDeviceValid( pDev ) == false)
+          {
+             DBG( "Invalid device!\n" );
+             usb_unlink_urb(pReadURB);
+             return;
+          }
+          if(IsDeviceDisconnect(pDev))
+          {
+            DBG( "%s Disconnected!\n" ,__FUNCTION__);
+            usb_unlink_urb(pReadURB);
+            return;
+          }
+          ResubmitIntURB(pDev, pDev->mQMIDev.mpIntURB );
+          return;
+      }
+   }
+   DBG( "Read %d bytes\n", pReadURB->actual_length );
+
+   pData = pReadURB->transfer_buffer;
+   if((int)(pReadURB->actual_length)>=0)
+   {
+      dataSize = pReadURB->actual_length;
+   }
+   else
+   {
+      if(IsDeviceDisconnect(pDev))
+      {
+         DBG( "%s Disconnected!\n" ,__FUNCTION__);
+         usb_unlink_urb(pReadURB);
+         return;
+      }
+      ResubmitIntURB(pDev, pDev->mQMIDev.mpIntURB );
+      return;
+   }
+
+   PrintHex( pData, dataSize );
+
+   result = ParseQMUX( &clientID,
+                       pData,
+                       dataSize );
+   if(clientID==QMICTL)
+   {
+      u8 u8Type = 0;
+      u16 u16MsgID = 0;
+      u8Type = *(u8*)(pData + result);
+      transactionID = *(u8*)(pData + result + 1);
+      u16MsgID = le16_to_cpu( get_unaligned((u16*)(pData + result + 2)) );
+      if(u8Type==QMI_CTL_IND)
+      {
+         DBG("u8Type:0x%02x, TID:0x%02x ,MSGID:0x%02x\n",
+         u8Type, transactionID,u16MsgID);
+         if(u16MsgID==QMI_CTL_SYNC_IND)
+         {
+            if(pDev)
+            {
+               if(pDev->dev!=NULL)
+               {
+                  printk(KERN_INFO "RESET DEVICE IND\n");
+                  GobiUSBLockReset(pDev->mpIntf);
+                  return;
+               }
+               else
+               {
+                  DBG("IGNORE REGISTER\n");
+               }
+            }
+         }
+      }
+   }
+   if (result < 0)
+   {
+      DBG( "Read error parsing QMUX %d\n", result );
+      if (IsDeviceValid( pDev ) == false)
+      {
+         DBG( "Invalid device!\n" );
+         usb_unlink_urb(pReadURB);
+         return;
+      }
+      if(IsDeviceDisconnect(pDev))
+      {
+         DBG( "%s Disconnected!\n" ,__FUNCTION__);
+         usb_unlink_urb(pReadURB);
+         return;
+      }
+      // Resubmit the interrupt URB
+      ResubmitIntURB(pDev, pDev->mQMIDev.mpIntURB );
+
+      return;
+   }
+
+   // Grab transaction ID
+
+   // Data large enough?
+   if (dataSize < result + 3)
+   {
+      DBG( "Data buffer too small to parse\n" );
+      if (IsDeviceValid( pDev ) == false)
+      {
+         DBG( "Invalid device!\n" );
+         usb_unlink_urb(pReadURB);
+         return;
+      }
+      if(IsDeviceDisconnect(pDev))
+      {
+         DBG( "%s Disconnected!\n" ,__FUNCTION__);
+         usb_unlink_urb(pReadURB);
+         return;
+      }
+      // Resubmit the interrupt URB
+      ResubmitIntURB(pDev, pDev->mQMIDev.mpIntURB );
+
+      return;
+   }
+
+   // Transaction ID size is 1 for QMICTL, 2 for others
+   if (clientID == QMICTL)
+   {
+      transactionID = *(u8*)(pData + result + 1);
+   }
+   else
+   {
+      transactionID = le16_to_cpu( get_unaligned((u16*)(pData + result + 1)) );
+   }
+
+   // Critical section
+   flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__ );
+
+   // Find memory storage for this service and Client ID
+   // Not using FindClientMem because it can't handle broadcasts
+   pClientMem = pDev->mQMIDev.mpClientMemList;
+   while (pClientMem != NULL)
+   {
+      if(IsDeviceDisconnect(pDev))
+      {
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         usb_unlink_urb(pReadURB);
+         return ;
+      }
+      if (pClientMem->mClientID == clientID
+      ||  (pClientMem->mClientID | 0xff00) == clientID)
+      {
+         // Make copy of pData
+         pDataCopy = kmalloc( dataSize, GOBI_GFP_ATOMIC );
+         if (pDataCopy == NULL)
+         {
+            DBG( "Error allocating client data memory\n" );
+
+            // End critical section
+            LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+            if (IsDeviceValid( pDev ) == false)
+            {
+               DBG( "Invalid device!\n" );
+               return;
+            }
+            if(IsDeviceDisconnect(pDev))
+            {
+               DBG( "%s Disconnected!\n" ,__FUNCTION__);
+               usb_unlink_urb(pReadURB);
+               return;
+            }
+            // Resubmit the interrupt URB
+            ResubmitIntURB(pDev, pDev->mQMIDev.mpIntURB );
+
+            return;            
+         }
+
+         memcpy( pDataCopy, pData, dataSize );
+         mb();
+         if (AddToReadMemList( pDev,
+                               pClientMem->mClientID,
+                               transactionID,
+                               pDataCopy,
+                               dataSize ) == false)
+         {
+            DBG( "Error allocating pReadMemListEntry "
+                 "read will be discarded\n" );
+            kfree( pDataCopy );
+
+            // End critical section
+            if (IsDeviceValid( pDev ) == false)
+            {
+               DBG( "Invalid device!\n" );
+               if(pDev)
+               {
+                  LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+               }
+               else
+               {
+                  LocalClientMemUnLockSpinLockIRQRestore(pDev,flags,__LINE__);
+               }
+               return;
+            }
+            LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+            if(!IsDeviceDisconnect(pDev))
+            {
+               // Resubmit the interrupt URB
+               ResubmitIntURB(pDev, pDev->mQMIDev.mpIntURB );
+            }
+            return;
+         }
+
+         // Success
+         CLIENT_READMEM_SNAPSHOT(clientID, pDev);
+         #if 0
+         DBG( "Creating new readListEntry for client 0x%04X, TID 0x%x\n",
+              clientID,
+              transactionID );
+         #endif
+         // Notify this client data exists
+         iResult = NotifyAndPopNotifyList( pDev,
+                             pClientMem->mClientID,
+                             transactionID );
+         if (iResult==eNotifyListFound) 
+          {
+                //DBG("%s:%d Found ClientID:0x%x , TID:0x%x\n",__FUNCTION__,__LINE__,pClientMem->mClientID,transactionID);
+          }
+          else if (iResult==eNotifyListEmpty) 
+          {
+                DBG("%s:%d Empty ClientID:0x%x , TID:0x%x\n",__FUNCTION__,__LINE__,pClientMem->mClientID,transactionID);
+          }
+          else 
+          {
+            DBG("%s:%d Not Found ClientID:0x%x , TID:0x%x\n",__FUNCTION__,__LINE__,pClientMem->mClientID,transactionID);
+            if (IsDeviceValid( pDev ) == false)
+            {
+               DBG( "Invalid device!\n" );
+               LocalClientMemUnLockSpinLockIRQRestore(pDev,flags,__LINE__);
+               return;
+            }
+            if(  (pDev->mbUnload >= eStatUnloading)||
+                  IsDeviceDisconnect(pDev) )
+            {
+               DBG( "Unload:%s\n", __FUNCTION__);
+               LocalClientMemUnLockSpinLockIRQRestore(pDev,flags,__LINE__);
+               usb_unlink_urb(pReadURB);
+               return ;
+            }
+         }
+         if (iResult==eNotifyListFound)
+         {
+            // Possibly notify poll() that data exists
+            wake_up_interruptible( &pClientMem->mWaitQueue );
+         }
+         else
+         {
+            void * pReadBuffer = NULL;
+            u16 readBufferSize;
+             // Pop the read data
+             if (PopFromReadMemList( pDev,
+                                     pClientMem->mClientID,
+                                     transactionID,
+                                     &pReadBuffer,
+                                     &readBufferSize ) == true)
+             {
+                // Success
+                DBG( "Remove Not Found Memory from read list\n" );
+                if(pReadBuffer)
+                kfree( pReadBuffer );
+                pReadBuffer=NULL;
+             }
+         }
+         // Not a broadcast
+         if (clientID >> 8 != 0xff)
+         {
+            break;
+         }
+      }
+      barrier();
+      // Next element
+      pClientMem = pClientMem->mpNext;
+      mb();
+   }
+   mb();
+   // End critical section
+   LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      usb_unlink_urb(pReadURB);
+      return;
+   }
+   
+   if(IsDeviceDisconnect(pDev))
+   {
+      DBG( "%s Disconnected!\n" ,__FUNCTION__);
+      usb_unlink_urb(pReadURB);
+      return;
+   }
+   // Resubmit the interrupt URB
+   ResubmitIntURB(pDev, pDev->mQMIDev.mpIntURB );
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 4,15,0 ))
+void read_tmr_cb( struct urb * pReadURB )
+{
+   int result;
+#else
+void read_tmr_cb( struct timer_list *t)
+{
+   int result;
+   sGobiUSBNet *pDev = NULL;
+   struct urb *pReadURB = NULL;
+   pDev = from_timer(pDev, t, read_tmr);
+   if(pDev!=NULL)
+   pReadURB = pDev->mQMIDev.mpReadURB;
+#endif
+
+  DBG( "%s called (%ld).\n", __func__, jiffies );
+
+  if ((pReadURB != NULL) && (pReadURB->status == -EINPROGRESS))
+  {
+     // Asynchronously unlink URB. On success, -EINPROGRESS will be returned, 
+     // URB status will be set to -ECONNRESET, and ReadCallback() executed
+     result = usb_unlink_urb( pReadURB );
+     DBG( "%s called usb_unlink_urb, result = %d\n", __func__, result);
+  }
+}
+
+/*===========================================================================
+METHOD:
+   IntCallback (Public Method)
+
+DESCRIPTION:
+   Data is available, fire off a read URB
+
+PARAMETERS
+   pIntURB       [ I ] - URB this callback is run for
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void IntCallback( struct urb * pIntURB )
+{
+   int status;
+   u64 CDCEncResp;
+   u64 CDCEncRespMask;
+
+   sGobiUSBNet * pDev = (sGobiUSBNet *)pIntURB->context;
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return;
+   }
+   if(IsDeviceDisconnect(pDev))
+   {
+      DBG( "Disconnected!\n" );
+      pIntURB->status = -EIO;
+      usb_unlink_urb(pIntURB);
+      return;
+   }
+   // Verify this was a normal interrupt
+   if (pIntURB->status != 0)
+   {
+        DBG( "Int status = %d\n", pIntURB->status );
+
+      // Ignore EOVERFLOW errors
+      if (pIntURB->status != -EOVERFLOW)
+      {
+         // Read 'thread' dies here
+         usb_unlink_urb(pIntURB);
+         return;
+      }
+      if(pIntURB->status<0)
+      {
+         usb_unlink_urb(pIntURB);
+         return;
+      }
+   }
+   else
+   {
+      //TODO cast transfer_buffer to struct usb_cdc_notification
+      
+      // CDC GET_ENCAPSULATED_RESPONSE
+      CDC_GET_ENCAPSULATED_RESPONSE(&CDCEncResp, &CDCEncRespMask)
+      #if 0
+      DBG( "IntCallback: Encapsulated Response = 0x%llx\n",
+          (*(u64*)pIntURB->transfer_buffer));
+      #endif
+      //AR7554RD returned interrupt buffer not matching expected mask
+      //thus, length check only
+      if (pIntURB->actual_length == 8)
+
+      {
+         // Time to read
+         usb_fill_control_urb( pDev->mQMIDev.mpReadURB,
+                               pDev->mpNetDev->udev,
+                               usb_rcvctrlpipe( pDev->mpNetDev->udev, 0 ),
+                               (unsigned char *)pDev->mQMIDev.mpReadSetupPacket,
+                               pDev->mQMIDev.mpReadBuffer,
+                               DEFAULT_READ_URB_LENGTH,
+                               ReadCallbackInt,
+                               pDev );
+         gobi_setup_timer( &pDev->read_tmr, (void*)read_tmr_cb, (unsigned long)pDev->mQMIDev.mpReadURB );
+         mod_timer( &pDev->read_tmr, jiffies + msecs_to_jiffies(USB_READ_TIMEOUT) );
+         mb();
+         status = usb_submit_urb( pDev->mQMIDev.mpReadURB, GOBI_GFP_ATOMIC );
+         if (status != 0)
+         {
+            DBG( "Error submitting Read URB %d\n", status );
+            if (IsDeviceValid( pDev ) == false)
+            {
+               DBG( "Invalid device!\n" );
+               return;
+            }
+            if(IsDeviceDisconnect(pDev))
+            {
+               DBG( "Disconnected!\n" );
+               return;
+            }
+            // Resubmit the interrupt urb
+            ResubmitIntURB( pDev,pIntURB );
+            return;
+         }
+
+         // Int URB will be resubmitted during ReadCallback
+         return;
+      }
+      // CDC CONNECTION_SPEED_CHANGE
+      else if ((pIntURB->actual_length == 16)
+           &&  (CDC_GET_CONNECTION_SPEED_CHANGE(&CDCEncResp, &CDCEncRespMask))
+           &&  ((*(u64*)pIntURB->transfer_buffer & CDCEncRespMask) == CDCEncResp ) )
+      {
+         DBG( "Connection Speed Change = 0x%llx\n",
+              (*(u64*)pIntURB->transfer_buffer));
+
+         // if upstream or downstream is 0, stop traffic.  Otherwise resume it
+         if ((*(u32*)(pIntURB->transfer_buffer + 8) == 0)
+         ||  (*(u32*)(pIntURB->transfer_buffer + 12) == 0))
+         {
+            GobiSetDownReason( pDev, CDC_CONNECTION_SPEED );
+            DBG( "traffic stopping due to CONNECTION_SPEED_CHANGE\n" );
+         }
+         else
+         {
+            GobiClearDownReason( pDev, CDC_CONNECTION_SPEED );
+            DBG( "resuming traffic due to CONNECTION_SPEED_CHANGE\n" );
+         }
+      }
+      else
+      {
+         DBG( "ignoring invalid interrupt in packet\n" );
+         PrintHex( pIntURB->transfer_buffer, pIntURB->actual_length );
+      }
+   }
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return;
+   }
+   if(IsDeviceDisconnect(pDev))
+   {
+      DBG( "Disconnected!\n" );
+      pIntURB->status = -EIO;
+      usb_unlink_urb(pIntURB);
+      return;
+   }
+   // Resubmit the interrupt urb
+   ResubmitIntURB(pDev,pIntURB);
+
+   return;
+}
+
+/*===========================================================================
+METHOD:
+   StartRead (Public Method)
+
+DESCRIPTION:
+   Start continuous read "thread" (callback driven)
+
+   Note: In case of error, KillRead() should be run
+         to remove urbs and clean up memory.
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   int - 0 for success
+         negative errno for failure
+===========================================================================*/
+int StartRead( sGobiUSBNet * pDev )
+{
+   int interval;
+   struct usb_endpoint_descriptor *pendp;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return -ENXIO;
+   }
+
+   // Allocate URB buffers
+   pDev->mQMIDev.mpReadURB = usb_alloc_urb( 0, GOBI_GFP_KERNEL );
+   if (pDev->mQMIDev.mpReadURB == NULL)
+   {
+      DBG( "Error allocating read urb\n" );
+      return -ENOMEM;
+   }
+
+   pDev->mQMIDev.mpIntURB = usb_alloc_urb( 0, GOBI_GFP_KERNEL );
+   if (pDev->mQMIDev.mpIntURB == NULL)
+   {
+      DBG( "Error allocating int urb\n" );
+      usb_free_urb( pDev->mQMIDev.mpReadURB );
+      pDev->mQMIDev.mpReadURB = NULL;
+      return -ENOMEM;
+   }
+
+   // Create data buffers
+   pDev->mQMIDev.mpReadBuffer = kmalloc( DEFAULT_READ_URB_LENGTH, GOBI_GFP_KERNEL );
+   if (pDev->mQMIDev.mpReadBuffer == NULL)
+   {
+      DBG( "Error allocating read buffer\n" );
+      usb_free_urb( pDev->mQMIDev.mpIntURB );
+      pDev->mQMIDev.mpIntURB = NULL;
+      usb_free_urb( pDev->mQMIDev.mpReadURB );
+      pDev->mQMIDev.mpReadURB = NULL;
+      return -ENOMEM;
+   }
+
+   pDev->mQMIDev.mpIntBuffer = kmalloc( DEFAULT_READ_URB_LENGTH, GOBI_GFP_KERNEL );
+   if (pDev->mQMIDev.mpIntBuffer == NULL)
+   {
+      DBG( "Error allocating int buffer\n" );
+      kfree( pDev->mQMIDev.mpReadBuffer );
+      pDev->mQMIDev.mpReadBuffer = NULL;
+      usb_free_urb( pDev->mQMIDev.mpIntURB );
+      pDev->mQMIDev.mpIntURB = NULL;
+      usb_free_urb( pDev->mQMIDev.mpReadURB );
+      pDev->mQMIDev.mpReadURB = NULL;
+      return -ENOMEM;
+   }
+
+   pDev->mQMIDev.mpReadSetupPacket = kmalloc( sizeof( sURBSetupPacket ),
+                                              GOBI_GFP_KERNEL );
+   if (pDev->mQMIDev.mpReadSetupPacket == NULL)
+   {
+      DBG( "Error allocating setup packet buffer\n" );
+      kfree( pDev->mQMIDev.mpIntBuffer );
+      pDev->mQMIDev.mpIntBuffer = NULL;
+      kfree( pDev->mQMIDev.mpReadBuffer );
+      pDev->mQMIDev.mpReadBuffer = NULL;
+      usb_free_urb( pDev->mQMIDev.mpIntURB );
+      pDev->mQMIDev.mpIntURB = NULL;
+      usb_free_urb( pDev->mQMIDev.mpReadURB );
+      pDev->mQMIDev.mpReadURB = NULL;
+      return -ENOMEM;
+   }
+
+   // CDC Get Encapsulated Response packet
+   pDev->mQMIDev.mpReadSetupPacket->mRequestType = 
+       USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+   pDev->mQMIDev.mpReadSetupPacket->mRequestCode = GET_ENCAPSULATED_RESPONSE;
+   pDev->mQMIDev.mpReadSetupPacket->mValue = 0;
+   pDev->mQMIDev.mpReadSetupPacket->mIndex =
+      cpu_to_le16(pDev->mpIntf->cur_altsetting->desc.bInterfaceNumber); /* interface number */
+   pDev->mQMIDev.mpReadSetupPacket->mLength = cpu_to_le16(DEFAULT_READ_URB_LENGTH);
+
+   pendp = GetEndpoint(pDev->mpIntf, USB_ENDPOINT_XFER_INT, USB_DIR_IN);
+   if (pendp == NULL)
+   {
+      DBG( "Invalid interrupt endpoint!\n" );
+      kfree(pDev->mQMIDev.mpReadSetupPacket);
+      pDev->mQMIDev.mpReadSetupPacket = NULL;
+      kfree( pDev->mQMIDev.mpIntBuffer );
+      pDev->mQMIDev.mpIntBuffer = NULL;
+      kfree( pDev->mQMIDev.mpReadBuffer );
+      pDev->mQMIDev.mpReadBuffer = NULL;
+      usb_free_urb( pDev->mQMIDev.mpIntURB );
+      pDev->mQMIDev.mpIntURB = NULL;
+      usb_free_urb( pDev->mQMIDev.mpReadURB );
+      pDev->mQMIDev.mpReadURB = NULL;
+      return -ENXIO;
+   }
+
+   // Interval needs reset after every URB completion
+   interval = (pDev->mpNetDev->udev->speed == USB_SPEED_HIGH) ?
+                 6 : max((int)(pendp->bInterval), 3);
+
+   // Schedule interrupt URB
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return -ENXIO;
+   }
+   mb();
+   wait_interrupt();
+   spin_lock_irq(&(pDev->urb_lock));
+   usb_fill_int_urb( pDev->mQMIDev.mpIntURB,
+                     pDev->mpNetDev->udev,
+                     /* QMI interrupt endpoint for the following
+                      * interface configuration: DM, NMEA, MDM, NET
+                      */
+                     usb_rcvintpipe( pDev->mpNetDev->udev,
+                                     pendp->bEndpointAddress),
+                     pDev->mQMIDev.mpIntBuffer,
+                     le16_to_cpu(pendp->wMaxPacketSize),
+                     IntCallback,
+                     pDev,
+                     interval );
+   spin_unlock_irq(&(pDev->urb_lock));
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return -ENXIO;
+   }
+   mb();
+   return usb_submit_urb( pDev->mQMIDev.mpIntURB, GOBI_GFP_ATOMIC );
+}
+
+/*===========================================================================
+METHOD:
+   KillRead (Public Method)
+
+DESCRIPTION:
+   Kill continuous read "thread"
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void KillRead( sGobiUSBNet * pDev )
+{
+
+   if(pDev ==NULL)
+   {
+      DBG( "pDev NULL\n" );
+      return ;
+   }
+   mb();
+   local_irq_disable();
+   GobiCancelReadCallBackWorkQueue(pDev);
+   // Stop reading
+   if (pDev->mQMIDev.mpReadURB != NULL)
+   {
+      DBG( "Killng read URB\n" );
+      usb_kill_urb( pDev->mQMIDev.mpReadURB );
+   }
+
+   if (pDev->mQMIDev.mpIntURB != NULL)
+   {
+      DBG( "Killng int URB\n" );
+      usb_kill_urb( pDev->mQMIDev.mpIntURB );
+   }
+
+   local_irq_enable();
+
+   // Release buffers
+   kfree( pDev->mQMIDev.mpReadSetupPacket );
+   pDev->mQMIDev.mpReadSetupPacket = NULL;
+   kfree( pDev->mQMIDev.mpReadBuffer );
+   pDev->mQMIDev.mpReadBuffer = NULL;
+   kfree( pDev->mQMIDev.mpIntBuffer );
+   pDev->mQMIDev.mpIntBuffer = NULL;
+
+   // Release URB's
+   usb_free_urb( pDev->mQMIDev.mpReadURB );
+   pDev->mQMIDev.mpReadURB = NULL;
+   usb_free_urb( pDev->mQMIDev.mpIntURB );
+   pDev->mQMIDev.mpIntURB = NULL;
+}
+
+/*===========================================================================
+METHOD:
+   InitSemID (Public Method)
+
+DESCRIPTION:
+   Initialize Read Sync tasks semaphore
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   None
+===========================================================================*/
+
+void InitSemID(sGobiUSBNet * pDev)
+{
+   int i = 0;
+   if(pDev==NULL)
+   {
+      DBG("%s NULL\n",__FUNCTION__);
+      return ;
+   }
+   sema_init( &(pDev->ReadsyncSem), SEMI_INIT_DEFAULT_VALUE );
+   mb();
+   up(&(pDev->ReadsyncSem));
+
+   for(i=0;i<MAX_READ_SYNC_TASK_ID;i++)
+   {
+     pDev->iReasSyncTaskID[i]=-__LINE__;
+     sema_init( &(pDev->readSem[i]), SEMI_INIT_DEFAULT_VALUE );
+     mb();
+   }
+   up(&(pDev->ReadsyncSem));
+}
+int gobi_kthread_should_stop(void)
+{
+   //kthread_should_stop();
+   return 0;
+}
+
+/*=========================================================================*/
+// Internal read/write functions
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   ReadAsync (Public Method)
+
+DESCRIPTION:
+   Start asynchronous read
+   NOTE: Reading client's data store, not device
+
+PARAMETERS:
+   pDev              [ I ] - Device specific memory
+   clientID          [ I ] - Requester's client ID
+   transactionID     [ I ] - Transaction ID or 0 for any
+   pCallback         [ I ] - Callback to be executed when data is available
+   pData             [ I ] - Data buffer that willl be passed (unmodified)
+                             to callback
+
+RETURN VALUE:
+   int - 0 for success
+         negative errno for failure
+===========================================================================*/
+int ReadAsync(
+   sGobiUSBNet *    pDev,
+   u16                clientID,
+   u16                transactionID,
+   void               (*pCallback)(sGobiUSBNet*, u16, void *),
+   void *             pData ,
+   int                iSpinLock)
+{
+   sClientMemList * pClientMem = NULL;
+   sReadMemList ** ppReadMemList = NULL;
+   unsigned long flags = 0;
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return -ENXIO;
+   }
+
+   // Critical section
+   if(iSpinLock==1)
+   flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+
+   // Find memory storage for this client ID
+   pClientMem = FindClientMem( pDev, clientID );
+   if(clientID ==0)
+   {
+      if(iSpinLock==1)
+      LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+      AddClientToMemoryList(pDev,clientID);
+      if(iSpinLock==1)
+      flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+      pClientMem = FindClientMem( pDev, clientID );
+   }
+   if (pClientMem == NULL)
+   {
+      DBG( "Could not find matching client ID 0x%04X\n",
+           clientID );
+
+      // End critical section
+      if(iSpinLock==1)
+      LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+      return -ENXIO;
+   }
+
+   ppReadMemList = &(pClientMem->mpList);
+
+   // Does data already exist?
+   while (*ppReadMemList != NULL)
+   {
+      // Is this element our data?
+      if (transactionID == 0
+      ||  transactionID == (*ppReadMemList)->mTransactionID)
+      {
+         // End critical section
+         if(iSpinLock==1)
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         if((pCallback==UpSem) && (pData ==NULL))
+         {
+            DBG("%d clientID:0x%X,mpData:0x%p",__LINE__,clientID,pData);
+            return 0;
+         }
+         DBG("%d clientID:0x%X,mpData:0x%p",__LINE__,clientID,pData);
+         // Run our own callback
+         pCallback( pDev, clientID, pData );
+
+         return 0;
+      }
+
+      // Next
+      ppReadMemList = &(*ppReadMemList)->mpNext;
+   }
+   mb();
+   // Data not found, add ourself to list of waiters
+   if (AddToNotifyList( pDev,
+                        clientID,
+                        transactionID,
+                        pCallback,
+                        pData ) == false)
+   {
+      DBG( "Unable to register for notification\n" );
+   }
+
+   // End critical section
+   if(iSpinLock==1)
+   LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+
+   // Success
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   UpSem (Public Method)
+
+DESCRIPTION:
+   Notification function for synchronous read
+
+PARAMETERS:
+   pDev              [ I ] - Device specific memory
+   clientID          [ I ] - Requester's client ID
+   pData             [ I ] - Buffer that holds semaphore to be up()-ed
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void UpSem(
+   sGobiUSBNet * pDev,
+   u16             clientID,
+   void *          pData )
+{
+   //DBG( "0x%04X\n", clientID );
+   mb();
+   if(pData!=NULL)
+   {
+      struct semaphore *sem = (struct semaphore *)pData;
+      barrier();
+      up(sem);
+   }
+   return;
+}
+
+/*===========================================================================
+METHOD:
+   ReadSync (Public Method)
+
+DESCRIPTION:
+   Start synchronous read
+   NOTE: Reading client's data store, not device
+
+PARAMETERS:
+   pDev              [ I ] - Device specific memory
+   ppOutBuffer       [I/O] - On success, will be filled with a
+                             pointer to read buffer
+   clientID          [ I ] - Requester's client ID
+   transactionID     [ I ] - Transaction ID or 0 for any
+
+RETURN VALUE:
+   int - size of data read for success
+         negative errno for failure
+===========================================================================*/
+int ReadSync(
+   sGobiUSBNet *    pDev,
+   void **            ppOutBuffer,
+   u16                clientID,
+   u16                transactionID,
+   int                *iID,
+   struct semaphore   *pReadSem,
+   int                *iIsClosing)
+{
+   int result;
+   sClientMemList * pClientMem;
+   sNotifyList ** ppNotifyList, * pDelNotifyListEntry;
+   void * pData = NULL;
+   u16 dataSize;
+   struct semaphore *pLocalreadSem = NULL;
+   unsigned long flags;
+   //DBG("\n");
+   if(pReadSem==NULL)
+   if(*iID<0)
+   {
+      DBG( "Could not find matching SemID\n");
+      return -ENXIO;
+   }
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return -ENXIO;
+   }
+   if (pDev->mbUnload >= eStatUnloading)
+   {
+      DBG( "unloaded\n" );
+      return -EFAULT;
+   }
+
+   if(IsDeviceDisconnect(pDev))
+   {
+      DBG( "Device Disconnected!\n" );
+      return -ENXIO;
+   }
+   
+   if(pReadSem==NULL)
+   {
+      pLocalreadSem = &(pDev->readSem[*iID]);
+   }
+   else
+   {
+     pLocalreadSem = pReadSem;
+   }
+
+   // Critical section
+   flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+
+   // Find memory storage for this Client ID
+   pClientMem = FindClientMem( pDev, clientID );
+   if (pClientMem == NULL)
+   {
+      DBG( "Could not find matching client ID 0x%04X\n",
+           clientID );
+
+      // End critical section
+      LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+      return -ENXIO;
+   }
+
+   // Note: in cases where read is interrupted,
+   //    this will verify client is still valid
+   while (PopFromReadMemList( pDev,
+                              clientID,
+                              transactionID,
+                              &pData,
+                              &dataSize ) == false)
+   {
+      // Data does not yet exist, wait
+       
+      if(pDev->mbUnload >= eStatUnloading)
+      {
+         DBG("Unloading\n");
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         return -ENXIO;
+      }
+      // Add ourself to list of waiters
+      if (AddToNotifyList( pDev,
+                           clientID,
+                           transactionID,
+                           UpSem,
+                           pLocalreadSem ) == false)
+      {
+         DBG( "unable to register for notification\n" );
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         return -EFAULT;
+      }
+
+      // End critical section while we block
+      LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+
+      // Wait for notification
+      if (signal_pending(current))
+      {
+         return -ERESTARTSYS;
+      }
+      result = gobi_down_interruptible( pLocalreadSem,pDev);
+      DBG("result:%d , CID:0x%04x\n",result,clientID);
+      if (IsDeviceValid( pDev ) == false)
+      {
+         DBG( "Invalid device!\n" );
+         return -EFAULT;
+      }
+      if (pDev->mbUnload > eStatUnloading)
+      {
+         DBG( "unloaded\n" );
+          if(pReadSem==NULL)
+          pDev->iReasSyncTaskID[*iID] = -__LINE__;
+          else
+          *iID = -__LINE__;
+           return -EFAULT;
+      }
+      if(iIsClosing!=NULL)
+      {
+         if(*iIsClosing>0)
+         {
+           DBG( "filp is closing\n" );
+           if(pReadSem==NULL)
+           pDev->iReasSyncTaskID[*iID] = -__LINE__;
+           else
+           *iID = -__LINE__;
+           mb();
+           flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+           RemoveAndPopNotifyList(pDev,clientID,transactionID,eClearAndReleaseCID);
+           LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+           return -EFAULT;
+         }
+      }
+      if (result < 0)
+      {
+         if(pDev)
+         {
+            if(pReadSem==NULL)
+            pDev->iReasSyncTaskID[*iID] = -__LINE__;
+            else
+            *iID = -__LINE__;
+         }
+         if(result!=-EINTR)
+         {
+             flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+             RemoveAndPopNotifyList(pDev,clientID,transactionID,eClearCID);
+             LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         }
+         return result;//-EFAULT;EINTR resume error
+      }
+      if(*iID<-1)
+      {
+         DBG( "%s:%d Interrupted %d iID:%d\n",__FUNCTION__,__LINE__, result,*iID );
+         return -EFAULT;
+      }
+      if (signal_pending(current))
+      {
+         return -ERESTARTSYS;
+      }
+      if (result != 0)
+      {
+         DBG( "Interrupted %d\n", result );
+
+         // readSem will fall out of scope,
+         // remove from notify list so it's not referenced
+         if(pDev==NULL)
+         {
+            return -EFAULT;
+         }
+         if(pDev->iIsClosing)
+         {
+            DBG( "Closing device!\n" );
+            if(pDev)
+            {
+                if(pReadSem==NULL)
+                pDev->iReasSyncTaskID[*iID] = -__LINE__;
+                else
+                *iID = -__LINE__;
+            }
+            return -EFAULT;
+         }
+         if(pDev->mbUnload >= eStatUnloading)
+         {
+            DBG("Unloading");
+            if(pReadSem==NULL)
+            pDev->iReasSyncTaskID[*iID] = -__LINE__;
+            else
+            *iID = -__LINE__;
+            return -ENXIO;
+         }
+         flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+         if(pDev)
+         {
+            flags = pDev->mQMIDev.mFlag;
+         }
+         ppNotifyList = &(pClientMem->mpReadNotifyList);
+         pDelNotifyListEntry = NULL;
+
+         // Find and delete matching entry
+         while (*ppNotifyList != NULL)
+         {
+            if (IsDeviceValid( pDev ) == false)
+            {
+               DBG( "Invalid device!\n" );
+               /* SWI_START */
+               /* workaround to leave the system in cleaner state:
+                * must enable interrupts and enable pre-emption.
+                * TBD what the correct action should be when the device is gone. 
+                */
+               LocalClientMemUnLockSpinLockIRQRestore(pDev,flags,__LINE__);
+               //preempt_enable();
+                if(pReadSem==NULL)
+                pDev->iReasSyncTaskID[*iID] = -__LINE__;
+                else
+                *iID = -__LINE__;
+               /* SWI_STOP */
+               return -EFAULT;
+            }
+            if(*iID<0)
+            {
+               DBG( "Invalid device!\n" );
+               /* SWI_START */
+               /* must restore irq, pre-emption, locks before returning */
+               LocalClientMemUnLockSpinLockIRQRestore(pDev,flags,__LINE__);
+               if(pReadSem==NULL)
+               {
+                  if(pDev)
+                  pDev->iReasSyncTaskID[*iID] = -__LINE__;
+               }
+               else
+               *iID = -__LINE__;
+               /* SWI_STOP */
+               return -EFAULT;
+            }
+            if(pDev==NULL)
+            {
+               DBG( "Invalid device!\n" );
+               LocalClientMemUnLockSpinLockIRQRestore(pDev,flags,__LINE__);
+               return -EFAULT;
+            }
+            if (pDev->mbUnload > eStatUnloading)
+            {
+               DBG( "UNLOADING!\n" );
+               LocalClientMemUnLockSpinLockIRQRestore(pDev,flags,__LINE__);
+               if(pReadSem==NULL)
+               pDev->iReasSyncTaskID[*iID] = -__LINE__;
+               else
+               *iID = -__LINE__;
+               return -EFAULT;
+            }
+            if(ppNotifyList==NULL)
+            {
+                DBG( "UNLOADING!\n" );
+                LocalClientMemUnLockSpinLockIRQRestore(pDev,flags,__LINE__);
+                if(pReadSem==NULL)
+                pDev->iReasSyncTaskID[*iID] = -__LINE__;
+                else
+                *iID = -__LINE__;
+                return -EFAULT;
+            }
+            if ((*ppNotifyList)->mpData == 
+                  pLocalreadSem)
+            {
+               pDelNotifyListEntry = *ppNotifyList;
+               *ppNotifyList = (*ppNotifyList)->mpNext;
+               kfree( pDelNotifyListEntry );
+               mb();
+               break;
+            }
+            barrier();
+            // Next
+            ppNotifyList = &(*ppNotifyList)->mpNext;
+            mb();
+         }
+         mb();
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         if(pDev)
+        {
+            if(pReadSem==NULL)
+            pDev->iReasSyncTaskID[*iID] = -__LINE__;
+            else
+            *iID = -__LINE__;
+        }
+         return -EINTR;
+      }
+
+      // Verify device is still valid
+      if (IsDeviceValid( pDev ) == false)
+      {
+         DBG( "Invalid device!\n" );
+         if(pDev)
+         {
+             if(pReadSem==NULL)
+             pDev->iReasSyncTaskID[*iID] = -__LINE__;
+             else
+             *iID = -__LINE__;
+         }
+         return -ENXIO;
+      }
+
+      // Restart critical section and continue loop
+      flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+   }
+
+   // End Critical section
+   LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+
+   // Success
+   *ppOutBuffer = pData;
+   if(pDev)
+   {
+      if(pReadSem==NULL)
+      pDev->iReasSyncTaskID[*iID] = -__LINE__;
+      else
+      *iID = -__LINE__;
+   }
+   return dataSize;
+}
+
+/*===========================================================================
+METHOD:
+   WriteSync (Public Method)
+
+DESCRIPTION:
+   Start synchronous write
+
+PARAMETERS:
+   pDev                 [ I ] - Device specific memory
+   pWriteBuffer         [ I ] - Data to be written
+   writeBufferSize      [ I ] - Size of data to be written
+   clientID             [ I ] - Client ID of requester
+
+RETURN VALUE:
+   int - write size (includes QMUX)
+         negative errno for failure
+===========================================================================*/
+int WriteSync(
+   sGobiUSBNet *          pDev,
+   char *                 pWriteBuffer,
+   int                    writeBufferSize,
+   u16                    clientID )
+{
+   int i;
+   int result;
+   int iLockRetry =0;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return -ENXIO;
+   }
+
+   if (pDev->mbUnload >= eStatUnloading)
+   {
+      DBG( "Unloading device!\n" );
+      return -ENXIO;
+   }
+
+   if(IsDeviceDisconnect(pDev))
+   {
+      DBG( "Device Disconnected!\n" );
+      return -ENXIO;
+   }
+
+   // Fill writeBuffer with QMUX
+   result = FillQMUX( clientID, pWriteBuffer, writeBufferSize );
+   if (result < 0)
+   {
+      return result;
+   }
+
+   // Wake device
+   result = gobi_usb_autopm_get_interface( pDev->mpIntf );
+   if (result < 0)
+   {
+      DBG( "unable to resume interface: %d\n", result );
+
+      // Likely caused by device going from autosuspend -> full suspend
+      if (result == -EPERM)
+      {
+#ifdef CONFIG_PM
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,33 ))
+         pDev->mpNetDev->udev->auto_pm = 0;
+#endif
+         GobiNetSuspend( pDev->mpIntf, PMSG_SUSPEND );
+#endif /* CONFIG_PM */
+      }
+      return result;
+   }
+
+   DBG( "Actual Write:\n" );
+   PrintHex( pWriteBuffer, writeBufferSize );
+
+   // Write Control URB, protect with read semaphore to track in-flight USB control writes in case of disconnect
+   for(i=0;i<USB_WRITE_RETRY;i++)
+   {
+      
+      if(isModuleUnload(pDev))
+      {
+         DBG( "unloaded\n" );
+         return -EFAULT;
+      }
+      if(IsDeviceDisconnect(pDev))
+      {
+         DBG( "Device Disconnected!\n" );
+         return -ENXIO;
+      }
+      pDev->iShutdown_read_sem= __LINE__;
+      if(signal_pending(current))
+      {
+         return -ERESTARTSYS;
+      }
+
+      iLockRetry = 0;
+      mb();
+      while(down_read_trylock(&(pDev->shutdown_rwsem))!=1)
+      {
+         wait_ms(5);
+         mb();
+         if(iLockRetry++>100)
+         {
+            DBG("down_read_trylock timeout");
+            return -EFAULT;
+         }
+         if(pDev==NULL)
+         {
+            DBG( "NULL\n" );
+            return -EFAULT;
+         }
+         if (pDev->mbUnload >= eStatUnloading)
+         {
+            DBG( "unloaded\n" );
+            return -EFAULT;
+         }
+         if(IsDeviceDisconnect(pDev))
+         {
+            DBG( "Device Disconnected!\n" );
+            return -ENXIO;
+         }
+      }
+      mb();
+      result = Gobi_usb_control_msg(pDev->mpIntf, pDev->mpNetDev->udev, usb_sndctrlpipe( pDev->mpNetDev->udev, 0 ),
+             SEND_ENCAPSULATED_COMMAND,
+             USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+             0, pDev->mpIntf->cur_altsetting->desc.bInterfaceNumber,
+             (void*)pWriteBuffer, writeBufferSize,
+             USB_WRITE_TIMEOUT );
+       up_read(&pDev->shutdown_rwsem);
+       if(signal_pending(current))
+       {
+          return -ERESTARTSYS;
+       }
+       if(pDev==NULL)
+       {
+          return -EFAULT;
+       }
+       if (IsDeviceDisconnect(pDev) )
+       {
+         return -ENXIO;
+       }
+       pDev->iShutdown_read_sem=- __LINE__;
+       
+       if (pDev->mbUnload >= eStatUnloading)
+       {
+          DBG( "unloaded\n" );
+          return -EFAULT;
+       }
+
+       if (signal_pending(current))
+       {
+           return -ERESTARTSYS;
+       }
+
+       if (result < 0)
+       {
+          printk(KERN_WARNING "usb_control_msg failed (%d)", result);
+       }
+       // Control write transfer may occasionally timeout with certain HCIs, attempt a second time before reporting an error
+       if (result == -ETIMEDOUT)
+       {
+           pDev->writeTimeoutCnt++;
+           printk(KERN_WARNING "Write URB timeout, cnt(%d)\n", pDev->writeTimeoutCnt);
+       }
+       else if(result < 0 )
+       {
+          DBG( "%s no device!\n" ,__FUNCTION__);
+           return result;
+       }
+       else
+       {
+           break;
+       }
+       if (IsDeviceValid( pDev ) == false)
+       {
+          DBG( "%s Invalid device!\n" ,__FUNCTION__);
+          return -ENXIO;
+       }
+       if(IsDeviceDisconnect(pDev))
+       {
+          DBG( "Device Disconnected!\n" );
+          return -ENXIO;
+       }
+       if (pDev->mbUnload > eStatUnloading)
+       {
+         DBG( "unloaded\n" );
+         return -EFAULT;
+       }
+   }
+
+   // Write is done, release device
+   gobi_usb_autopm_put_interface( pDev->mpIntf );
+
+
+   return result;
+}
+
+/*=========================================================================*/
+// Internal memory management functions
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   AddClientToMemoryList (Public Method)
+
+DESCRIPTION:
+   Add Client To Memory List
+
+PARAMETERS:
+   pDev           [ I ] - Device specific memory
+   clientID       [ I ] - Client ID
+
+RETURN VALUE:
+   int - Add Client ID to Memory List for success (positive)
+         Negative errno for error
+===========================================================================*/
+int AddClientToMemoryList(sGobiUSBNet *pDev,u16 clientID)
+{
+   unsigned long flags;
+   sClientMemList ** ppClientMem;
+   // Critical section
+   flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+
+   // Verify client is not already allocated
+   if (FindClientMem( pDev, clientID ) != NULL)
+   {
+      DBG( "Client memory already exists CID:0x%x\n",clientID );
+      // End Critical section
+      LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+      return -ETOOMANYREFS;
+   }
+   //DBG( "Add Client memory CID:0x%x\n",clientID );
+   // Go to last entry in client mem list
+   ppClientMem = &pDev->mQMIDev.mpClientMemList;
+   while (*ppClientMem != NULL)
+   {
+      ppClientMem = &(*ppClientMem)->mpNext;
+   }
+
+   // Create locations for read to place data into
+   *ppClientMem = kmalloc( sizeof( sClientMemList ), GOBI_GFP_ATOMIC );
+   if (*ppClientMem == NULL)
+   {
+      DBG( "Error allocating read list\n" );
+
+      // End critical section
+      LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+      return -ENOMEM;
+   }
+
+   (*ppClientMem)->mClientID = clientID;
+   (*ppClientMem)->mpList = NULL;
+   (*ppClientMem)->mpReadNotifyList = NULL;
+   (*ppClientMem)->mpURBList = NULL;
+   (*ppClientMem)->mpNext = NULL;
+   mb();
+   // Initialize workqueue for poll()
+   init_waitqueue_head( &(*ppClientMem)->mWaitQueue );
+
+   // End Critical section
+   LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+   return (int)clientID;
+}
+
+/*=========================================================================*/
+// Internal memory management functions
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   GetClientID (Public Method)
+
+DESCRIPTION:
+   Request a QMI client for the input service type and initialize memory
+   structure
+
+PARAMETERS:
+   pDev           [ I ] - Device specific memory
+   serviceType    [ I ] - Desired QMI service type
+
+RETURN VALUE:
+   int - Client ID for success (positive)
+         Negative errno for error
+===========================================================================*/
+int GetClientID(
+   sGobiUSBNet *    pDev,
+   u8                 serviceType ,
+   struct semaphore   *pReadSem)
+{
+   u16 clientID;
+   int result;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   void * pReadBuffer;
+   u16 readBufferSize;
+   u8 transactionID;
+   unsigned long flags;
+   struct semaphore readSem;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return -ENXIO;
+   }
+   sema_init( &readSem, SEMI_INIT_DEFAULT_VALUE );
+   mb();
+   // Run QMI request to be asigned a Client ID
+   if (serviceType != 0)
+   {
+      writeBufferSize = QMICTLGetClientIDReqSize();
+      pWriteBuffer = kmalloc( writeBufferSize, GOBI_GFP_KERNEL );
+      if (pWriteBuffer == NULL)
+      {
+         return -ENOMEM;
+      }
+
+      /* transactionID cannot be 0 */
+      transactionID = QMIXactionIDGet(pDev);
+      if (transactionID != 0)
+      {
+         result = QMICTLGetClientIDReq( pWriteBuffer,
+                                        writeBufferSize,
+                                        transactionID,
+                                        serviceType );
+         if (result < 0)
+         {
+            if(pWriteBuffer)
+            {
+               kfree( pWriteBuffer );
+               pWriteBuffer = NULL;
+            }
+            return result;
+         }
+      }
+      else
+      {
+         if(pWriteBuffer)
+         {
+            kfree( pWriteBuffer );
+            pWriteBuffer = NULL;
+         }
+         DBG( "Invalid transaction ID!\n" );
+         return -EINVAL;
+      }
+
+      result = ReadAsync( pDev, QMICTL, transactionID, UpSem, &readSem ,1);
+      if (result < 0)
+      {
+         DBG( "ReadAsync Error!\n" );
+         if(pWriteBuffer)
+         {
+            kfree( pWriteBuffer );
+            pWriteBuffer = NULL;
+         }
+         return result;
+      }
+      result = WriteSync( pDev,
+                          pWriteBuffer,
+                          writeBufferSize,
+                          QMICTL );
+      if(pWriteBuffer)
+      {
+         kfree( pWriteBuffer );
+         pWriteBuffer = NULL;
+      }
+      if (result < 0)
+      {
+         // Timeout, remove the async read
+         DBG( "%s Timeout!\n" ,__FUNCTION__);
+         flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+         // Timeout, remove the async read
+         RemoveAndPopNotifyList(pDev,QMICTL,transactionID,eClearAndReleaseCID);
+         // End critical section
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         return result;
+      }
+      wait_control_msg_semaphore_timeout(&readSem,QMI_CONTROL_MAX_MSG_DELAY_MS);
+      mb();
+      // Enter critical section
+      flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+      barrier();
+      spin_lock_irq(&(pDev->notif_lock));
+      if (down_trylock( &readSem ) == 0)
+      {
+         // Pop the read data
+         if (PopFromReadMemList( pDev,
+                                 QMICTL,
+                                 transactionID,
+                                 &pReadBuffer,
+                                 &readBufferSize ) == true)
+         {
+            // Success
+            DBG( "Success!\n" );
+            spin_unlock_irq(&(pDev->notif_lock));
+            // End critical section
+            LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+            result = QMICTLGetClientIDResp( pReadBuffer,
+                                      readBufferSize,
+                                      &clientID );
+            // We don't care about the result
+            DBG( "QMICTLGetClientIDResp Result:%d!\n" ,result);
+            if(pReadBuffer)
+            kfree( pReadBuffer );
+            pReadBuffer=NULL;
+         }
+         else
+         {
+            // Read mismatch/failure, unlock and continue
+            DBG( "Read mismatch/failure, unlock and continue!\n" );
+            spin_unlock_irq(&(pDev->notif_lock));
+            LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+            result = -1;
+         }
+      }
+      else
+      {
+             // Timeout, remove the async read
+             DBG( "Timeout, remove the async read!\n" );
+             //ReleaseNotifyList( pDev, QMICTL, transactionID );
+             // Timeout, remove the async read
+             RemoveAndPopNotifyList(pDev,QMICTL,transactionID,eClearAndReleaseCID);
+             // End critical section
+             spin_unlock_irq(&(pDev->notif_lock));
+             LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+             result = -1;
+      }
+     /* Upon return from QMICTLGetClientIDResp, clientID
+      * low address contains the Service Number (SN), and
+      * clientID high address contains Client Number (CN)
+      * For the ReadCallback to function correctly,we swap
+      * the SN and CN on a Big Endian architecture.
+      */
+      clientID = le16_to_cpu(clientID);
+
+      if (result < 0)
+      {
+         return result;
+      }
+   }
+   else
+   {
+      // QMI CTL will always have client ID 0
+      clientID = 0;
+   }
+   return AddClientToMemoryList(pDev,clientID);
+}
+
+/*===========================================================================
+METHOD:
+   ReleaseClientID (Public Method)
+
+DESCRIPTION:
+   Release QMI client and free memory
+
+PARAMETERS:
+   pDev           [ I ] - Device specific memory
+   clientID       [ I ] - Requester's client ID
+
+RETURN VALUE:
+   true - 0 success.
+   false - on error.
+===========================================================================*/
+bool ReleaseClientID(
+   sGobiUSBNet *    pDev,
+   u16                clientID)
+{
+   sClientMemList ** ppDelClientMem;
+   sClientMemList * pNextClientMem;
+   void * pDelData = NULL;
+   u16 dataSize;
+   unsigned long flags = 0;
+   bool bReturn = true;
+   
+   // Is device is still valid?
+   DBG("clientID:0x%x\n",clientID);
+   if (pDev->mbUnload > eStatUnloaded)
+   {
+      DBG( "unloaded\n" );
+      return false;
+   }
+   barrier();
+     
+   if(TransceiveReleaseClientID(pDev,clientID)==false)
+   {
+      pDev->mReleaseClientIDFail = 1;
+   }
+   
+   // Cleaning up client memory
+   DBG("Release clientID:0x%x memory\n",clientID);
+   // Critical section
+   flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+
+   // Can't use FindClientMem, I need to keep pointer of previous
+   ppDelClientMem = &pDev->mQMIDev.mpClientMemList;
+   while (*ppDelClientMem != NULL)
+   {
+      mb();
+      if ((*ppDelClientMem)->mClientID == clientID)
+      {
+         barrier();
+         pNextClientMem = (*ppDelClientMem)->mpNext;
+
+         // Notify all clients
+         while (NotifyAndPopNotifyList( pDev,
+                                        clientID,
+                                        0 ) == eNotifyListFound );
+         // Free any unread data
+         while (PopFromReadMemList( pDev,
+                                    clientID,
+                                    0,
+                                    &pDelData,
+                                    &dataSize ) == true )
+         {
+            kfree( pDelData );
+            pDelData = NULL;
+         }
+         //DBG("Delete client Mem\r\n");
+         if(*ppDelClientMem!=NULL)
+         {
+            // Delete client Mem
+            kfree( *ppDelClientMem );
+         }
+         else
+         {
+            bReturn = false;
+         }
+         *ppDelClientMem = NULL;
+         //DBG("Prepare Next Delete client Mem\r\n");
+         // Overwrite the pointer that was to this client mem
+         barrier();
+         *ppDelClientMem = pNextClientMem;
+      }
+      else
+      {
+         // I now point to (a pointer of ((the node I was at)'s mpNext))
+          if(*ppDelClientMem==NULL)
+          {
+              DBG("ppDelClientMem NULL %d\r\n",__LINE__);
+              break;
+          }
+          //DBG("mpClientMemList:%p,*ppDelClientMem:%p",&pDev->mQMIDev.mpClientMemList,*ppDelClientMem);
+          barrier();
+          pNextClientMem = (*ppDelClientMem)->mpNext;
+          barrier();
+          ppDelClientMem = &(*ppDelClientMem)->mpNext;
+      }
+   }
+   mb();
+   // End Critical section
+   LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+   return bReturn;
+}
+
+/*===========================================================================
+METHOD:
+   FindClientMem (Public Method)
+
+DESCRIPTION:
+   Find this client's memory
+
+   Caller MUST have lock on mClientMemLock
+
+PARAMETERS:
+   pDev           [ I ] - Device specific memory
+   clientID       [ I ] - Requester's client ID
+
+RETURN VALUE:
+   sClientMemList - Pointer to requested sClientMemList for success
+                    NULL for error
+===========================================================================*/
+sClientMemList * FindClientMem(
+   sGobiUSBNet *      pDev,
+   u16              clientID )
+{
+   sClientMemList * pClientMem;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return NULL;
+   }
+   mb();
+#ifdef CONFIG_SMP
+   // Verify Lock
+   #if _IGNORE_DISCONNECT_SPIN_LOCK_CHECK_
+   if(!IsDeviceDisconnect(pDev))
+   #endif
+   if (LocalClientMemLockSpinIsLock( pDev ) == 0)
+   {
+      DBG( "unlocked\n" );
+      BUG();
+   }
+#endif
+
+   pClientMem = pDev->mQMIDev.mpClientMemList;
+   while (pClientMem != NULL)
+   {
+      if (pClientMem->mClientID == clientID)
+      {
+         // Success
+         //DBG("Found client's 0x%x memory\n", clientID);
+         return pClientMem;
+      }
+
+      pClientMem = pClientMem->mpNext;
+   }
+
+   //DBG( "Could not find client mem 0x%04X\n", clientID );
+   return NULL;
+}
+
+/*===========================================================================
+METHOD:
+   AddToReadMemList (Public Method)
+
+DESCRIPTION:
+   Add Data to this client's ReadMem list
+
+   Caller MUST have lock on mClientMemLock
+
+PARAMETERS:
+   pDev           [ I ] - Device specific memory
+   clientID       [ I ] - Requester's client ID
+   transactionID  [ I ] - Transaction ID or 0 for any
+   pData          [ I ] - Data to add
+   dataSize       [ I ] - Size of data to add
+
+RETURN VALUE:
+   bool
+===========================================================================*/
+bool AddToReadMemList(
+   sGobiUSBNet *      pDev,
+   u16              clientID,
+   u16              transactionID,
+   void *           pData,
+   u16              dataSize )
+{
+   sClientMemList * pClientMem;
+   sReadMemList ** ppThisReadMemList;
+
+#ifdef CONFIG_SMP
+   // Verify Lock
+   #if _IGNORE_DISCONNECT_SPIN_LOCK_CHECK_
+   if(!IsDeviceDisconnect(pDev))
+   #endif
+   if (LocalClientMemLockSpinIsLock( pDev ) == 0)
+   {
+      DBG( "unlocked\n" );
+      BUG();
+   }
+#endif
+
+   // Get this client's memory location
+   pClientMem = FindClientMem( pDev, clientID );
+   if (pClientMem == NULL)
+   {
+      DBG( "Could not find this client's memory 0x%04X\n",
+           clientID );
+
+      return false;
+   }
+
+   // Go to last ReadMemList entry
+   ppThisReadMemList = &pClientMem->mpList;
+   while (*ppThisReadMemList != NULL)
+   {
+      ppThisReadMemList = &(*ppThisReadMemList)->mpNext;
+   }
+   mb();
+   *ppThisReadMemList = kmalloc( sizeof( sReadMemList ), GOBI_GFP_ATOMIC );
+   if (*ppThisReadMemList == NULL)
+   {
+      DBG( "Mem error\n" );
+
+      return false;
+   }
+
+   (*ppThisReadMemList)->mpNext = NULL;
+   (*ppThisReadMemList)->mpData = pData;
+   (*ppThisReadMemList)->mDataSize = dataSize;
+   (*ppThisReadMemList)->mTransactionID = transactionID;
+   mb();
+   return true;
+}
+
+/*===========================================================================
+METHOD:
+   PopFromReadMemList (Public Method)
+
+DESCRIPTION:
+   Remove data from this client's ReadMem list if it matches
+   the specified transaction ID.
+
+   Caller MUST have lock on mClientMemLock
+
+PARAMETERS:
+   pDev              [ I ] - Device specific memory
+   clientID          [ I ] - Requester's client ID
+   transactionID     [ I ] - Transaction ID or 0 for any
+   ppData            [I/O] - On success, will be filled with a
+                             pointer to read buffer
+   pDataSize         [I/O] - On succces, will be filled with the
+                             read buffer's size
+
+RETURN VALUE:
+   bool
+===========================================================================*/
+bool PopFromReadMemList(
+   sGobiUSBNet *      pDev,
+   u16              clientID,
+   u16              transactionID,
+   void **          ppData,
+   u16 *            pDataSize )
+{
+   sClientMemList * pClientMem;
+   sReadMemList * pDelReadMemList, ** ppReadMemList;
+   //DBG("");
+#ifdef CONFIG_SMP
+   // Verify Lock
+   #if _IGNORE_DISCONNECT_SPIN_LOCK_CHECK_
+   if(!IsDeviceDisconnect(pDev))
+   #endif
+   if (LocalClientMemLockSpinIsLock( pDev ) == 0)
+   {
+      DBG( "unlocked\n" );
+      BUG();
+   }
+#endif
+
+   // Get this client's memory location
+   pClientMem = FindClientMem( pDev, clientID );
+   if (pClientMem == NULL)
+   {
+      DBG( "Could not find this client's memory 0x%04X\n",
+           clientID );
+
+      return false;
+   }
+
+   ppReadMemList = &(pClientMem->mpList);
+   pDelReadMemList = NULL;
+
+   // Find first message that matches this transaction ID
+   CLIENT_READMEM_SNAPSHOT(clientID, pDev);
+   while (*ppReadMemList != NULL)
+   {
+      // Do we care about transaction ID?
+      if (transactionID == 0
+      ||  transactionID == (*ppReadMemList)->mTransactionID )
+      {
+         pDelReadMemList = *ppReadMemList;
+         #if 0
+         DBG(  "*ppReadMemList = 0x%p pDelReadMemList = 0x%p\n",
+               *ppReadMemList, pDelReadMemList );
+         #endif
+         break;
+      }
+
+      //DBG( "skipping 0x%04X data TID = 0x%x\n", clientID, (*ppReadMemList)->mTransactionID );
+
+      // Next
+      ppReadMemList = &(*ppReadMemList)->mpNext;
+   }
+   mb();
+   //DBG(  "*ppReadMemList = 0x%p pDelReadMemList = 0x%p\n",
+   //      *ppReadMemList, pDelReadMemList );
+   if (pDelReadMemList != NULL)
+   {
+       if(*ppReadMemList==NULL)
+       {
+           DBG("ppReadMemList NULL\n");
+           return false;
+       }
+      *ppReadMemList = (*ppReadMemList)->mpNext;
+
+      // Copy to output
+      *ppData = pDelReadMemList->mpData;
+      *pDataSize = pDelReadMemList->mDataSize;
+      #if 0
+      DBG(  "*ppData = 0x%p pDataSize = %u\n",
+            *ppData, *pDataSize );
+      #endif
+      // Free memory
+      kfree( pDelReadMemList );
+      pDelReadMemList = NULL;
+      mb();
+      return true;
+   }
+   else
+   {
+      DBG( "No read memory to pop, Client 0x%04X, TID = 0x%x\n",
+           clientID,
+           transactionID );
+      return false;
+   }
+}
+
+/*===========================================================================
+METHOD:
+   AddToNotifyList (Public Method)
+
+DESCRIPTION:
+   Add Notify entry to this client's notify List
+
+   Caller MUST have lock on mClientMemLock
+
+PARAMETERS:
+   pDev              [ I ] - Device specific memory
+   clientID          [ I ] - Requester's client ID
+   transactionID     [ I ] - Transaction ID or 0 for any
+   pNotifyFunct      [ I ] - Callback function to be run when data is available
+   pData             [ I ] - Data buffer that willl be passed (unmodified)
+                             to callback
+
+RETURN VALUE:
+   bool
+===========================================================================*/
+bool AddToNotifyList(
+   sGobiUSBNet *      pDev,
+   u16              clientID,
+   u16              transactionID,
+   void             (* pNotifyFunct)(sGobiUSBNet *, u16, void *),
+   void *           pData )
+{
+   sClientMemList * pClientMem;
+   sNotifyList ** ppThisNotifyList;
+   //DBG("ClientID:0x%x, TID:0x%x\n",clientID,transactionID);
+   mb();
+   if(pDev==NULL)
+   {
+      DBG("NULL");
+      return eNotifyListEmpty;
+   }
+#ifdef CONFIG_SMP
+   // Verify Lock
+   #if _IGNORE_DISCONNECT_SPIN_LOCK_CHECK_
+   if(!IsDeviceDisconnect(pDev))
+   #endif
+   if (LocalClientMemLockSpinIsLock( pDev ) == 0)
+   {
+      DBG( "unlocked\n" );
+      BUG();
+   }
+#endif
+
+   // Get this client's memory location
+   pClientMem = FindClientMem( pDev, clientID );
+   if (pClientMem == NULL)
+   {
+      DBG( "Could not find this client's memory 0x%04X\n", clientID );
+      return false;
+   }
+
+   // Go to last URBList entry
+   ppThisNotifyList = &pClientMem->mpReadNotifyList;
+   while (*ppThisNotifyList != NULL)
+   {
+      ppThisNotifyList = &(*ppThisNotifyList)->mpNext;
+   }
+   mb();
+   *ppThisNotifyList = kmalloc( sizeof( sNotifyList ), GOBI_GFP_ATOMIC );
+   if (*ppThisNotifyList == NULL)
+   {
+      DBG( "Mem error\n" );
+      return false;
+   }
+
+   (*ppThisNotifyList)->mpNext = NULL;
+   (*ppThisNotifyList)->mpNotifyFunct = pNotifyFunct;
+   (*ppThisNotifyList)->mpData = pData;
+   (*ppThisNotifyList)->mTransactionID = transactionID;
+   mb();
+   return true;
+}
+
+/*===========================================================================
+METHOD:
+   NotifyAndPopNotifyList (Public Method)
+
+DESCRIPTION:
+   Remove first Notify entry from this client's notify list
+   and Run function
+
+   Caller MUST have lock on mClientMemLock
+
+PARAMETERS:
+   pDev              [ I ] - Device specific memory
+   clientID          [ I ] - Requester's client ID
+   transactionID     [ I ] - Transaction ID or 0 for any
+
+RETURN VALUE:
+   bool
+===========================================================================*/
+int NotifyAndPopNotifyList(
+   sGobiUSBNet *      pDev,
+   u16              clientID,
+   u16              transactionID )
+{
+   sClientMemList * pClientMem;
+   sNotifyList * pDelNotifyList = NULL, **ppNotifyList;
+
+   if(pDev==NULL)
+   {
+      DBG("NULL");
+      return eNotifyListEmpty;
+   }
+#ifdef CONFIG_SMP
+   // Verify Lock
+   #if _IGNORE_DISCONNECT_SPIN_LOCK_CHECK_
+   if(!IsDeviceDisconnect(pDev))
+   #endif
+   if (LocalClientMemLockSpinIsLock( pDev ) == 0)
+   {
+      DBG( "unlocked\n" );
+      BUG();
+   }
+#endif
+
+   // Get this client's memory location
+   pClientMem = FindClientMem( pDev, clientID );
+   if (pClientMem == NULL)
+   {
+      DBG( "Could not find this client's memory 0x%04X\n", clientID );
+      return eNotifyListEmpty;
+   }
+
+   ppNotifyList = &(pClientMem->mpReadNotifyList);
+   pDelNotifyList = NULL;
+
+   // Remove from list
+   CLIENT_READMEM_SNAPSHOT(clientID,pDev);
+   while (*ppNotifyList != NULL)
+   {
+      // Do we care about transaction ID?
+      if (transactionID == 0
+      ||  (*ppNotifyList)->mTransactionID == 0
+      ||  transactionID == (*ppNotifyList)->mTransactionID)
+      {
+         if((clientID==0)&&(transactionID!=(*ppNotifyList)->mTransactionID))
+         {
+            
+         }
+         else
+         {
+            pDelNotifyList = *ppNotifyList;
+            mb();
+            break;
+         }
+      }
+
+      DBG( "skipping data TID = %x\n", (*ppNotifyList)->mTransactionID );
+
+      // next
+      barrier();
+      ppNotifyList = &(*ppNotifyList)->mpNext;
+      mb();
+   }
+   mb();
+   if (pDelNotifyList != NULL)
+   {
+      // Remove element
+      *ppNotifyList = (*ppNotifyList)->mpNext;
+
+      // Run notification function
+      if (pDelNotifyList->mpNotifyFunct != NULL)
+      {
+          // Unlock for callback
+          if(((clientID==QMICTL)&&(pDev->mbUnload>=eStatUnloading)) ||
+               IsDeviceDisconnect(pDev))
+          {
+
+          }
+          else
+          {
+                if((pDelNotifyList->mpNotifyFunct == UpSem) && (pDelNotifyList->mpData==NULL))
+                {
+                   
+                }
+                else
+                {
+                  barrier();
+                  pDelNotifyList->mpNotifyFunct( pDev,
+                                           clientID,
+                                           pDelNotifyList->mpData );
+                }
+          }
+      }
+
+      // Delete memory
+      kfree( pDelNotifyList );
+      //DBG( "notify for Client:0x%x, TID 0x%x\n",clientID, transactionID );
+      mb();
+      return eNotifyListFound;
+   }
+   else
+   {
+      DBG( "no one to notify for Client:0x%x, TID 0x%x\n",clientID, transactionID );
+      return eNotifyListNotFound;
+   }
+}
+
+int map_mux_id_to_ipv4(
+        sGobiUSBNet *pDev,
+        unsigned long arg
+        )
+{
+    int idx;
+    int status;
+    sQMuxIPTable table;
+    if (arg == 0)
+    {
+        DBG( "Bad IP Table IOCTL buffer\n" );
+        return -EINVAL;
+    }
+    status = copy_from_user( &table, (void*)arg, sizeof(table) );
+    if (status != 0)
+    {
+        DBG( "Unable to copy data from userspace %d\n", status );
+        return -EINVAL;
+    }
+
+    idx = table.instance - MUX_ID_START;
+
+    /* a little bit difference between sQMuxIPTable and arg, arg passed from user space is mux id 
+       and ip address, but instance of sQMuxIPTable is the index from 0 to MAX_MUX_NUMBER_SUPPORTED-1,
+       so the difference is the MUX_ID_START offset */
+    if (
+            ( idx >= MAX_MUX_NUMBER_SUPPORTED ) ||
+            ( idx < 0 )
+       )
+    {
+        DBG( "invalid indexing muxid to ipv4 table: %d\n", idx);
+        return -EINVAL;
+    }
+
+    pDev->qMuxIPTable[idx].instance = idx;
+    if ( table.ipAddress == 0 )
+    {
+        pDev->qMuxIPTable[idx].ipAddress = 0;
+    }
+    else if ( table.ipAddress > 0 )
+    {
+        pDev->qMuxIPTable[idx].ipAddress= table.ipAddress;
+    }
+
+    DBG(" Set IP Address Mux ID : 0x%02x\n", table.instance);
+    PrintIPAddr( "Set IP Address : ", table.ipAddress);
+    return 0;
+}
+
+int iIsZeroIPv6Addr(ipv6_addr *pAddr)
+{
+   if(pAddr)
+   {
+      int i = 0;
+      for(i=0;i<IPV6_ADDR_LEN;i++)
+      {
+         if(pAddr->ipv6addr[i]!=0)
+            return 0;
+      }
+   }
+   return 1;
+}
+
+int map_mux_id_to_ipv6(
+   sGobiUSBNet *pDev,
+   unsigned long arg )
+{
+    int idx;
+    int status;
+    sQMuxIPTable table;
+    if (arg == 0)
+    {
+        DBG( "Bad IP Table IOCTL buffer\n" );
+        return -EINVAL;
+    }
+    status = copy_from_user( &table, (void*)arg, sizeof(table) );
+    if (status != 0)
+    {
+        DBG( "Unable to copy data from userspace %d\n", status );
+        return -EINVAL;
+    }
+
+    idx = table.instance - MUX_ID_START;
+
+    /* a little bit difference between sQMuxIPTable and arg, arg passed from user space is mux id 
+       and ip address, but instance of sQMuxIPTable is the index from 0 to MAX_MUX_NUMBER_SUPPORTED-1,
+       so the difference is the MUX_ID_START offset */
+    if (
+            ( idx >= MAX_MUX_NUMBER_SUPPORTED ) ||
+            ( idx < 0 )
+       )
+    {
+        DBG( "invalid indexing muxid to ipv6 table: %d\n", idx);
+        return -EINVAL;
+    }
+
+    pDev->qMuxIPTable[idx].instance = idx;
+    if ( iIsZeroIPv6Addr(&table.ipV6Address)==1 )
+    {
+        memset(&pDev->qMuxIPTable[idx].ipV6Address , 0,sizeof(ipv6_addr));
+    }
+    else 
+    {
+        memcpy(&pDev->qMuxIPTable[idx].ipV6Address,&table.ipV6Address,sizeof(ipv6_addr));
+    }
+
+    NETDBG(" Set IP Address Mux ID : 0x%02x\n", table.instance);
+    PrintIPV6Addr( &table.ipV6Address);
+    return 0;
+}
+
+/*=========================================================================*/
+// Internal userspace wrappers
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   UserspaceunlockedIOCTL (Public Method)
+
+DESCRIPTION:
+   Internal wrapper for Userspace IOCTL interface
+
+PARAMETERS
+   pFilp        [ I ] - userspace file descriptor
+   cmd          [ I ] - IOCTL command
+   arg          [ I ] - IOCTL argument
+
+RETURN VALUE:
+   long - 0 for success
+          Negative errno for failure
+===========================================================================*/
+long UserspaceunlockedIOCTL(
+   struct file *     pFilp,
+   unsigned int      cmd,
+   unsigned long     arg ) 
+{
+   int j;
+   int result;
+   u32 devVIDPID;
+
+   sQMIFilpStorage * pFilpData = (sQMIFilpStorage *)pFilp->private_data;
+   unsigned long i_ino = -1;
+   
+   if (pFilpData == NULL)
+   {
+      DBG( "Bad file data\n" );
+      return -EBADF;
+   }
+   if(file_inode(pFilp) !=NULL)
+   {
+      i_ino = file_inode(pFilp)->i_ino;
+   }
+   else
+   {
+      DBG("File Inode Null %d\n",__LINE__);
+      return -EIO;
+   }
+   DBG( "%d (%d)i_ino:%lu cmd:%X iCount:%d\n",__LINE__ ,pFilpData->iInfNum,i_ino,cmd,pFilpData->iCount);
+   if(cmd==USBDEVFS_RESET)
+   {
+      DBG( "RESET 0\n" );
+      DBG( "%d (%d)i_ino:%lu cmd:%X\n",__LINE__ ,pFilpData->iInfNum,i_ino,cmd);
+      return 0;
+   }
+   if (IsDeviceValid( pFilpData->mpDev ) == false)
+   {
+      DBG( "Invalid device! Updating f_ops\n" );
+      return -ENXIO;
+   }
+   if(IsDeviceDisconnect(pFilpData->mpDev))
+   {
+      DBG( "Device Disconnected!\n" );
+      return -ENXIO;
+   }
+   if(pFilpData->mpDev->mbUnload)
+   {
+      DBG( "Unload:%s\n", __FUNCTION__);
+      return -ENXIO;
+   }
+
+   if(pFilpData->mDeviceInvalid==1)
+   {
+      DBG( "Clsoing.." );
+      gobi_filp_close(pFilp,NULL);
+      return -ENXIO;
+   }
+   if(pFilpData->iIsClosing==1)
+   {
+       DBG( "Invalid device! Updating f_ops\n" );
+       return -ENXIO;
+
+   }
+   if(pFilpData->mpDev->iIsClosing==1)
+   {
+      DBG( "Device Clsoing.." );
+      return -ENXIO;
+   }
+   pFilpData->pIOCTLTask = current;
+   switch (cmd)
+   {
+      case IOCTL_QMI_GET_SERVICE_FILE:
+         DBG( "Setting up QMI for service %lu\n", arg );
+         if ((u8)arg == 0)
+         {
+            DBG( "Cannot use QMICTL from userspace\n" );
+            return -EINVAL;
+         }
+
+         // Connection is already setup
+         if (pFilpData->mClientID !=  0xffff)
+         {
+            DBG( "Close the current connection before opening a new one\n" );
+            return -EBADR;
+         }
+
+         pFilpData->iSemID = __LINE__;
+         result = GetClientID( pFilpData->mpDev, (u8)arg ,&(pFilpData->mReadSem));
+         pFilpData->iSemID = -__LINE__;
+         mb();
+         if(IsDeviceDisconnect(pFilpData->mpDev))
+         {
+            DBG( "Device Disconnected!\n" );
+            return -ENXIO;
+         }
+         if (result < 0)
+         {
+            pFilpData->mDeviceInvalid = 1;
+            return result;
+         }
+         if(pFilpData->iIsClosing ==1)
+         {
+            return -ENXIO;
+         }
+         pFilpData->mClientID = (u16)result;
+         pFilpData->iReadSyncResult = 0;
+         mb();
+         return 0;
+         break;
+
+
+      case IOCTL_QMI_GET_DEVICE_VIDPID:
+         if (arg == 0)
+         {
+            DBG( "Bad VIDPID buffer\n" );
+            return -EINVAL;
+         }
+
+         // Extra verification
+         if (pFilpData->mpDev->mpNetDev == 0)
+         {
+            DBG( "Bad mpNetDev\n" );
+            return -ENOMEM;
+         }
+         if (pFilpData->mpDev->mpNetDev->udev == 0)
+         {
+            DBG( "Bad udev\n" );
+            return -ENOMEM;
+         }
+
+         devVIDPID = ((le16_to_cpu( pFilpData->mpDev->mpNetDev->udev->descriptor.idVendor ) << 16)
+                     + le16_to_cpu( pFilpData->mpDev->mpNetDev->udev->descriptor.idProduct ) );
+
+         result = copy_to_user( (unsigned int *)arg, &devVIDPID, 4 );
+         if (result != 0)
+         {
+            DBG( "Copy to userspace failure %d\n", result );
+         }
+
+         return result;
+
+         break;
+
+      case IOCTL_QMI_GET_DEVICE_MEID:
+         if (arg == 0)
+         {
+            DBG( "Bad MEID buffer\n" );
+            return -EINVAL;
+         }
+         result = copy_to_user( (unsigned int *)arg, &pFilpData->mpDev->mMEID[0], MAX_DEVICE_MEID_SIZE);
+         if (result != 0)
+         {
+            DBG( "Copy to userspace failure %d\n", result );
+         }
+
+         return result;
+
+         break;
+
+      case IOCTL_QMI_GET_SVC_VERSION_INFO:
+         if (arg == 0)
+         {
+            DBG( "Bad Svc Info buffer\n" );
+            return -EINVAL;
+         }
+         result = copy_to_user( (unsigned int *)arg, &pFilpData->mpDev->svcVersion[0], MAX_SVC_VERSION_SIZE);
+         if (result != 0)
+         {
+            DBG( "Copy to userspace failure %d\n", result );
+         }
+
+         return result;
+
+      case IOCTL_QMI_ADD_MAPPING:
+         {
+             sGobiUSBNet * pDev = pFilpData->mpDev;
+             sMapping *pmap = (sMapping*) arg;
+
+             DBG( "add mapping\n" );
+             if (arg == 0)
+             {
+                DBG( "null pointer\n" );
+                return -EINVAL;
+             }
+             DBG( "dscp, qos_id: 0x%x, 0x%x\n", pmap->dscp, pmap->qosId );
+
+             if ((MAX_DSCP_ID < pmap->dscp) && (UNIQUE_DSCP_ID != pmap->dscp))
+             {
+                 DBG( "Invalid DSCP value\n" );
+                 return -EINVAL;
+             }
+
+             //check for existing map
+             for (j=0;j<MAX_MAP;j++)
+             {
+                 if (pDev->maps.table[j].dscp == pmap->dscp)
+                 {
+                     DBG("mapping already exists at slot #%d\n", j);
+                     return -EINVAL;
+                 }
+             }
+
+             //check if this is a request to redirect all IP traffic to default bearer
+             if (UNIQUE_DSCP_ID == pmap->dscp)
+             {
+                 DBG("set slot (%d) to indicate IP packet redirection is needed\n", MAX_MAP-1);
+                 pDev->maps.table[MAX_MAP-1].dscp = UNIQUE_DSCP_ID;
+                 pDev->maps.table[MAX_MAP-1].qosId = pmap->qosId;
+                 pDev->maps.count++; 
+                 return 0;
+             }
+
+             //find free slot to hold new mapping
+             for(j=0;j<MAX_MAP-1;j++)
+             {
+                 if (pDev->maps.table[j].dscp == 0xff)
+                 {
+                     pDev->maps.table[j].dscp = pmap->dscp;
+                     pDev->maps.table[j].qosId = pmap->qosId;
+                     pDev->maps.count++; 
+                     return 0;
+                 }
+             }
+
+             DBG("no free mapping slot\n");
+             return -ENOMEM;
+         }
+         break;
+
+      case IOCTL_QMI_EDIT_MAPPING:
+         {
+             sGobiUSBNet * pDev = pFilpData->mpDev;
+
+             sMapping *pmap = (sMapping*) arg;
+             DBG( "edit mapping\n" );
+             if (arg == 0)
+             {
+                DBG( "null pointer\n" );
+                return -EINVAL;
+             }
+             DBG( "dscp, qos_id: 0x%x, 0x%x\n", pmap->dscp, pmap->qosId );
+
+             if ((MAX_DSCP_ID < pmap->dscp) && (UNIQUE_DSCP_ID != pmap->dscp))
+             {
+                 DBG( "Invalid DSCP value\n" );
+                 return -EINVAL;
+             }
+
+             for(j=0;j<MAX_MAP;j++)
+             {
+                 if (pDev->maps.table[j].dscp == pmap->dscp)
+                 {
+                     pDev->maps.table[j].qosId = pmap->qosId;
+                     return 0;
+                 }
+             }
+
+             DBG("no matching tos for edit mapping\n");
+             return -ENOMEM;
+         }
+         break;
+
+      case IOCTL_QMI_READ_MAPPING:
+         {
+             sGobiUSBNet * pDev = pFilpData->mpDev;
+
+             sMapping *pmap = (sMapping*) arg;
+             DBG( "read mapping\n" );
+             if (arg == 0)
+             {
+                DBG( "null pointer\n" );
+                return -EINVAL;
+             }
+
+             if ((MAX_DSCP_ID < pmap->dscp) && (UNIQUE_DSCP_ID != pmap->dscp))
+             {
+                 DBG( "Invalid DSCP value\n" );
+                 return -EINVAL;
+             }
+
+             for(j=0;j<MAX_MAP;j++)
+             {
+                 if (pDev->maps.table[j].dscp == pmap->dscp)
+                 {
+                     pmap->qosId = pDev->maps.table[j].qosId;
+                     DBG( "dscp, qos_id: 0x%x, 0x%x\n", pmap->dscp, pmap->qosId );
+
+                     result = copy_to_user( (unsigned int *)arg, &pDev->maps.table[j], sizeof(sMapping));
+                     if (result != 0)
+                     {
+                         DBG( "Copy to userspace failure %d\n", result );
+                     }
+
+                     return result;
+                 }
+             }
+
+             DBG("no matching tos for read mapping\n");
+             return -ENOMEM;
+         }
+         break;
+
+      case IOCTL_QMI_DEL_MAPPING:
+         {
+             sGobiUSBNet * pDev = pFilpData->mpDev;
+             sMapping *pmap = (sMapping*) arg;
+             DBG( "Delete mapping\n" );
+             if (arg == 0)
+             {
+                 DBG( "null pointer\n" );
+                 return -EINVAL;
+             }
+             DBG( "DSCP 0x%x\n", pmap->dscp );
+
+             if ((MAX_DSCP_ID < pmap->dscp) && (UNIQUE_DSCP_ID != pmap->dscp))
+             {
+                 DBG( "Invalid DSCP value\n" );
+                 return -EINVAL;
+             }
+
+             for(j=0;j<MAX_MAP;j++)
+             {
+                 if (pDev->maps.table[j].dscp == pmap->dscp)
+                 {
+                     // delete mapping table entry
+                     memset(&pDev->maps.table[j], 0xff, sizeof(pDev->maps.table[0]));
+                     if (pDev->maps.count) pDev->maps.count--; 
+                     return 0;
+                 }
+             }
+
+             DBG("no matching mapping slot\n");
+             return -ENOMEM;
+         }
+         break;
+
+      case IOCTL_QMI_CLR_MAPPING:
+         {
+             sGobiUSBNet * pDev = pFilpData->mpDev;
+             DBG( "Clear mapping\n" );
+             memset(pDev->maps.table, 0xff, sizeof(pDev->maps.table));
+             pDev->maps.count = 0; 
+             return 0;
+         }
+         break;
+
+#ifdef QOS_SIMULATE
+      case IOCTL_QMI_QOS_SIMULATE:
+         {
+             int result;
+             u8 supported = (u8)-1;
+             DBG( "simulate indication\n" );
+             u8 qos_support_ind[] = {
+                 0x01,0x15,0x00,0x80,0x04,0xFF,0x04,0x00,0x00,
+                 0x27,0x00,0x09,0x00,0x01,0x01,0x00,0x01,0x10,0x02,0x00,0x01,0x80
+             };
+             u8 qos_flow_activate_ind[] = {
+                 0x01,0x15,0x00,0x80,0x04,0xFF,0x04,0x00,0x00,
+                 0x26,0x00,0x09,0x00,0x01,0x06,0x00,0xDD,0xCC,0xBB,0xAA,0x01,0x01
+             };
+             u8 qos_flow_suspend_ind[] = {
+                 0x01,0x15,0x00,0x80,0x04,0xFF,0x04,0x00,0x00,
+                 0x26,0x00,0x09,0x00,0x01,0x06,0x00,0xDD,0xCC,0xBB,0xAA,0x02,0x02
+             };
+             u8 qos_flow_gone_ind[] = {
+                 0x01,0x15,0x00,0x80,0x04,0xFF,0x04,0x00,0x00,
+                 0x26,0x00,0x09,0x00,0x01,0x06,0x00,0xDD,0xCC,0xBB,0xAA,0x03,0x03
+             };
+             result = QMIQOSEventResp( qos_support_ind,
+                     sizeof(qos_support_ind));
+             result = QMIQOSEventResp( qos_flow_activate_ind,
+                     sizeof(qos_flow_activate_ind));
+             result = QMIQOSEventResp( qos_flow_suspend_ind,
+                     sizeof(qos_flow_suspend_ind));
+             result = QMIQOSEventResp( qos_flow_gone_ind,
+                     sizeof(qos_flow_gone_ind));
+             return 0;
+         }
+         break;
+#endif
+
+      case IOCTL_QMI_GET_TX_Q_LEN:
+         {
+
+             sGobiUSBNet * pDev = pFilpData->mpDev;
+
+             if (arg == 0)
+             {
+                 DBG( "Bad Tx Queue buffer\n" );
+                 return -EINVAL;
+             }
+
+             // Extra verification
+             if (pFilpData->mpDev->mpNetDev == 0)
+             {
+                 DBG( "Bad mpNetDev\n" );
+                 return -ENOMEM;
+             }
+             if (pFilpData->mpDev->mpNetDev->udev == 0)
+             {
+                 DBG( "Bad udev\n" );
+                 return -ENOMEM;
+             }
+
+             result = copy_to_user( (unsigned int *)arg, &pDev->tx_qlen, sizeof(pDev->tx_qlen) );
+             if (result != 0)
+             {
+                 DBG( "Copy to userspace failure %d\n", result );
+             }
+
+             return result;
+         }
+
+         break;
+
+      case IOCTL_QMI_DUMP_MAPPING:
+         {
+             sGobiUSBNet * pDev = pFilpData->mpDev;
+
+             DBG( "dump mapping\n" );
+             if (arg == 0)
+             {
+                DBG( "null pointer\n" );
+                return -EINVAL;
+             }
+
+             result = copy_to_user( (unsigned int *)arg, &pDev->maps.table[0], sizeof(pDev->maps.table));
+             if (result != 0)
+             {
+                 DBG( "Copy to userspace failure %d\n", result );
+             }
+             return result;
+         }
+
+      case IOCTL_QMI_GET_USBNET_STATS:
+         {
+             sGobiUSBNet * pDev = pFilpData->mpDev;
+             sNetStats netStats;
+             #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 4,12,0 ))
+             struct rtnl_link_stats64 Stats64;
+             struct rtnl_link_stats64 *pStats = &Stats64;
+             memset(&Stats64,0,sizeof(Stats64));
+             usbnet_get_stats64(pDev->mpNetDev->net,pStats); 
+             #else
+             struct net_device_stats * pStats = &(pDev->mpNetDev->net->stats);
+             #endif
+
+             if (arg == 0)
+             {
+                 DBG( "Bad usbnet statistic buffer\n" );
+                 return -EINVAL;
+             }
+
+             // Extra verification
+             if (pFilpData->mpDev->mpNetDev == 0)
+             {
+                 DBG( "Bad mpNetDev\n" );
+                 return -ENOMEM;
+             }
+
+             memset(&netStats,0,sizeof(netStats));
+             /* copy the value from struct net_device_stats to struct sNetStats */
+             netStats.rx_packets = pStats->rx_packets;
+             netStats.tx_packets = pStats->tx_packets;
+             netStats.rx_bytes = pStats->rx_bytes;
+             netStats.tx_bytes = pStats->tx_bytes;
+             netStats.rx_errors = pStats->rx_errors;
+             netStats.tx_errors = pStats->tx_errors;
+             netStats.rx_overflows = pStats->rx_fifo_errors;
+             netStats.tx_overflows = pStats->tx_fifo_errors;
+
+             result = copy_to_user( (unsigned int *)arg, &netStats, sizeof(sNetStats) );
+             if (result != 0)
+             {
+                 DBG( "Copy to userspace failure %d\n", result );
+             }
+
+             return result;
+         }
+
+         break;
+         case IOCTL_QMI_SET_DEVICE_MTU:
+         {
+             sGobiUSBNet *pDev = pFilpData->mpDev;
+             // struct usbnet * pNet = netdev_priv( pDev->mpNetDev->net );
+             int iArgp = (int)arg;
+             if (iArgp <= 0)
+             {
+                 DBG( "Bad MTU buffer\n" );
+                 return -EINVAL;
+             }
+             DBG( "new mtu :%d ,qcqmi:%d\n",iArgp,(int)pDev->mQMIDev.qcqmi );
+             pDev->mtu = iArgp;
+             usbnet_change_mtu(pDev->mpNetDev->net ,pDev->mtu);
+         }
+         return 0;
+         case IOCTL_QMI_GET_QMAP_SUPPORT:
+         {
+            sGobiUSBNet *pDev = pFilpData->mpDev;
+
+            if (arg == 0)
+            {
+               DBG( "Bad QMAP IOCTL buffer\n" );
+               return -EINVAL;
+            }
+            result = copy_to_user( (unsigned int *)arg, &pDev->nRmnet, sizeof(pDev->nRmnet));
+            if (result != 0)
+            {
+               DBG( "Copy to userspace failure %d\n", result );
+            }
+            DBG( "nRmnet:%d\n",(int)pDev->nRmnet);
+            return result;
+          }
+         case IOCTL_QMI_SET_IP_ADDRESS:
+            return map_mux_id_to_ipv4(pFilpData->mpDev, arg);
+         case IOCTL_QMI_SET_IPV6_ADDRESS:
+            return map_mux_id_to_ipv6(pFilpData->mpDev, arg);
+         case IOCTL_QMI_GET_IPALIAS_MODE:
+            {
+                sGobiUSBNet *pDev = pFilpData->mpDev;
+                result = -1;
+                if (arg == 0)
+                {
+                   DBG( "Bad GET IP ALIAS IOCTL buffer\n" );
+                   return -EINVAL;
+                }
+                if(pDev->iQMUXEnable)
+                {
+                    result = copy_to_user( (unsigned int *)arg, &pDev->iIPAlias, sizeof(pDev->iIPAlias));
+                    if (result != 0)
+                    {
+                       DBG( "Copy to userspace failure %d\n", result );
+                    }
+                    DBG( "iIPAlias:%d\n",(int)pDev->iIPAlias);
+                }
+                return result;
+            }
+      default:
+         return -EBADRQC;
+   }
+}
+
+/*=========================================================================*/
+// Userspace wrappers
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   UserspaceOpen (Public Method)
+
+DESCRIPTION:
+   Userspace open
+      IOCTL must be called before reads or writes
+
+PARAMETERS
+   pInode       [ I ] - kernel file descriptor
+   pFilp        [ I ] - userspace file descriptor
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for failure
+===========================================================================*/
+int UserspaceOpen(
+   struct inode *         pInode,
+   struct file *          pFilp )
+{
+   sQMIFilpStorage * pFilpData;
+   sQMIDev * pQMIDev = NULL;
+   sGobiUSBNet * pDev = NULL;
+   static int count = 0;
+   //DBG( "\n" );
+   // Optain device pointer from pInode
+   if(signal_pending(current))
+   {
+      return -ERESTARTSYS;
+   }
+   pQMIDev = container_of( pInode->i_cdev,
+                                     sQMIDev,
+                                     mCdev );
+   pDev = container_of( pQMIDev,
+                                    sGobiUSBNet,
+                                    mQMIDev );
+   if(signal_pending(current))
+   {
+      return -ERESTARTSYS;
+   }
+   pFilp->private_data = NULL;
+
+   if (IsDeviceValid( pDev ) == false) 
+   {
+      printk( KERN_INFO "Invalid device\n" );
+      return -ENXIO;
+   }
+   if(IsDeviceDisconnect(pDev))
+   {
+      DBG( "Device Disconnected!\n" );
+      return -ENXIO;
+   }
+   if(pDev->mbUnload)
+   {
+       printk( KERN_INFO "Unload:%s\n", __FUNCTION__);
+      return -ENXIO;
+   }
+   if(pDev->iIsClosing)
+   {
+     printk( KERN_INFO "Unload:%s\n", __FUNCTION__);
+      return -ENXIO;
+   }
+   // Setup data in pFilp->private_data
+   pFilp->private_data = kmalloc( sizeof( sQMIFilpStorage ), GOBI_GFP_KERNEL );
+   if (pFilp->private_data == NULL)
+   {
+      printk( KERN_INFO "Mem error\n" );
+      return -ENOMEM;
+   }
+
+   pFilpData = (sQMIFilpStorage *)pFilp->private_data;
+   pFilpData->mClientID =  0xffff;
+   pFilpData->mDeviceInvalid = 0;
+   pFilpData->mpDev = pDev;
+   pFilpData->iSemID = -1;
+   pFilpData->iIsClosing = 0;
+   pFilpData->iReadSyncResult = -1;
+   pFilpData->iInfNum = pDev->mpIntf->cur_altsetting->desc.bInterfaceNumber;
+   pFilpData->iCount = count++;
+   pFilpData->pOpenTask = current;
+   pFilpData->pReadTask = current;
+   pFilpData->pWriteTask = current;
+   pFilpData->pIOCTLTask = current;
+   sema_init(&pFilpData->mReadSem , SEMI_INIT_DEFAULT_VALUE );
+   mb();
+   if(file_inode(pFilp)!=NULL)
+   {
+      DBG( "%d CID:0x%x, (%d)i_ino:%lu icount:%d\n",__LINE__ ,pFilpData->mClientID,pFilpData->iInfNum,file_inode(pFilp)->i_ino,pFilpData->iCount);
+   }
+   else
+   {
+      DBG( "%d CID:0x%x, (%d)i_ino:NULL icount:%d\n",__LINE__ ,pFilpData->mClientID,pFilpData->iInfNum,pFilpData->iCount);  
+   }
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   UserspaceIOCTL (Public Method)
+
+DESCRIPTION:
+   Userspace IOCTL functions
+
+PARAMETERS
+   pUnusedInode [ I ] - (unused) kernel file descriptor
+   pFilp        [ I ] - userspace file descriptor
+   cmd          [ I ] - IOCTL command
+   arg          [ I ] - IOCTL argument
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for failure
+===========================================================================*/
+int UserspaceIOCTL(
+   struct inode *    pUnusedInode,
+   struct file *     pFilp,
+   unsigned int      cmd,
+   unsigned long     arg ) 
+{
+   int ret = 0;
+   unsigned long  i_ino = -1;
+   if(signal_pending(current))
+   {
+      return -ERESTARTSYS;
+   }
+   // call the internal wrapper function
+   
+   if(file_inode(pFilp)!=NULL)
+      i_ino = file_inode(pFilp)->i_ino;
+   DBG("%d i_ino:%lu",__LINE__,i_ino);
+   ret = (int)UserspaceunlockedIOCTL( pFilp, cmd, arg );
+   if(file_inode(pFilp)!=NULL)
+   DBG("%d i_ino:%lu ret:%d",__LINE__,i_ino,ret);
+   return ret;
+}
+
+/*===========================================================================
+METHOD:
+   UserspaceClose (Public Method)
+
+DESCRIPTION:
+   Userspace close
+      Release client ID and free memory
+
+PARAMETERS
+   pFilp           [ I ] - userspace file descriptor
+   unusedFileTable [ I ] - (unused) file table
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for failure
+===========================================================================*/
+int UserspaceClose(
+   struct file *       pFilp,
+   fl_owner_t          unusedFileTable )
+{
+   sQMIFilpStorage * pFilpData = NULL;
+   u16 u16ClientID = 0xFFFF;
+   unsigned long i_ino = -1;
+   int iInfNum, iCount;
+   struct task_struct *pOpenTask = NULL;
+   struct task_struct *pReadTask = NULL;
+   struct task_struct *pWriteTask = NULL;
+   struct task_struct *pIOCTLTask = NULL;
+   pid_t pid = -1;
+   int iTimeout = 0;
+   int iFile_count = 0;
+   long refcnt = 0;
+   mb();
+   if(pFilp ==NULL)
+   {
+      printk( KERN_INFO "bad file data\n" );
+      return -EBADF;
+   }
+   refcnt = atomic_long_read(&pFilp->f_count);
+   if (refcnt > 1)
+   {
+      if(current->exit_signal!=SIGCHLD)
+      {
+          if((IsOtherTaskUsingFilp(pFilp) ==1)&&
+                (IsOpenTaskIsCurrent(pFilp)||
+                 IsCurrentTaskExit()))
+          {
+             DBG( "f_count %ld - ignoring close\n", refcnt);
+             return -EBUSY;
+          }
+      }
+      else
+      {
+         DBG( "SIGCHLD %ld \n", refcnt);
+         if(!IsOpenTaskIsCurrent(pFilp))
+         {
+            DBG( "f_count %ld - ignoring close\n", refcnt);
+            return -EBUSY;
+         }
+      }
+      DBG("f_count %ld - close %d %d\n", refcnt,IsOtherTaskUsingFilp(pFilp),IsOpenTaskIsCurrent(pFilp));
+   }
+   pFilpData = (sQMIFilpStorage *)pFilp->private_data;
+   if (pFilpData == NULL)
+   {
+      printk( KERN_INFO "bad file data private \n" );
+      return -EBADF;
+   }
+   if (IsDeviceValid( pFilpData->mpDev ) == false)
+   {
+      printk( KERN_INFO "%s Invalid device! Updating f_ops\n",__FUNCTION__ );
+   }
+   wait_interrupt();
+   if(pFilpData->iIsClosing==1)
+   {
+      u16ClientID = pFilpData->mClientID;
+      iInfNum = pFilpData->iInfNum;
+      iCount = pFilpData->iCount;
+      iFile_count = file_count(pFilp);
+      pOpenTask = pFilpData->pOpenTask;
+      pReadTask = pFilpData->pReadTask;
+      pWriteTask = pFilpData->pWriteTask;
+      pIOCTLTask = pFilpData->pIOCTLTask;
+      if(file_inode(pFilp)!=NULL)
+      {
+         i_ino = file_inode(pFilp)->i_ino;
+      }
+      else
+      {
+         DBG("File Inode Null %d\n",__LINE__);
+         return 0;
+      }
+      if(pFilpData->pOpenTask!=NULL)
+      {
+         pid = pFilpData->pOpenTask->pid;
+      }
+      DBG( "%d CID:0x%x, (%d)i_ino:%lu, icount:%d pid:%d, iFile_count:%d\n",__LINE__ ,u16ClientID,iInfNum,i_ino,iCount,pid,iFile_count);
+      if(pWriteTask!=pOpenTask)
+      {
+         wakeup_target_process(pWriteTask);
+         wait_interrupt();
+      }
+      if(pReadTask!=pOpenTask)
+      {
+         wakeup_target_process(pReadTask);
+         wait_interrupt();
+      }
+      if(pIOCTLTask!=pOpenTask)
+      {
+         wakeup_target_process(pIOCTLTask);
+         wait_interrupt();
+      }
+      if(pOpenTask!=current)
+      {
+         wakeup_target_process(pOpenTask);
+         wait_interrupt();
+         do
+         {
+            wait_ms(100);
+            mb();
+            if(pFilp==NULL)
+            {
+               return 0;
+            }
+            if(pFilp->private_data ==NULL)
+            {
+               return 0;
+            }
+            if(iTimeout++>5)
+            {
+               DBG( "%d CID:0x%x, (%d)i_ino:%lu, icount:%d pid:%d timeout\n",__LINE__ ,u16ClientID,iInfNum,i_ino,iCount,pid);
+               break;
+            }
+            if(iFile_count!=file_count(pFilp))
+            {
+               DBG( "%d CID:0x%x, (%d)i_ino:%lu, icount:%d pid:%d count:%d/%d\n",__LINE__ ,u16ClientID,iInfNum,i_ino,iCount,pid,iFile_count,(int)file_count(pFilp));
+               break;
+            
+            }
+            else if(file_count(pFilp)==0)
+            {
+               DBG( "%d CID:0x%x, (%d)i_ino:%lu, icount:%d pid:%d count==0\n",__LINE__ ,u16ClientID,iInfNum,i_ino,iCount,pid);
+               break;
+            }
+            
+         }while(pFilpData!=NULL);
+         DBG( "%d CID:0x%x, (%d)i_ino:%lu, icount:%d pid:%d return\n",__LINE__ ,u16ClientID,iInfNum,i_ino,iCount,pid);
+      }
+   }
+   
+   pFilpData->iIsClosing = 1;
+   pFilpData->mDeviceInvalid = 1;
+   mb();
+   u16ClientID = pFilpData->mClientID;
+   iInfNum = pFilpData->iInfNum;
+   iCount = pFilpData->iCount;
+   pOpenTask = pFilpData->pOpenTask;
+   pReadTask = pFilpData->pReadTask;
+   pWriteTask = pFilpData->pWriteTask;
+   pIOCTLTask = pFilpData->pIOCTLTask;
+   if(file_inode(pFilp)!=NULL)
+   {
+      i_ino = file_inode(pFilp)->i_ino;
+   }
+   else
+   {
+      DBG("File Inode Null %d\n",__LINE__);
+      return 0;
+   }
+   GobiSyncRcu();
+
+   DBG( "%d CID:0x%x, (%d)i_ino:%lu, icount:%d\n",__LINE__ ,u16ClientID,iInfNum,i_ino,iCount);
+   if( ((pFilpData->iSemID > 0) && (pFilpData->mClientID != 0xffff) ) ||
+       ((pFilpData->pOpenTask != pFilpData->pIOCTLTask )&&(pFilpData->iSemID > 0)) )
+   {
+      int iRetry = 0;
+      int iReturn = 0;
+      int iLockCount = 0;
+      if(pFilpData->mpDev->mbUnload)
+      {
+         iReturn = -EAGAIN;
+      }
+      
+      while(pFilpData->iSemID > 0)
+      {
+          GobiSyncRcu();
+          if(!pOpenTask)
+          {
+             break;
+          }
+          if((signal_pending(current))||(signal_pending(pOpenTask)))
+          {
+            DBG( "%d wait next\n",__LINE__ );
+            break;
+          }
+          if(LocalClientMemLockSpinIsLock(pFilpData->mpDev)!=0)
+          {
+             if(pFilpData->mpDev->mQMIDev.pTask!=NULL)
+             {
+                wakeup_target_process(pFilpData->mpDev->mQMIDev.pTask);
+                wait_interrupt();
+             }
+             if(iLockCount++ > 10)
+             {
+                DBG("locked!");
+                return -EAGAIN;
+             }
+             else
+             {
+                gobi_flush_work();
+                wait_ms(100);
+                continue;
+             }
+          }
+          iLockCount = 0;
+          mb();
+          if((pFilpData==NULL) || (pFilp==NULL))
+          {
+            iReturn = 0;
+            break;
+          }
+          barrier();
+          if(!down_trylock(&(pFilpData->mReadSem)))
+          {
+              DBG("NOT locked : %d",pFilpData->iSemID);
+              barrier();
+              up(&(pFilpData->mReadSem));
+              pFilpData->iSemID = -1;
+              mb();
+              break;
+          }
+          barrier();
+          up(&(pFilpData->mReadSem));
+          if((signal_pending(current))||(signal_pending(pOpenTask)))
+          {
+            DBG( "%d wait next\n",__LINE__ );
+            break;
+          }
+          if(pWriteTask!=NULL)
+          {
+              wakeup_target_process(pWriteTask);
+          }
+          if(pReadTask!=NULL)
+          {
+             wakeup_target_process(pReadTask);
+          }
+          wakeup_inode_process(pFilp,pOpenTask);
+          if((pFilpData==NULL) || (pFilp==NULL))
+          {
+             iReturn = 0;
+             DBG( "%d NULL\n",__LINE__ );
+             break;
+          }
+          if(iRetry++>10)
+          {
+              iReturn = -EAGAIN;
+              printk("Timeout!");
+              return iReturn;
+          }
+          wait_ms(500);
+      };
+      GobiSyncRcu();
+   } 
+
+   if(pFilpData->mpDev->mbUnload)
+   {
+      if(pOpenTask==current)
+      {
+         wait_interrupt();
+         kfree( pFilp->private_data );
+         pFilp->private_data = NULL;
+         GobiSyncRcu();
+         mb();
+      }
+      return 0;
+   }
+
+   if (pFilpData->mpDev->mbUnload > eStatUnloading)
+   {
+      if(pOpenTask==current)
+      {
+         wait_interrupt();
+         kfree( pFilp->private_data );
+         pFilp->private_data = NULL;
+         GobiSyncRcu();
+         mb();
+      }
+      return 0;
+   }
+   
+   DBG( "CID 0x%04X\n", u16ClientID );
+
+   if (pFilpData->mClientID !=  0xffff) 
+   {
+     pFilpData->iSemID = __LINE__;
+     if ( (pFilpData->iReadSyncResult>=0) && 
+         (pFilpData->mpDev->mbUnload < eStatUnloading) &&
+         !IsDeviceDisconnect(pFilpData->mpDev))
+     {
+          DBG( "Release CID 0x%04X\n", u16ClientID );
+          ReleaseClientID( pFilpData->mpDev,
+                      pFilpData->mClientID);
+     }
+     else
+     {
+         unsigned long flags;
+         flags = LocalClientMemLockSpinLockIRQSave( pFilpData->mpDev , __LINE__);
+         RemoveAndPopNotifyList(pFilpData->mpDev,
+                      pFilpData->mClientID,0,eClearAndReleaseCID);
+         LocalClientMemUnLockSpinLockIRQRestore ( pFilpData->mpDev ,flags,__LINE__);
+         
+     }
+     pFilpData->iSemID = -__LINE__;
+     mb();
+     pFilpData->mClientID =  0xffff;
+   }
+   wait_interrupt();
+   kfree( pFilp->private_data );
+
+   // Disable pFilpData so they can't keep sending read or write
+   //    should this function hang
+   // Note: memory pointer is still saved in pFilpData to be deleted later
+   pFilp->private_data = NULL;
+   GobiSyncRcu();
+   mb();
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   UserspaceRead (Public Method)
+
+DESCRIPTION:
+   Userspace read (synchronous)
+
+PARAMETERS
+   pFilp           [ I ] - userspace file descriptor
+   pBuf            [ I ] - read buffer
+   size            [ I ] - size of read buffer
+   pUnusedFpos     [ I ] - (unused) file position
+
+RETURN VALUE:
+   ssize_t - Number of bytes read for success
+             Negative errno for failure
+===========================================================================*/
+ssize_t UserspaceRead(
+   struct file *          pFilp,
+   char __user *          pBuf,
+   size_t                 size,
+   loff_t *               pUnusedFpos )
+{
+   int result = -1;
+   void * pReadData = NULL;
+   void * pSmallReadData = NULL;
+   sQMIFilpStorage * pFilpData = NULL;
+   int iCount = -1;
+   //DBG("\n");
+   if(pFilp==NULL)
+   {
+       return -EBADF;
+   }
+   pFilpData = (sQMIFilpStorage *)pFilp->private_data;
+   if (pFilpData == NULL)
+   {
+      DBG( "Bad file data\n" );
+      return -EBADF;
+   }
+
+   if(signal_pending(current))
+   {
+      return -ERESTARTSYS;
+   }
+
+   if (IsDeviceValid( pFilpData->mpDev ) == false)
+   {
+      DBG( "Invalid device! Updating f_ops\n" );
+      return -ENXIO;
+   }
+   if(IsDeviceDisconnect(pFilpData->mpDev))
+   {
+      DBG( "Device Disconnected!\n" );
+      return -ENXIO;
+   }
+   if(pFilpData->mpDev->mbUnload)
+   {
+      DBG( "Unload:%s\n", __FUNCTION__);
+      return -ENXIO;
+   }
+
+   if(pFilpData->mDeviceInvalid)
+   {
+      DBG( "mDeviceInvalid\n");
+      return -ENXIO;
+   }
+   
+   if (pFilpData->mClientID ==  0xffff)
+   {
+      DBG( "Client ID must be set before reading 0x%04X\n",
+           pFilpData->mClientID );
+      return -EBADR;
+   }
+   if(pFilpData->iIsClosing==1)
+   {
+      DBG( "filep Clsoing.." );
+      return -ENXIO;
+   }
+   
+   if(pFilpData->mpDev->iIsClosing==1)
+   {
+      DBG( "Device Clsoing.." );
+      return -ENXIO;
+   }
+   iCount = pFilpData->iCount;
+   pFilpData->pReadTask = current;
+
+   pFilpData->iSemID = __LINE__;
+   // Perform synchronous read
+   result = ReadSync( pFilpData->mpDev,
+                      &pReadData,
+                      pFilpData->mClientID,
+                      0,
+                      &(pFilpData->iSemID),&(pFilpData->mReadSem),&(pFilpData->iIsClosing));
+   if(pFilp==NULL)
+   {
+      DBG("%s pFilp NULL\n",__FUNCTION__);
+      return -ENXIO;
+   }
+   if(pFilpData==NULL)
+   {
+      return -ENXIO;
+   }
+   pFilpData->iSemID = -__LINE__;
+   mb();
+   GobiSyncRcu();
+   if(result<0)
+   {
+      if(file_inode(pFilp)!=NULL)
+      {
+      DBG("Read Error!CID:0x%04x, (%d)i_ino:%lu iCount:%d\n",pFilpData->mClientID,pFilpData->iInfNum, file_inode(pFilp)->i_ino,iCount);
+      }
+      else
+      {
+         DBG("Read Error!CID:0x%04x, (%d)i_ino:NULL iCount:%d\n",pFilpData->mClientID,pFilpData->iInfNum,iCount);
+         DBG("File Inode Null %d\n",__LINE__);
+         return -ENXIO;
+      }
+   }
+   else
+   {
+      PrintHex(pReadData,result);
+   }
+   if(pFilp==NULL)
+   {
+      DBG("%s pFilp NULL\n",__FUNCTION__);
+      return -ENXIO;
+   }
+   if(pFilpData->mpDev==NULL)
+   {
+      DBG("%s pFilp NULL\n",__FUNCTION__);
+      return -ENXIO;
+   }
+   if(IsDeviceDisconnect(pFilpData->mpDev))
+   {
+      DBG( "Device Disconnected!\n" );
+      return -ENXIO;
+   }
+   if((pFilpData->mpDev->mbUnload)||(pFilpData->iIsClosing))
+   {
+      return -ENXIO;
+   }
+   if (result <= 0)
+   {
+      #ifdef CONFIG_PM
+      if(bIsSuspend(pFilpData->mpDev))
+      {
+         DBG("SUSPEND\n");
+      }
+      #endif
+      if(result == -EINTR)
+      {
+         DBG("RETRY\n");
+      }
+      return result;
+   }
+
+   // Discard QMUX header
+   result -= QMUXHeaderSize();
+   pSmallReadData = pReadData + QMUXHeaderSize();
+
+   if (result > size)
+   {
+      DBG( "Read data is too large for amount user has requested\n" );
+      if(pReadData)
+      kfree( pReadData );
+      return -EOVERFLOW;
+   }
+
+   DBG(  "pBuf = 0x%p pSmallReadData = 0x%p, result = %d",
+         pBuf, pSmallReadData, result );
+
+   if (copy_to_user( pBuf, pSmallReadData, result ) != 0)
+   {
+      DBG( "Error copying read data to user\n" );
+      result = -EFAULT;
+   }
+   pSmallReadData = NULL;
+   // Reader is responsible for freeing read buffer
+   kfree( pReadData );
+
+   return result;
+}
+
+/*===========================================================================
+METHOD:
+   UserspaceWrite (Public Method)
+
+DESCRIPTION:
+   Userspace write (synchronous)
+
+PARAMETERS
+   pFilp           [ I ] - userspace file descriptor
+   pBuf            [ I ] - write buffer
+   size            [ I ] - size of write buffer
+   pUnusedFpos     [ I ] - (unused) file position
+
+RETURN VALUE:
+   ssize_t - Number of bytes read for success
+             Negative errno for failure
+===========================================================================*/
+ssize_t UserspaceWrite(
+   struct file *        pFilp,
+   const char __user *  pBuf,
+   size_t               size,
+   loff_t *             pUnusedFpos )
+{
+   int status;
+   void * pWriteBuffer;
+   sQMIFilpStorage * pFilpData = (sQMIFilpStorage *)pFilp->private_data;
+
+   if (pFilpData == NULL)
+   {
+      DBG( "Bad file data\n" );
+      return -EBADF;
+   }
+   if(signal_pending(current))
+   {
+      return -ERESTARTSYS;
+   }
+   pFilpData->pWriteTask = current;
+   
+   if (IsDeviceValid( pFilpData->mpDev ) == false)
+   {
+      DBG( "Invalid device! Updating f_ops\n" );
+      return -ENXIO;
+   }
+   if(IsDeviceDisconnect(pFilpData->mpDev))
+   {
+      DBG( "Device Disconnected!\n" );
+      return -ENXIO;
+   }
+   if(pFilpData->mpDev->mbUnload)
+   {
+      DBG( "Unload:%s\n", __FUNCTION__);
+      return -ENXIO;
+   }
+
+   if(pFilpData->mDeviceInvalid)
+   {
+      DBG( "mDeviceInvalid\n");
+      gobi_filp_close(pFilp,NULL);
+      return -ENXIO;
+   }
+
+   if (pFilpData->mClientID ==  0xffff)
+   {
+      DBG( "Client ID must be set before writing 0x%04X\n",
+           pFilpData->mClientID );
+      return -EBADR;
+   }
+   if(pFilpData->iIsClosing==1)
+   {
+      DBG( "Filep Clsoing.." );
+      return -ENXIO;
+   }
+   if(pFilpData->mpDev->iIsClosing==1)
+   {
+      DBG( "Device Clsoing.." );
+      return -ENXIO;
+   }
+
+   // Copy data from user to kernel space
+   pWriteBuffer = kmalloc( size + QMUXHeaderSize(), GOBI_GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+   status = copy_from_user( pWriteBuffer + QMUXHeaderSize(), pBuf, size );
+   if (status != 0)
+   {
+      DBG( "Unable to copy data from userspace %d\n", status );
+      kfree( pWriteBuffer );
+      return status;
+   }
+
+   status = WriteSync( pFilpData->mpDev,
+                       pWriteBuffer,
+                       size + QMUXHeaderSize(),
+                       pFilpData->mClientID );
+
+   kfree( pWriteBuffer );
+   if(pFilpData!=NULL)
+   if(IsDeviceDisconnect(pFilpData->mpDev))
+   {
+      DBG( "Device Disconnected!\n" );
+      return -ENXIO;
+   }
+   // On success, return requested size, not full QMI reqest size
+   if (status == size + QMUXHeaderSize())
+   {
+      return size;
+   }
+   else
+   {
+      pFilpData->mDeviceInvalid = 1;
+      if(status<0)
+      {
+         pFilpData->iIsClosing=1;
+         return -ENXIO;
+      }
+      return status;
+   }
+}
+
+/*===========================================================================
+METHOD:
+   UserspacePoll (Public Method)
+
+DESCRIPTION:
+   Used to determine if read/write operations are possible without blocking
+
+PARAMETERS
+   pFilp              [ I ] - userspace file descriptor
+   pPollTable         [I/O] - Wait object to notify the kernel when data 
+                              is ready
+
+RETURN VALUE:
+   unsigned int - bitmask of what operations can be done immediately
+===========================================================================*/
+unsigned int UserspacePoll(
+   struct file *                  pFilp,
+   struct poll_table_struct *     pPollTable )
+{
+   sQMIFilpStorage * pFilpData = (sQMIFilpStorage *)pFilp->private_data;
+   sClientMemList * pClientMem;
+   unsigned long flags;
+
+   // Always ready to write
+   unsigned int status = POLLOUT | POLLWRNORM;
+
+   if (pFilpData == NULL)
+   {
+      DBG( "Bad file data\n" );
+      return POLLERR;
+   }
+
+   if (IsDeviceValid( pFilpData->mpDev ) == false)
+   {
+      DBG( "Invalid device! Updating f_ops\n" );
+      return POLLERR;
+   }
+
+   if (pFilpData->mClientID ==  0xffff)
+   {
+      DBG( "Client ID must be set before polling 0x%04X\n",
+           pFilpData->mClientID );
+      return POLLERR;
+   }
+   if(IsDeviceDisconnect(pFilpData->mpDev))
+   {
+      DBG( "Device Disconnected!\n" );
+      return -ENXIO;
+   }
+   // Critical section
+   flags = LocalClientMemLockSpinLockIRQSave( pFilpData->mpDev , __LINE__);
+
+   // Get this client's memory location
+   pClientMem = FindClientMem( pFilpData->mpDev, 
+                              pFilpData->mClientID );
+   if (pClientMem == NULL)
+   {
+      DBG( "Could not find this client's memory 0x%04X\n",
+           pFilpData->mClientID );
+
+      LocalClientMemUnLockSpinLockIRQRestore ( pFilpData->mpDev ,flags,__LINE__);
+      return POLLERR;
+   }
+   if (ClientTransactionIDExist(pFilpData->mpDev,
+                           pClientMem->mClientID,
+                           0)==0)
+   {
+      if (AddToNotifyList( pFilpData->mpDev,
+                           pClientMem->mClientID,
+                           0,
+                           NULL,
+                           NULL ) == false)
+      {
+         LocalClientMemUnLockSpinLockIRQRestore ( pFilpData->mpDev ,flags,__LINE__);
+         return POLLERR;
+      }
+   }
+   else
+   {
+       DBG("SKIP AddToNotifyList\n");
+   }
+
+   poll_wait( pFilp, &pClientMem->mWaitQueue, pPollTable );
+
+   if (pClientMem->mpList != NULL)
+   {
+      status |= POLLIN | POLLRDNORM;
+   }
+
+   // End critical section
+   LocalClientMemUnLockSpinLockIRQRestore ( pFilpData->mpDev ,flags,__LINE__);
+
+   // Always ready to write 
+   return (status | POLLOUT | POLLWRNORM);
+}
+
+void gobi_try_wake_up_process(struct task_struct *pTask)
+{
+   int count = 0;
+   if(pTask==NULL)
+      return ;
+   if(pTask==current)
+      return ;
+   if(wait_preempt()==0)
+      return ;
+   #if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)
+   while(raw_spin_is_locked(&pTask->pi_lock))
+   #endif
+   {
+      if(count++>10)
+      {
+         DBG( "task Locked %d\n",__LINE__ );
+         return ;
+      }
+      msleep_interruptible(100);
+      mb();
+      if(pTask==NULL)
+            return;
+      if(signal_pending(pTask))
+      return ;
+   }
+   DBG( "%d pid:%d\n",__LINE__,pTask->pid );
+   wake_up_process(pTask);
+}
+
+int wakeup_inode_process(struct file *pFilp,struct task_struct * pTask)
+{
+   struct task_struct *pEachTask=NULL;
+   #if _SIG_LOCK_
+   struct sighand_struct *sighand;
+   #endif
+   unsigned long i_no =-1;
+   int iFound =0;
+   struct list_head *list;
+   mb();
+   if(pFilp==NULL)
+      return 0;
+   if(file_inode(pFilp)!=NULL)
+   {
+      i_no = file_inode(pFilp)->i_ino;
+   }
+   else
+   {
+      DBG("File Inode Null %d\n",__LINE__);
+      return 0;
+   }
+   DBG( "%d i_ino:%lu\n",__LINE__ ,i_no);
+   if(!pTask)
+   {
+      DBG( "pTask NULL\n");
+      return 0;
+   }
+   if(signal_pending(pTask))
+   {
+      DBG("signal_pending %d\n",__LINE__);
+      return 0;
+   }
+   if(pTask)
+   {
+         #if _SIG_LOCK_
+         if(lockdep_tasklist_lock_is_held())
+         {
+            DBG( "lockdep_tasklist_lock_is_held %d\n",__LINE__ );
+         }
+         sighand = rcu_dereference_check(pTask->sighand,
+         lockdep_tasklist_lock_is_held());
+         if(sighand)
+         spin_lock_irq(&sighand->siglock);
+         else
+         {
+            DBG( "spin_lock %d\n",__LINE__ );
+            return 0;
+         }
+         #endif
+         if(pTask->state==TASK_STOPPED)
+         {
+            if (unlikely(pTask->signal->notify_count < 0))
+            {
+               int count = 0;
+               if(pTask!=current)
+               {
+                  gobi_try_wake_up_process(pTask);
+               }
+               list_for_each(list, &pTask->children)
+               {
+                  struct task_struct *task;
+                  task = list_entry(list, struct task_struct, sibling);
+                  if((task!=NULL)&&(task!=current))
+                  {
+                     gobi_try_wake_up_process(task);
+                  }
+               }
+               count++;
+               do{
+                  wait_ms(100);
+                  mb();
+                  if(count++>10)
+                     break;
+               }while(file_count(pFilp)>0);
+            }
+         }
+         else
+         {
+            DBG( "not wakeup %d\n",__LINE__ );
+         }
+         #if _SIG_LOCK_
+         if(sighand)
+         spin_unlock_irq(&sighand->siglock);
+         #endif
+         return 0;
+      
+   }
+   
+   if(pEachTask!=NULL)
+   {
+      int count =0;
+      if(pEachTask!=current)
+      gobi_try_wake_up_process(pEachTask);
+      do{
+         wait_ms(100);
+         mb();
+         if(count++>10)
+            break;
+      }while(file_count(pFilp)>0);
+   }
+
+   if(iFound==1)
+   {
+      DBG( "%d i_ino:%lu\n",__LINE__ ,i_no);
+      return 0;
+   }
+   barrier();
+   for_each_process( pEachTask )
+   {
+      int count = 0;
+      struct fdtable * pFDT;
+      if (pEachTask == NULL || pEachTask->files == NULL)
+      {
+         // Some tasks may not have files (e.g. Xsession)
+            continue;
+      }
+      pFDT = files_fdtable( pEachTask->files );
+      for (count = 0; count < pFDT->max_fds; count++)
+      {
+         if (pFDT->fd[count] == pFilp)
+         {
+            iFound = 1;
+            #if _SIG_LOCK_
+            if(lockdep_tasklist_lock_is_held())
+            {
+              DBG( "lockdep_tasklist_lock_is_held %d\n",__LINE__ );
+            }
+            sighand = rcu_dereference_check(pEachTask->sighand,
+            lockdep_tasklist_lock_is_held());
+            if(sighand)
+            spin_lock_irq(&sighand->siglock);
+            else
+            {
+              return 0;
+            }
+            #endif
+            if(pEachTask->state==TASK_STOPPED)//(pEachTask->state != TASK_STOPPED)
+            {
+              if (unlikely(pEachTask->signal->notify_count < 0))
+              {
+                 int count =0;
+                 if(pEachTask!=current)
+                 gobi_try_wake_up_process(pEachTask);
+                 list_for_each(list, &pEachTask->children)
+                 {
+                    struct task_struct *task;
+                    task = list_entry(list, struct task_struct, sibling);
+                    if((task!=NULL)&&(task!=current))
+                    {
+                       gobi_try_wake_up_process(task);
+                    }
+                 }
+                 do{
+                    wait_ms(100);
+                    mb();
+                    if(count++>10)
+                       break;
+                 }while(file_count(pFilp)>0);
+                 mb();
+              }
+            }
+            else
+            {
+              DBG( "not wakeup %d\n",__LINE__ );
+            }
+            #if _SIG_LOCK_
+            if(sighand)
+            spin_unlock_irq(&sighand->siglock);
+            #endif           
+            count = pFDT->max_fds;
+         }
+      }
+   }
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   UserSpaceLock (Public Method)
+
+DESCRIPTION:
+   Used to determine if read/write operations are possible without blocking
+
+PARAMETERS
+   pFilp      [ I ] - The file to apply the lock to
+   cmd        [ I ] - type of locking operation (F_SETLK, F_GETLK, etc.)
+   fl         [I/O] - The lock to be applied
+
+RETURN VALUE:
+   unsigned int - bitmask of what operations can be done immediately
+===========================================================================*/
+int UserSpaceLock(struct file *filp, int cmd, struct file_lock *fl)
+{
+   if((filp!=NULL) && (fl!=NULL))
+   {
+      #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,9,0 ))
+      if(file_inode(filp)!=NULL)
+      {
+         return posix_lock_file(filp, fl, NULL);
+      }
+      #else
+      return posix_lock_file(filp, fl, NULL);
+      #endif
+   }
+   return -ENOLCK;
+}
+
+/*===========================================================================
+METHOD:
+   UserspaceRelease (Public Method)
+
+DESCRIPTION:
+   Used to determine if read/write operations are possible without blocking
+
+PARAMETERS
+   pInode              [I/O] - userspace file descriptor
+   pFilp               [I/O] - userspace file descriptor
+   
+RETURN VALUE:
+   unsigned int - bitmask of what operations can be done immediately
+===========================================================================*/
+int UserspaceRelease(struct inode *pInode, struct file *pFilp)
+{
+   sQMIFilpStorage * pFilpData = NULL;
+   mb();
+   if(pFilp==NULL)
+   {
+      return 0;
+   }
+
+   pFilpData = (sQMIFilpStorage *)pFilp->private_data;
+   if(pFilpData!=NULL)
+   {
+     if(pFilp->private_data)
+     {
+       kfree(pFilp->private_data);
+       pFilp->private_data = NULL;
+     }
+   }
+   mb();
+   return 0;
+}
+/*=========================================================================*/
+// Initializer and destructor
+/*=========================================================================*/
+int QMICTLSyncProc(sGobiUSBNet *pDev)
+{
+   void *pWriteBuffer;
+   void *pReadBuffer;
+   int result;
+   u16 writeBufferSize;
+   u8 transactionID;
+   struct semaphore readSem;
+   unsigned long flags;
+   u16 readBufferSize;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return -EFAULT;
+   }
+   sema_init( &readSem, SEMI_INIT_DEFAULT_VALUE );
+   mb();
+   writeBufferSize= QMICTLSyncReqSize();
+   pWriteBuffer = kmalloc( writeBufferSize, GOBI_GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+
+   transactionID = QMIXactionIDGet(pDev);
+
+   /* send a QMI_CTL_SYNC_REQ (0x0027) */
+   result = QMICTLSyncReq( pWriteBuffer,
+                           writeBufferSize,
+                           transactionID );
+   if (result < 0)
+   {
+      if(pWriteBuffer)
+      {
+         kfree( pWriteBuffer );
+         pWriteBuffer = NULL;
+      }
+      return result;
+   }
+
+   result = ReadAsync( pDev, QMICTL, transactionID, UpSem, &readSem ,1);
+   if(result == 0)
+   {
+      result = WriteSync( pDev,
+                    pWriteBuffer,
+                    writeBufferSize,
+                    QMICTL );
+   }
+   if(pWriteBuffer)
+   {
+      kfree( pWriteBuffer );
+      pWriteBuffer = NULL;
+   }
+   if(result<0)
+   {
+      return result;
+   }
+   wait_control_msg_semaphore_timeout(&readSem,QMI_CONTROL_MAX_MSG_DELAY_MS);
+   mb();
+   // Enter critical section
+   flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+   spin_lock_irq(&(pDev->notif_lock));
+   barrier();
+   if (down_trylock( &readSem ) == 0)
+   {      
+      // Pop the read data
+      if (PopFromReadMemList( pDev,
+                              QMICTL,
+                              transactionID,
+                              &pReadBuffer,
+                              &readBufferSize ) == true)
+      {
+         spin_unlock_irq(&(pDev->notif_lock));
+         // End critical section
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         result = QMICTLSyncResp(pReadBuffer,
+                                               readBufferSize);
+         // We don't care about the result
+         if(pReadBuffer)
+         kfree( pReadBuffer );
+      }
+      else
+      {
+         // Read mismatch/failure, unlock and continue
+         RemoveAndPopNotifyList(pDev,QMICTL,0,eClearCID);
+         spin_unlock_irq(&(pDev->notif_lock));
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+      }
+   }
+   else
+   {
+      // Timeout, remove the async read
+      RemoveAndPopNotifyList(pDev,QMICTL,0,eClearCID);
+      spin_unlock_irq(&(pDev->notif_lock));
+      // End critical section
+      LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+      result = -1;
+   }
+
+   if (result < 0) /* need to re-sync */
+   {
+      DBG( "sync response error code %d\n", result );
+      /* start timer and wait for the response */
+      /* process response */
+      return result;
+   }
+
+   // Success
+   return 0;
+}
+
+static int 
+qmi_show(struct seq_file *m, void *v)
+{
+    sGobiUSBNet * pDev = (sGobiUSBNet*) m->private;
+    seq_printf(m, "readTimeoutCnt %d\n", pDev->readTimeoutCnt);
+    seq_printf(m, "writeTimeoutCnt %d\n", pDev->writeTimeoutCnt);
+    return 0;
+}
+
+static int
+qmi_open(struct inode *inode, struct file *file)
+{
+    char *data;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,10,0 ))
+    data=PDE_DATA(inode);
+#else
+    data=PDE(inode)->data;
+#endif
+
+    return single_open(file, qmi_show, data);
+}
+
+static const struct file_operations proc_fops = {
+    .owner      = THIS_MODULE,
+    .open       = qmi_open,
+    .read       = seq_read,
+    .llseek     = seq_lseek,
+    .release    = single_release,
+};
+
+/*===========================================================================
+METHOD:
+   RegisterQMIDevice (Public Method)
+
+DESCRIPTION:
+   QMI Device initialization function
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+   is9x15   [ I ]
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for failure
+===========================================================================*/
+int RegisterQMIDevice( sGobiUSBNet * pDev, int is9x15 )
+{
+   char qcqmi_dev_name[10];
+   int i;
+   int result;
+   dev_t devno;
+   pDev->mQMIDev.proc_file = NULL;
+   if (pDev->mQMIDev.mbCdevIsInitialized == true)
+   {
+      // Should never happen, but always better to check
+      DBG( "device already exists\n" );
+      return -EEXIST;
+   }
+
+   pDev->mbQMIValid = true;
+   pDev->mbUnload = eStatRegister;
+   pDev->mReleaseClientIDFail=0;
+   pDev->readTimeoutCnt = 0;
+   pDev->writeTimeoutCnt = 0;
+   pDev->mtu = 0;
+   pDev->iShutdown_write_sem = -1;
+   pDev->iShutdown_read_sem = -1;
+   init_rwsem(&pDev->shutdown_rwsem);
+   InitSemID(pDev);
+
+   i=0;
+   do
+   {
+      // Set up for QMICTL
+      //    (does not send QMI message, just sets up memory)
+      if(gobi_kthread_should_stop())
+      {
+         return -1;
+      }
+      
+      result = GetClientID( pDev, QMICTL ,NULL);
+
+      if(gobi_kthread_should_stop())
+      {
+         return -1;
+      }
+      
+      if(pDev->mbUnload != eStatRegister)
+      {
+         return result;
+      }
+      if (result != 0)
+      {
+         if(i++>MAX_RETRY)
+         {
+            pDev->mbQMIValid = false;
+            return result;
+         }
+      }
+   }while(result!=0);
+   atomic_set( &pDev->mQMIDev.mQMICTLTransactionID, 1 );
+
+   // Start Async reading
+   result = StartRead( pDev );
+   if (result != 0)
+   {
+      pDev->mbQMIValid = false;
+      return result;
+   }
+
+   // Send SetControlLineState request (USB_CDC)
+   //   Required for Autoconnect and 9x30 to wake up
+   result = Gobi_usb_control_msg(pDev->mpIntf, pDev->mpNetDev->udev,
+                             usb_sndctrlpipe( pDev->mpNetDev->udev, 0 ),
+                             SET_CONTROL_LINE_STATE_REQUEST,
+                             SET_CONTROL_LINE_STATE_REQUEST_TYPE,
+                             CONTROL_DTR,
+                             /* USB interface number to receive control message */
+                             pDev->mpIntf->cur_altsetting->desc.bInterfaceNumber,
+                             NULL,
+                             0,
+                             100 );
+   if (result < 0)
+   {
+      DBG( "Bad SetControlLineState status %d\n", result );
+      return result;
+   }
+
+
+   // Device is not ready for QMI connections right away
+   //   Wait up to 30 seconds before failing
+   result = QMIReady( pDev, 30000 );
+   if(result==-1)
+   {
+      pDev->mbUnload = eStatUnloading;
+      return -EFAULT;
+   }
+   else if (result == false)
+   {
+      DBG( "Device unresponsive to QMI\n" );
+      return -ETIMEDOUT;
+   }
+   if(pDev->mbUnload != eStatRegister)
+   {
+      return -EFAULT;
+   }
+   // Initiate QMI CTL Sync Procedure
+   DBG( "Sending QMI CTL Sync Request\n" );
+   i=0;
+   do
+   {
+      result = QMICTLSyncProc(pDev);
+      if(isModuleUnload(pDev))
+      {
+         return -EFAULT;;
+      }
+      if (result != 0)
+      {
+         if(i++>MAX_RETRY)
+         {
+            DBG( "QMI CTL Sync Procedure Error\n" );
+            return result;
+         }
+      }
+      else
+      {
+         DBG( "QMI CTL Sync Procedure Successful\n" );
+      }
+   }while(result!=0);
+   if(iTEEnable<eSKIP_TE_FLOW_CONTROL_TLV)
+   {
+      iTEEnable = eSKIP_TE_FLOW_CONTROL_TLV;
+   }
+   // Setup Data Format
+   if (is9x15)
+   {
+      i=0;
+      if (pDev->iQMUXEnable!=0)
+      {
+         pDev->iDataMode = eDataMode_RAWIP;
+      }
+      else if(iRAWIPEnable==0)
+      {
+         pDev->iDataMode = eDataMode_Ethernet;
+      }
+      else
+      {
+         pDev->iDataMode = eDataMode_RAWIP;
+      }
+      
+      do
+      {
+         if(iTEEnable!=eSKIP_TE_FLOW_CONTROL_TLV)//TE_FLOW_CONTROL
+         {
+            result = QMIWDASetDataFormat (pDev, iTEEnable,pDev->iQMUXEnable);
+         }
+         else
+         {
+            result = QMIWDASetDataFormat (pDev, eSKIP_TE_FLOW_CONTROL_TLV,pDev->iQMUXEnable);
+         }
+         if(isModuleUnload(pDev))
+         {
+            return -EFAULT;;
+         }
+         if(i++>MAX_RETRY)
+         {
+            if(pDev->iDataMode==eDataMode_Ethernet)
+            {
+               pDev->iDataMode=eDataMode_RAWIP;
+               i = 0;
+            }
+            else
+            {
+               break;
+            }
+         }
+      }while(result!=0);
+       if(result != 0)
+       {
+          if(iTEEnable==eTE_FLOW_CONTROL_TLV_1)//TE_FLOW_CONTROL
+          {
+             result = QMIWDASetDataFormat (pDev, eTE_FLOW_CONTROL_TLV_0,pDev->iQMUXEnable);
+             if(result != 0)
+             {
+                printk(KERN_INFO "Set Data Format Fail\n");
+             }
+             else
+             {
+                 printk(KERN_INFO "TE Flow Control disabled\n");
+             }
+          }
+          else if(iTEEnable==eTE_FLOW_CONTROL_TLV_0)//TE_FLOW_CONTROL
+          {
+             result = QMIWDASetDataFormat (pDev, eSKIP_TE_FLOW_CONTROL_TLV,pDev->iQMUXEnable);
+             if(result != 0)
+             {
+                printk(KERN_INFO "Set Data Format Fail No TE flow control\n");
+             }
+          }
+       }
+       else
+       {
+          if(iTEEnable!=eSKIP_TE_FLOW_CONTROL_TLV)
+          {
+             if(iTEEnable==eTE_FLOW_CONTROL_TLV_1)//TE_FLOW_CONTROL
+             {
+                printk(KERN_INFO "TE Flow Control Enabled\n");
+             }
+             else
+             {
+                printk(KERN_INFO "TE Flow Control disabled\n");
+             }
+          }
+       }
+   }
+   else
+   {
+       pDev->iDataMode = eDataMode_Ethernet;
+       result = QMICTLSetDataFormat (pDev);
+       if(result!=0)
+       {
+         pDev->iDataMode = eDataMode_RAWIP;
+         result = QMICTLSetDataFormat (pDev);
+       }
+   }
+
+   if (result != 0)
+   {
+       return result;
+   }
+
+   i=0;
+   do
+   {
+      // Setup WDS callback
+      result = SetupQMIWDSCallback( pDev );
+      if(isModuleUnload(pDev))
+      {
+         return -EFAULT;
+      }
+      if (result != 0)
+      {
+         if(i++>MAX_RETRY)
+         {
+         return result;
+         }
+      }
+   }while(result!=0);
+
+   if (is9x15)
+   {
+       // Set FCC Authentication
+       i=0;
+       do
+       {
+          result = QMIDMSSWISetFCCAuth( pDev );
+          if(pDev->mbUnload != eStatRegister)
+          {
+             return -EFAULT;;
+          }
+          if (result != 0)
+          {
+            if(i++>MAX_RETRY)
+            {
+               return result;
+            }
+          }
+       }while(result!=0);
+   }
+   // Fill MEID for device
+   i=0;
+   do
+   {
+      result = QMIDMSGetMEID( pDev );
+      if(pDev->mbUnload != eStatRegister)
+      {
+          return -EFAULT;;
+      }
+      if (result != 0)
+      {
+         if(i++>MAX_RETRY)
+         {
+            return result;
+         }
+      }
+   }while(result!=0);
+
+   // Fill Get Version info
+   memset(&pDev->svcVersion[0], 0, sizeof(pDev->svcVersion));
+   i=0;   
+   do
+   {
+      result = QMICTLGetVersionInfo(pDev);
+      if(isModuleUnload(pDev))
+      {
+         return -EFAULT;;
+      }
+      if (result != 0)
+      {
+         if(i++ > MAX_RETRY)
+         {
+            DBG( "QMI CTL Service Versions Procedure Error\n" );
+            
+            // Don't treat it fatal for driver loading, move on
+            break;
+         }
+      }
+      else
+      {
+         DBG( "QMI CTL Service Versions Procedure Successful\n" );
+      }
+   }while(result!=0);
+
+   // allocate and fill devno with numbers
+   result = alloc_chrdev_region( &devno, 0, 1, "qcqmi" );
+   if (result < 0)
+   {
+      return result;
+   }
+   for(i=0;i<MAX_QCQMI;i++)
+   {
+       if (qcqmi_table[i] == 0)
+           break;
+   }
+   
+   if (i == MAX_QCQMI)
+   {
+       printk(KERN_WARNING "no free entry available at qcqmi_table array\n");
+       return -ENOMEM;
+   }
+   qcqmi_table[i] = 1;
+   pDev->mQMIDev.qcqmi = i;
+
+   // Always print this output
+   printk( KERN_INFO "creating qcqmi%d\n",
+           pDev->mQMIDev.qcqmi );
+
+   // Create cdev
+   cdev_init( &pDev->mQMIDev.mCdev, &UserspaceQMIFops );
+   pDev->mQMIDev.mCdev.owner = THIS_MODULE;
+   pDev->mQMIDev.mCdev.ops = &UserspaceQMIFops;
+   pDev->mQMIDev.mbCdevIsInitialized = true;
+
+   result = cdev_add( &pDev->mQMIDev.mCdev, devno, 1 );
+   if (result != 0)
+   {
+      DBG( "error adding cdev\n" );
+      return result;
+   }
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,27 ))
+   // kernel 2.6.27 added a new fourth parameter to device_create
+   //    void * drvdata : the data to be added to the device for callbacks
+   pDev->dev = device_create( pDev->mQMIDev.mpDevClass,
+                  &pDev->mpIntf->dev,
+                  devno,
+                  NULL,
+                  "qcqmi%d",
+                  pDev->mQMIDev.qcqmi );
+#else
+   pDev->dev = device_create( pDev->mQMIDev.mpDevClass,
+                  &pDev->mpIntf->dev,
+                  devno,
+                  "qcqmi%d",
+                  pDev->mQMIDev.qcqmi );
+#endif
+
+   pDev->mQMIDev.mDevNum = devno;
+
+   memset(pDev->maps.table, 0xff, sizeof(pDev->maps.table));
+   pDev->maps.count = 0; 
+
+   sprintf(qcqmi_dev_name, "qcqmi%d", (int)pDev->mQMIDev.qcqmi);
+   pDev->mQMIDev.proc_file = proc_create_data(qcqmi_dev_name, 0, NULL, &proc_fops, pDev);
+
+   if (!pDev->mQMIDev.proc_file) {
+       return -ENOMEM;
+   }
+
+  // Success
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   wakeup_target_process (Public Method)
+
+DESCRIPTION:
+   Close File Inode
+
+PARAMETERS:
+   pTask     [ I ] - task struct
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void wakeup_target_process(struct task_struct * pTask)
+{
+   if(pTask!=NULL)
+   {
+      struct list_head *list = NULL;
+      int count=0;
+      #if _SIG_LOCK_
+      struct sighand_struct *sighand = NULL;
+      #endif
+      if(wait_preempt()==0)
+      return ;
+      if(signal_pending(pTask))
+         return ;
+      if(pTask==current)
+         return ;
+      if(pTask->state!=TASK_STOPPED)
+         return ;
+      #if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)
+      while(raw_spin_is_locked(&pTask->pi_lock))
+      #endif
+      {
+         if(count++>10)
+         {
+            DBG( "task Locked %d, pid:%d\n",__LINE__ ,pTask->pid);
+            return ;
+         }
+         msleep_interruptible(100);
+         mb();
+         if(pTask==NULL)
+            return;
+         if(signal_pending(pTask))
+         return ;
+      }
+      if(signal_pending(pTask))
+         return ;
+      #if _SIG_LOCK_         
+      if(lockdep_tasklist_lock_is_held())
+      {
+      DBG( "lockdep_tasklist_lock_is_held %d, pid:%d\n",__LINE__ ,pTask->pid);
+      }
+      sighand = rcu_dereference_check(pTask->sighand,
+      lockdep_tasklist_lock_is_held());
+      if(sighand)
+      spin_lock_irq(&sighand->siglock);
+      else
+      {
+      DBG( "spin_lock %d, pid:%d\n",__LINE__ ,pTask->pid);
+      return ;
+      }
+      #endif
+      if(pTask->state==TASK_STOPPED)
+      {
+         if (unlikely(pTask->signal->notify_count < 0))
+         {
+             if(pTask!=current)
+             {
+                 gobi_try_wake_up_process(pTask);
+             }
+             list_for_each(list, &pTask->children)
+             {
+                 struct task_struct *task;
+                 task = list_entry(list, struct task_struct, sibling);
+                 if(task!=NULL)
+                 if(task!=current)
+                 {
+                    DBG( "%d pid:%d\n",__LINE__,task->pid );
+                    gobi_try_wake_up_process(task);
+                 }
+             }
+             wait_ms(500);
+         }
+      }
+      #if _SIG_LOCK_
+      if(sighand)
+      spin_unlock_irq(&sighand->siglock);
+      #endif
+      return ;
+   }
+}
+
+/*===========================================================================
+METHOD:
+   CloseFileInode (Public Method)
+
+DESCRIPTION:
+   Close File Inode
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   None
+===========================================================================*/
+int CloseFileInode(sGobiUSBNet * pDev,int iCount)
+{
+   struct inode * pOpenInode=NULL;
+   struct task_struct * pEachTask = NULL;
+   struct fdtable * pFDT;
+   struct file * pFilp;
+   unsigned long i_no =-1;
+   int count = 0;
+   //DBG("\n");
+   if(pDev==NULL)
+   {
+      return 0;
+   }
+   GobiSyncRcu();
+   if(!list_empty_careful(&pDev->mQMIDev.mCdev.list))
+   if(!list_empty(&pDev->mQMIDev.mCdev.list))
+    {
+       list_for_each_entry(pOpenInode,&pDev->mQMIDev.mCdev.list,i_devices)
+       {
+          if(!pOpenInode)
+          {
+             break;
+          }
+          // Get the inode
+          if (pOpenInode != NULL && (IS_ERR( pOpenInode ) == false))
+          {
+             i_no = pOpenInode->i_ino;
+             DBG("OpenedInode:%lu\n",i_no);
+             // Look for this inode in each task
+             for_each_process( pEachTask )
+             {
+                int max_fds = 0;
+                if (pEachTask == NULL )
+                {
+                   break;
+                }
+                if(pEachTask->files == NULL)
+                {
+                   // Some tasks may not have files (e.g. Xsession)
+                   continue;
+                }
+                if(signal_pending(pEachTask))
+                {
+                  DBG("Task exiting OpenedInode:%lu\n",i_no);
+                  return 1;
+                }
+                // For each file this task has open, check if it's referencing
+                // our inode.
+                pFDT = files_fdtable( pEachTask->files );
+                if(pFDT)
+                {
+                    int iFound = 0;
+                    max_fds = pFDT->max_fds;
+                    for (count = 0; count < max_fds; count++)
+                    {
+                       if(pFDT==NULL)
+                       {
+                          break;
+                       }
+                       if(signal_pending(pEachTask))
+                       {
+                           break;
+                       }
+                       pFilp = pFDT->fd[count];
+                       
+                       #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,19,0 ))
+                       if (pFilp != NULL &&  pFilp->f_path.dentry != NULL)
+                       #else
+                       if (pFilp != NULL &&  pFilp->f_dentry != NULL)
+                       #endif
+                       {
+                          #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,19,0 ))
+                          if (pFilp->f_path.dentry->d_inode == pOpenInode)
+                          #else
+                          if (pFilp->f_dentry->d_inode == pOpenInode)
+                          #endif
+                          {
+                             sQMIFilpStorage * pFilpData = NULL;
+                             int reffrom = 0;
+                             if(file_inode(pFilp)!=NULL)
+                             {
+                                i_no = file_inode(pFilp)->i_ino;
+                             }
+                             else
+                             {
+                                DBG("File Inode Null %d\n",__LINE__);
+                                break;
+                             }
+                             printk( KERN_INFO "forcing close of opened file handle i_ino:%lu\n", i_no);
+
+                             reffrom = gobi_atomic_read( &pDev->mQMIDev.mCdev.kobj.kref.refcount );
+                             if (reffrom<2)
+                             {
+                                DBG("opened file handle i_ino:%lu\n", i_no);
+                                break;
+                             }
+                             pFilpData = (sQMIFilpStorage *)pFilp->private_data;
+                             if(pFilpData!=NULL)
+                             {
+                                 struct task_struct *pOpenTask = pFilpData->pOpenTask;
+                                 struct task_struct *pReadTask = pFilpData->pReadTask;
+                                 struct task_struct *pIOCTLTask = pFilpData->pIOCTLTask;
+                                 struct task_struct *pWriteTask = pFilpData->pWriteTask;
+                                 reffrom = 0;
+                                 if((!signal_pending(pEachTask))&&
+                                    (pFilpData->iSemID >0))
+                                 {
+                                    if(!down_trylock(&(pFilpData->mReadSem)))
+                                    {
+                                         DBG("NOT locked : %d",pFilpData->iSemID);
+                                    }
+                                    barrier();
+                                    up(&(pFilpData->mReadSem));
+                                 }
+                                 if(pReadTask!=pOpenTask)
+                                 {
+                                    DBG("pReadTask:%d\n", pReadTask->pid);
+                                    wakeup_target_process(pReadTask);
+                                    pFilpData->pReadTask = pFilpData->pOpenTask;
+                                    reffrom++;
+                                    mb();
+                                 }
+                                 if(pIOCTLTask!=pOpenTask)
+                                 {
+                                    DBG("pIOCTLTask:%d\n", pIOCTLTask->pid);
+                                    wakeup_target_process(pIOCTLTask);
+                                    pFilpData->pIOCTLTask = pFilpData->pOpenTask;
+                                    reffrom++;
+                                    mb();
+                                 }
+                                 if(pWriteTask!=pOpenTask)
+                                 {
+                                    reffrom++;
+                                    DBG("pWriteTask:%d\n", pWriteTask->pid);
+                                    wakeup_target_process(pWriteTask);
+                                    pFilpData->pWriteTask = pFilpData->pOpenTask;
+                                    mb();
+                                 }
+                                 if(reffrom==0)
+                                 if( (pOpenTask==pReadTask)&&
+                                     (pOpenTask==pIOCTLTask)&&
+                                     (pOpenTask==pWriteTask))
+                                 {
+                                    wakeup_target_process(pOpenTask);
+                                 }
+                                 if(reffrom>0)
+                                 {
+                                    return 1;
+                                 }
+                             }
+                             else
+                             {
+                                 DBG("NULL private_data\n");
+                             }
+                             if(!signal_pending(pEachTask))
+                             {
+                                reffrom++;
+                                wakeup_target_process(pEachTask);
+                             }
+                             if((!signal_pending(pEachTask))&&
+                                (iCount>5))
+                             {
+                                DBG("ForceFilpClose:%d\n",pEachTask->pid);
+                                ForceFilpClose(pFilp);
+                             }
+                             if(reffrom>0)
+                             {
+                                 return 1;
+                             }
+                          }//if (pFilp->f_dentry->d_inode == pOpenInode)
+                       }
+                                             
+                    }//for (count = 0; count < max_fds; count++)
+                    if(iFound==0)
+                    {
+                       if(!signal_pending(pEachTask))
+                       {
+                          wakeup_target_process(pEachTask);
+                       }
+                       else 
+                       {
+                          return 1;
+                       }
+                       iFound = 0;
+                    }
+                }//if(pFDT)
+             }//for_each_process
+          }//// Get the inode
+       }//list_for_each_entry
+      }//list_empty
+   gobi_flush_work();
+   mb();
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   gobi_flush_work (Public Method)
+
+DESCRIPTION:
+   sync memory
+
+PARAMETERS:
+   None
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void gobi_flush_work(void)
+{
+    GobiSyncRcu();
+    return ;
+}
+
+/*===========================================================================
+METHOD:
+   DeregisterQMIDevice (Public Method)
+
+DESCRIPTION:
+   QMI Device cleanup function
+
+   NOTE: When this function is run the device is no longer valid
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void UnLocalClientMemLockSpinLock(sGobiUSBNet * pDev )
+{
+   int count =0;
+   mb();
+    while(LocalClientMemLockSpinIsLock( pDev ) != 0)
+    {
+      mb();
+      if(count>10)
+      {
+         break;
+      }
+      count++;
+      wait_ms(50);
+    };
+}
+void DeregisterQMIDevice( sGobiUSBNet * pDev )
+{
+   int tries = 0;
+   int result = -1;
+   int i = 0;
+   int iIntfNum = 0;
+   unsigned long flags = 0;
+   if(isPreempt()!=0)
+   {
+      printk("preempt_disable");
+      preempt_disable();
+   }
+   pDev->mbUnload = eStatUnloading;
+   qmux_table[pDev->iDeviceMuxID]=0;
+   // Should never happen, but check anyway
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "wrong device\n" );
+      pDev->iNetLinkStatus = eNetDeviceLink_Disconnected;
+      RemoveProcessFile(pDev);
+      RemoveCdev(pDev);
+      KillRead( pDev );
+      GobiDestoryWorkQueue(pDev);
+      flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+      // Timeout, remove the async read
+      RemoveAndPopNotifyList(pDev,QMICTL,0,eClearCID);
+      // End critical section
+      LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+      // Send SetControlLineState request (USB_CDC)
+      result = Gobi_usb_control_msg(pDev->mpIntf, pDev->mpNetDev->udev,
+                             usb_sndctrlpipe( pDev->mpNetDev->udev, 0 ),
+                             SET_CONTROL_LINE_STATE_REQUEST,
+                             SET_CONTROL_LINE_STATE_REQUEST_TYPE,
+                             0, // DTR not present
+                             /* USB interface number to receive control message */
+                             pDev->mpIntf->cur_altsetting->desc.bInterfaceNumber,
+                             NULL,
+                             0,
+                             100 );
+      pDev->mbUnload = eStatUnloaded;
+      gobi_flush_work();
+      return;
+   }
+   pDev->iNetLinkStatus = eNetDeviceLink_Disconnected;
+   RemoveProcessFile(pDev);
+   pDev->mQMIDev.mCdev.ops = NULL;
+   mb();
+   tries = 0;
+   iIntfNum = pDev->mpIntf->cur_altsetting->desc.bInterfaceNumber;
+   pDev->mQMIDev.mCdev.ops = NULL;
+   UnLocalClientMemLockSpinLock(pDev);
+   
+   while(LocalClientMemLockSpinIsLock(pDev)!=0)
+   {
+      gobi_flush_work();
+      if((tries%10)==0)
+      {
+         printk("Spinlocked\n");
+      }
+      if(200> tries++)
+      {
+         break;
+      }
+   }
+
+   /* clear the qmux ip table */
+   for ( i = 0; i < MAX_MUX_NUMBER_SUPPORTED; i++)
+   {
+      pDev->qMuxIPTable[i].instance = 0;
+      pDev->qMuxIPTable[i].ipAddress = 0;
+   }
+   // Stop all reads
+   KillRead( pDev );
+   wait_interrupt();
+   GobiDestoryWorkQueue(pDev);   
+   if(pDev->WDSClientID!=(u16)-1)
+   ReleaseClientID( pDev, pDev->WDSClientID );
+
+   gobi_flush_work();
+   wait_interrupt();
+   // Release all clients
+   while (pDev->mQMIDev.mpClientMemList != NULL)
+   {
+      DBG( "release 0x%04X\n", pDev->mQMIDev.mpClientMemList->mClientID );
+      if(pDev->mQMIDev.mpClientMemList->mClientID==QMICTL)
+      {
+          unsigned long flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+          // Timeout, remove the async read
+          RemoveAndPopNotifyList(pDev,QMICTL,0,eClearCID);
+          // End critical section
+          LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+          break;
+      }
+      else
+      {
+
+      if (ReleaseClientID(pDev,
+                       pDev->mQMIDev.mpClientMemList->mClientID) == false)
+          break;
+      // NOTE: pDev->mQMIDev.mpClientMemList will
+      //       be updated in ReleaseClientID()
+      }
+      gobi_flush_work();
+      wait_interrupt();
+   }
+   tries = 0;
+   do
+   {
+      int ref = 0;
+      mb();
+      ref = gobi_atomic_read( &pDev->mQMIDev.mCdev.kobj.kref.refcount );
+      DBG("%s:%d(%d) tries:%d ref:%d\n",__FUNCTION__,__LINE__,iIntfNum,tries,ref);     
+      if (ref > 1)
+      {       
+         int iLoop = 0;
+         mb();
+         wait_interrupt();
+         ref = gobi_atomic_read( &pDev->mQMIDev.mCdev.kobj.kref.refcount );
+         if(wait_preempt()==1)
+         if(ref>1)
+         {
+            
+            while(CloseFileInode(pDev,tries)==1)
+            {
+               if(iLoop++>10)
+               {
+                  break;
+               }
+               if(preempt_count()>0)
+               {
+                  wait_ms(100);
+               }
+               else
+               {
+                  msleep_interruptible(100);
+               }
+            }
+            gobi_flush_work();
+            mb();
+         }
+
+         if(iLoop==0)
+         {
+            if(preempt_count()>0)
+            {
+               wait_ms(400);
+            }
+            else
+            {
+               msleep_interruptible(400);
+            }
+         }
+         
+         
+      }
+      else
+      {
+         break;
+      }
+      wait_ms(100);
+   }while(20> tries++);
+   gobi_flush_work();
+
+
+   pDev->mbQMIValid = false;
+
+   if (pDev->mQMIDev.mbCdevIsInitialized == false)
+   {
+      pDev->mbUnload = eStatUnloaded;
+      return;
+   }
+
+   // Find each open file handle, and manually close it
+
+   // Generally there will only be only one inode, but more are possible
+   mb();
+   if(pDev->iShutdown_write_sem>0)
+   {
+      down_write_trylock(&(pDev->shutdown_rwsem));
+      up_write(&pDev->shutdown_rwsem);
+   }
+   mb();
+   if(pDev->iShutdown_read_sem>0)
+   {
+      down_read_trylock(&(pDev->shutdown_rwsem));
+      up_read(&pDev->shutdown_rwsem);
+   }
+   i =0;
+   while(!down_trylock( &(pDev->ReadsyncSem) ))
+   {
+      i++;
+      if(i>MAX_RETRY_LOCK_NUMBER)
+      {
+         break;
+      }
+      set_current_state(TASK_INTERRUPTIBLE);
+      wait_ms(MAX_RETRY_LOCK_MSLEEP_TIME);
+      if(signal_pending(current))
+      {
+        break;
+      }
+      if(pDev==NULL)
+      {
+         return ;
+      }
+   }
+   up(&(pDev->ReadsyncSem));
+   set_current_state(TASK_RUNNING);
+   // Send SetControlLineState request (USB_CDC)
+   result = Gobi_usb_control_msg(pDev->mpIntf, pDev->mpNetDev->udev,
+                             usb_sndctrlpipe( pDev->mpNetDev->udev, 0 ),
+                             SET_CONTROL_LINE_STATE_REQUEST,
+                             SET_CONTROL_LINE_STATE_REQUEST_TYPE,
+                             0, // DTR not present
+                             /* USB interface number to receive control message */
+                             pDev->mpIntf->cur_altsetting->desc.bInterfaceNumber,
+                             NULL,
+                             0,
+                             100 );
+   if (result < 0)
+   {
+      DBG( "SetControlLineState:%d\n", result );
+   }
+
+   // Remove device (so no more calls can be made by users)
+   if (IS_ERR( pDev->mQMIDev.mpDevClass ) == false)
+   {
+      device_destroy( pDev->mQMIDev.mpDevClass,
+                      pDev->mQMIDev.mDevNum );
+   }
+
+   qcqmi_table[pDev->mQMIDev.qcqmi] = 0;
+
+   // Hold onto cdev memory location until everyone is through using it.
+   // Timeout after 30 seconds (10 ms interval).  Timeout should never happen,
+   // but exists to prevent an infinate loop just in case.
+
+   for (tries = 0; tries < 60; tries++)
+   {
+      int ref = gobi_atomic_read( &pDev->mQMIDev.mCdev.kobj.kref.refcount );
+      if (ref > 1)
+      {
+         wait_ms(500);
+         ref = gobi_atomic_read( &pDev->mQMIDev.mCdev.kobj.kref.refcount );
+         if(ref>1)
+         {
+            printk( KERN_WARNING "cdev in use by %d tasks\n", ref - 1 );
+            CloseFileInode(pDev,tries);
+            wait_ms(500);
+         }
+      }
+      else
+      {
+         break;
+      }
+   }
+
+   cdev_del( &pDev->mQMIDev.mCdev );
+
+   unregister_chrdev_region( pDev->mQMIDev.mDevNum, 1 );
+   pDev->mbUnload = eStatUnloaded;
+   return;
+}
+
+/*=========================================================================*/
+// Driver level client management
+/*=========================================================================*/
+
+/*===========================================================================
+METHOD:
+   QMIReady (Public Method)
+
+DESCRIPTION:
+   Send QMI CTL GET VERSION INFO REQ and SET DATA FORMAT REQ
+   Wait for response or timeout
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+   timeout  [ I ] - Milliseconds to wait for response
+
+RETURN VALUE:
+   int
+===========================================================================*/
+int QMIReady(
+   sGobiUSBNet *    pDev,
+   u16                timeout )
+{
+   int result;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   void * pReadBuffer;
+   u16 readBufferSize;
+   struct semaphore readSem;
+   u16 curTime;
+   u8 transactionID;
+   unsigned long flags;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return false;
+   }
+
+   writeBufferSize = QMICTLReadyReqSize();
+   pWriteBuffer = kmalloc( writeBufferSize, GOBI_GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return false;
+   }
+
+   // An implimentation of down_timeout has not been agreed on,
+   //    so it's been added and removed from the kernel several times.
+   //    We're just going to ignore it and poll the semaphore.
+
+   sema_init( &readSem, SEMI_INIT_DEFAULT_VALUE );
+   mb();
+   // Send a write every 1000 ms and see if we get a response
+   for (curTime = 0; curTime < timeout; curTime += 1000)
+   {
+      if(gobi_kthread_should_stop())
+      {
+         return -1;
+      }
+      
+      // Start read
+      transactionID =QMIXactionIDGet(pDev);
+      
+      result = ReadAsync( pDev, QMICTL, transactionID, UpSem, &readSem ,1);
+      if (result != 0)
+      {
+         kfree( pWriteBuffer );
+         flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+         RemoveAndPopNotifyList(pDev,QMICTL,0,eClearCID);
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         return false;
+      }
+
+      // Fill buffer
+      result = QMICTLReadyReq( pWriteBuffer,
+                               writeBufferSize,
+                               transactionID );
+      if (result < 0)
+      {
+         kfree( pWriteBuffer );
+         flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+         RemoveAndPopNotifyList(pDev,QMICTL,0,eClearCID);
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         return false;
+      }
+
+      // Disregard status.  On errors, just try again
+      WriteSync( pDev,
+                 pWriteBuffer,
+                 writeBufferSize,
+                 QMICTL );
+      if(gobi_kthread_should_stop())
+      {
+         set_current_state(TASK_RUNNING);
+         flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+         RemoveAndPopNotifyList(pDev,QMICTL,0,eClearCID);
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         return -1;
+      }
+
+      if(curTime < timeout)
+      {
+         int iScaleCount = 0;
+         for(iScaleCount=0;iScaleCount<100;iScaleCount++)
+         {
+            if( gobi_kthread_should_stop() )
+            {
+               if(pWriteBuffer)
+               kfree(pWriteBuffer);
+               KillRead( pDev );
+               flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+               RemoveAndPopNotifyList(pDev,QMICTL,0,eClearCID);
+               LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+               return -1;
+            }
+            msleep( 10 );//wait_ms(10);//msleep( 10 );
+            if(gobi_kthread_should_stop())
+            {
+               if(pWriteBuffer)
+               kfree(pWriteBuffer);
+               KillRead( pDev );
+               flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+               RemoveAndPopNotifyList(pDev,QMICTL,0,eClearCID);
+               LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+               return -1;
+            }
+            if(isModuleUnload(pDev))
+            {
+               if(pWriteBuffer)
+               kfree(pWriteBuffer);
+               KillRead( pDev );
+               flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+               RemoveAndPopNotifyList(pDev,QMICTL,0,eClearCID);
+               LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+               return -1;
+            }
+         }
+         
+      }
+      mb();
+      // Enter critical section
+      flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+      barrier();
+      spin_lock_irq(&(pDev->notif_lock));
+      if (down_trylock( &readSem ) == 0)
+      {
+         // Pop the read data
+         if (PopFromReadMemList( pDev,
+                                 QMICTL,
+                                 transactionID,
+                                 &pReadBuffer,
+                                 &readBufferSize ) == true)
+         {
+            // Success
+            spin_unlock_irq(&(pDev->notif_lock));
+            // End critical section
+            LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+
+            // We don't care about the result
+            if(pReadBuffer)
+            kfree( pReadBuffer );
+            break;
+         }
+         else
+         {
+            RemoveAndPopNotifyList(pDev,QMICTL,transactionID,eClearCID);
+            spin_unlock_irq(&(pDev->notif_lock));
+            // Read mismatch/failure, unlock and continue
+            LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         }
+      }
+      else
+      {
+         if( (pDev->mbUnload < eStatUnloading) ||
+            IsDeviceDisconnect(pDev))
+         {
+             // Enter critical section
+             // Timeout, remove the async read
+             RemoveAndPopNotifyList(pDev,QMICTL,transactionID,eClearCID);
+             // End critical section
+         }
+         spin_unlock_irq(&(pDev->notif_lock));
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+      }
+   }
+   kfree( pWriteBuffer );
+   // Did we time out?
+   if (curTime >= timeout)
+   {
+      return false;
+   }
+   DBG( "QMI Ready after %u milliseconds\n", curTime );
+   if(SetPowerSaveMode(pDev,0)<0)
+   {
+      DBG("Set Power Save Mode error\n");
+   }
+
+   flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+   // Timeout, remove the async read
+   RemoveAndPopNotifyList(pDev,QMICTL,0,eClearCID);
+   // End critical section
+   LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+   // Success
+   return true;
+}
+
+/*===========================================================================
+METHOD:
+   QMIWDSCallback (Public Method)
+
+DESCRIPTION:
+   QMI WDS callback function
+   Update net stats or link state
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+   clientID [ I ] - Client ID
+   pData    [ I ] - Callback data (unused)
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void QMIWDSCallback(
+   sGobiUSBNet *    pDev,
+   u16                clientID,
+   void *             pData )
+{
+   bool bRet;
+   int result;
+   void * pReadBuffer=NULL;
+   u16 readBufferSize;
+   u32 TXOk = (u32)-1;
+   u32 RXOk = (u32)-1;
+   u32 TXErr = (u32)-1;
+   u32 RXErr = (u32)-1;
+   u32 TXOfl = (u32)-1;
+   u32 RXOfl = (u32)-1;
+   u64 TXBytesOk = (u64)-1;
+   u64 RXBytesOk = (u64)-1;
+   bool bReconfigure;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return;
+   }
+
+   bRet = PopFromReadMemList( pDev,
+                              clientID,
+                              0,
+                              &pReadBuffer,
+                              &readBufferSize );
+
+
+   if (bRet == false)
+   {
+      DBG( "WDS callback failed to get data\n" );
+      if(pReadBuffer)
+         kfree( pReadBuffer );
+      pReadBuffer = NULL;
+      return;
+   }
+
+   // Default values
+   pDev->bLinkState = ! GobiTestDownReason( pDev, NO_NDIS_CONNECTION );
+   bReconfigure = false;
+
+   result = QMIWDSEventResp( pReadBuffer,
+                             readBufferSize,
+                             &TXOk,
+                             &RXOk,
+                             &TXErr,
+                             &RXErr,
+                             &TXOfl,
+                             &RXOfl,
+                             &TXBytesOk,
+                             &RXBytesOk,
+                             (u8*)&pDev->bLinkState,
+                             &bReconfigure );
+   if (result < 0)
+   {
+      DBG( "bad WDS packet\n" );
+   }
+   else
+   {
+      if (bReconfigure == true)
+      {
+         DBG( "Net device link reset\n" );
+         GobiSetDownReason( pDev, NO_NDIS_CONNECTION );
+         GobiClearDownReason( pDev, NO_NDIS_CONNECTION );
+      }
+      else
+      {
+         if (pDev->bLinkState == true)
+         {
+            DBG( "Net device link is connected\n" );
+            GobiClearDownReason( pDev, NO_NDIS_CONNECTION );
+         }
+         else
+         {
+            DBG( "Net device link is disconnected\n" );
+            GobiSetDownReason( pDev, NO_NDIS_CONNECTION );
+         }
+      }
+   }
+   if(pReadBuffer)
+   kfree( pReadBuffer );
+   pReadBuffer = NULL;
+
+   // Setup next read
+   result = ReadAsync( pDev,
+                       clientID,
+                       0,
+                       QMIWDSCallback,
+                       pData ,0);
+
+   if (result != 0)
+   {
+      DBG( "unable to setup next async read\n" );
+   }
+
+   return;
+}
+
+void QMIQOSCallback(
+   sGobiUSBNet *    pDev,
+   u16                clientID,
+   void *             pData )
+{
+   bool bRet;
+   int result;
+   void * pReadBuffer;
+   u16 readBufferSize;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      QDBG( "Invalid device\n" );
+      return;
+   }
+
+   bRet = PopFromReadMemList( pDev,
+                              clientID,
+                              0,
+                              &pReadBuffer,
+                              &readBufferSize );
+
+
+   if (bRet == false)
+   {
+      QDBG( "QOS callback failed to get data\n" );
+      return;
+   }
+
+   result = QMIQOSEventResp(pDev, pReadBuffer, readBufferSize);
+
+   if (result < 0)
+   {
+      QDBG( "bad QOS packet\n" );
+   }
+   if(pReadBuffer)
+   kfree( pReadBuffer );
+
+   // Setup next read
+   result = ReadAsync( pDev,
+                       clientID,
+                       0,
+                       QMIQOSCallback,
+                       pData ,0);
+
+   if (result != 0)
+   {
+      QDBG( "unable to setup next async read\n" );
+   }
+
+   return;
+}
+
+/*===========================================================================
+METHOD:
+   SetupQMIWDSCallback (Public Method)
+
+DESCRIPTION:
+   Request client and fire off reqests and start async read for
+   QMI WDS callback
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for failure
+===========================================================================*/
+int SetupQMIWDSCallback( sGobiUSBNet * pDev )
+{
+   int result;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   u16 WDSClientID;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return -EFAULT;
+   }
+
+   result = GetClientID( pDev, QMIWDS,NULL );
+   if (result < 0)
+   {
+      return result;
+   }
+   pDev->WDSClientID = WDSClientID = result;
+
+   // QMI WDS Set Event Report
+   writeBufferSize = QMIWDSSetEventReportReqSize();
+   pWriteBuffer = kmalloc( writeBufferSize, GOBI_GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+
+   result = QMIWDSSetEventReportReq( pWriteBuffer,
+                                     writeBufferSize,
+                                     1 );
+   if (result < 0)
+   {
+      kfree( pWriteBuffer );
+      return result;
+   }
+
+   result = WriteSync( pDev,
+                       pWriteBuffer,
+                       writeBufferSize,
+                       WDSClientID );
+   kfree( pWriteBuffer );
+
+   if (result < 0)
+   {
+      return result;
+   }
+
+   // QMI WDS Get PKG SRVC Status
+   writeBufferSize = QMIWDSGetPKGSRVCStatusReqSize();
+   pWriteBuffer = kmalloc( writeBufferSize, GOBI_GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+
+   result = QMIWDSGetPKGSRVCStatusReq( pWriteBuffer,
+                                       writeBufferSize,
+                                       2 );
+   if (result < 0)
+   {
+      kfree( pWriteBuffer );
+      return result;
+   }
+
+   result = WriteSync( pDev,
+                       pWriteBuffer,
+                       writeBufferSize,
+                       WDSClientID );
+   kfree( pWriteBuffer );
+
+   if (result < 0)
+   {
+      return result;
+   }
+
+   // Setup asnyc read callback
+   result = ReadAsync( pDev,
+                       WDSClientID,
+                       0,
+                       QMIWDSCallback,
+                       NULL ,1);
+   if (result != 0)
+   {
+      DBG( "unable to setup async read\n" );
+      return result;
+   }
+
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   QMIDMSSWISetFCCAuth (Public Method)
+
+DESCRIPTION:
+   Register DMS client
+   send FCC Authentication req and parse response
+   Release DMS client
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   None
+===========================================================================*/
+int QMIDMSSWISetFCCAuth( sGobiUSBNet * pDev )
+{
+   int result;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   void * pReadBuffer;
+   u16 readBufferSize;
+   u16 DMSClientID;
+   struct semaphore readSem;
+   unsigned long flags;
+   DBG("\n");
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return -EFAULT;
+   }
+   sema_init( &readSem, SEMI_INIT_DEFAULT_VALUE );
+   mb();
+
+   result = GetClientID( pDev, QMIDMS ,NULL);
+   if (result < 0)
+   {
+      return result;
+   }
+   DMSClientID = result;
+
+   // QMI DMS Get Serial numbers Req
+   writeBufferSize = QMIDMSSWISetFCCAuthReqSize();
+   pWriteBuffer = kmalloc( writeBufferSize, GOBI_GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+
+   result = QMIDMSSWISetFCCAuthReq( pWriteBuffer,
+                                    writeBufferSize,
+                                    1 );
+   if (result < 0)
+   {
+      kfree( pWriteBuffer );
+      pWriteBuffer = NULL;
+      return result;
+   }
+
+   result = ReadAsync( pDev, DMSClientID, 1, UpSem, &readSem ,1);
+   if(result == 0)
+   {
+      result = WriteSync( pDev,
+                    pWriteBuffer,
+                    writeBufferSize,
+                    DMSClientID );
+   }
+   if(pWriteBuffer)
+   {
+      kfree( pWriteBuffer );
+      pWriteBuffer = NULL;
+   }
+   wait_control_msg_semaphore_timeout(&readSem,QMI_CONTROL_MAX_MSG_DELAY_MS);
+   mb();
+   // Enter critical section
+   flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+   spin_lock_irq(&(pDev->notif_lock));
+   barrier();
+   if (down_trylock( &readSem ) == 0)
+   {
+      // Pop the read data
+      if (PopFromReadMemList( pDev,
+                              DMSClientID,
+                              1,
+                              &pReadBuffer,
+                              &readBufferSize ) == true)
+      {
+         spin_unlock_irq(&(pDev->notif_lock));
+         // End critical section
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         result = 0;
+         // We don't care about the result
+         if(pReadBuffer)
+         kfree( pReadBuffer );
+      }
+      else
+      {
+         // Read mismatch/failure, unlock and continue
+         DBG( "Read mismatch/failure, unlock and continue\n" );
+         RemoveAndPopNotifyList(pDev,DMSClientID,1,eClearCID);
+         spin_unlock_irq(&(pDev->notif_lock));
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+      }
+   }
+   else
+   {
+      DBG( "Timeout\n" );
+      // Timeout, remove the async read
+      RemoveAndPopNotifyList(pDev,DMSClientID,1,eClearCID);
+      spin_unlock_irq(&(pDev->notif_lock));
+      // End critical section
+      LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+      result = -1;
+   }
+
+   if (result < 0)
+   {
+      // Non fatal error, device did not return FCC Auth response
+      DBG( "Bad FCC Auth resp\n" );
+   }
+   ReleaseClientID( pDev, DMSClientID );
+
+   // Success
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   QMIDMSGetMEID (Public Method)
+
+DESCRIPTION:
+   Register DMS client
+   send MEID req and parse response
+   Release DMS client
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   None
+===========================================================================*/
+int QMIDMSGetMEID( sGobiUSBNet * pDev )
+{
+   int result;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   void * pReadBuffer;
+   u16 readBufferSize;
+   u16 DMSClientID;
+   unsigned long flags;
+   struct semaphore readSem;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return -EFAULT;
+   }
+
+   sema_init( &readSem, SEMI_INIT_DEFAULT_VALUE );
+   mb();
+   result = GetClientID( pDev, QMIDMS ,NULL);
+   if (result < 0)
+   {
+      return result;
+   }
+   DMSClientID = result;
+
+   // QMI DMS Get Serial numbers Req
+   writeBufferSize = QMIDMSGetMEIDReqSize();
+   pWriteBuffer = kmalloc( writeBufferSize, GOBI_GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+
+   result = QMIDMSGetMEIDReq( pWriteBuffer,
+                              writeBufferSize,
+                              1 );
+   if (result < 0)
+   {
+      kfree( pWriteBuffer );
+      pWriteBuffer = NULL;
+      return result;
+   }
+
+   result = ReadAsync( pDev, DMSClientID, 1, UpSem, &readSem ,1);
+   if(result == 0)
+   {
+      result = WriteSync( pDev,
+                    pWriteBuffer,
+                    writeBufferSize,
+                    DMSClientID );
+   }
+   if(pWriteBuffer)
+   {
+      kfree( pWriteBuffer );
+      pWriteBuffer = NULL;
+   }
+   wait_control_msg_semaphore_timeout(&readSem,QMI_CONTROL_MAX_MSG_DELAY_MS);
+   mb();
+   // Enter critical section
+   flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+   spin_lock_irq(&(pDev->notif_lock));
+   barrier();
+   if (down_trylock( &readSem ) == 0)
+   {
+      // Pop the read data
+      if (PopFromReadMemList( pDev,
+                              DMSClientID,
+                              1,
+                              &pReadBuffer,
+                              &readBufferSize ) == true)
+      {
+         spin_unlock_irq(&(pDev->notif_lock));
+         // End critical section
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         result = QMIDMSGetMEIDResp( pReadBuffer,
+                               readBufferSize,
+                               &pDev->mMEID[0],
+                               14 );
+         // We don't care about the result
+         if(pReadBuffer)
+         kfree( pReadBuffer );
+      }
+      else
+      {
+         RemoveAndPopNotifyList(pDev,DMSClientID,1,eClearAndReleaseCID);
+         spin_unlock_irq(&(pDev->notif_lock));
+         // Read mismatch/failure, unlock and continue
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+      }
+   }
+   else
+   {
+      // Timeout, remove the async read
+      RemoveAndPopNotifyList(pDev,DMSClientID,1,eClearAndReleaseCID);
+      spin_unlock_irq(&(pDev->notif_lock));
+      // End critical section
+      LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+      result = -1;
+      if (result < 0)
+      {
+         DBG( "bad get MEID resp\n" );
+         // Non fatal error, device did not return any MEID
+         //    Fill with 0's
+         memset( &pDev->mMEID[0], '0', 14 );
+      }
+   }
+
+   if (result < 0)
+   {
+      DBG( "bad get MEID resp\n" );
+
+      // Non fatal error, device did not return any MEID
+      //    Fill with 0's
+      memset( &pDev->mMEID[0], '0', 14 );
+   }
+
+   ReleaseClientID( pDev, DMSClientID );
+
+   // always return Success as MEID is only available on CDMA devices only
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   QMICTLSetDataFormat (Public Method)
+
+DESCRIPTION:
+   send Data format request and parse response
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   None
+===========================================================================*/
+int QMICTLSetDataFormat( sGobiUSBNet * pDev )
+{
+   u8 transactionID;
+   struct semaphore readSem;
+   int result;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   void * pReadBuffer;
+   u16 readBufferSize;
+   unsigned long flags;
+
+   //DBG("\n");
+
+   // Send SET DATA FORMAT REQ
+   writeBufferSize = QMICTLSetDataFormatReqSize();
+
+   pWriteBuffer = kmalloc( writeBufferSize, GOBI_GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+
+   // Start read
+   sema_init( &readSem, SEMI_INIT_DEFAULT_VALUE );
+   mb();
+
+   transactionID = QMIXactionIDGet(pDev);
+
+   // Fill buffer
+   result = QMICTLSetDataFormatReq( pWriteBuffer,
+                            writeBufferSize,
+                            transactionID ,
+                            pDev->iDataMode);
+
+   if (result < 0)
+   {
+      kfree( pWriteBuffer );
+      return result;
+   }
+
+   DBG("Sending QMI Set Data Format Request, TransactionID: 0x%x\n", transactionID );
+
+   WriteSync( pDev,
+              pWriteBuffer,
+              writeBufferSize,
+              QMICTL );
+
+   //msleep( 100 );
+   wait_control_msg_semaphore_timeout(&readSem,QMI_CONTROL_MAX_MSG_DELAY_MS);
+   mb();
+   // Enter critical section
+   flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+   spin_lock_irq(&(pDev->notif_lock));
+   barrier();
+   if (down_trylock( &readSem ) == 0)
+   {
+      // Pop the read data
+      if (PopFromReadMemList( pDev,
+                              QMICTL,
+                              transactionID,
+                              &pReadBuffer,
+                              &readBufferSize ) == true)
+      {
+         // Success
+         PrintHex(pReadBuffer, readBufferSize);
+         spin_unlock_irq(&(pDev->notif_lock));
+         // End critical section
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         // We care about the result: call Response  function
+         result = QMICTLSetDataFormatResp( pReadBuffer, readBufferSize,pDev->iDataMode);
+         if(pReadBuffer)
+         kfree( pReadBuffer );
+
+         if (result != 0)
+         {
+            DBG( "Device cannot set requested data format\n" );
+            if(pWriteBuffer)
+            kfree( pWriteBuffer );
+            return result;
+         }
+      }
+      else
+      {
+         spin_unlock_irq(&(pDev->notif_lock));
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+      }
+   }
+   else
+   {
+      // Timeout, remove the async read
+      RemoveAndPopNotifyList(pDev,QMICTL,transactionID,eForceClearAndReleaseCID);
+      // End critical section
+      
+   }
+   spin_unlock_irq(&(pDev->notif_lock));
+   LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+   kfree( pWriteBuffer );
+
+   return 0;
+}
+
+
+/*===========================================================================
+METHOD:
+   QMIWDASetQMAP (Public Method)
+
+DESCRIPTION:
+   Send set QMAP Data format request and parse response
+
+PARAMETERS:
+   pDev            [ I ] - Device specific memory
+   WDAClientID     [ I ] - WDA Client ID
+RETURN VALUE:
+   int - 0 for success
+            Negative errno for failure
+===========================================================================*/
+int QMIWDASetQMAP( sGobiUSBNet * pDev , u16 WDAClientID)
+{
+   int result;
+   void *pWriteBuffer;
+   u16 writeBufferSize;
+   void *pReadBuffer;
+   u16 readBufferSize;
+   unsigned long flags;
+   struct semaphore readSem;
+   u16 uTID=2;
+   DBG("\n");
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return -EFAULT;
+   }
+   sema_init( &readSem, SEMI_INIT_DEFAULT_VALUE );
+   mb();
+
+   // QMI WDA Set Data Format Request
+   writeBufferSize = QMIWDASetDataFormatReqSettingsSize();
+   pWriteBuffer = kmalloc( writeBufferSize, GOBI_GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+
+   result = QMIWDASetDataFormatReqSettingsReq( pWriteBuffer,
+                                    writeBufferSize,
+                                    uTID);
+   if (result < 0)
+   {
+      kfree( pWriteBuffer );
+      pWriteBuffer = NULL;
+      return result;
+   }
+
+   result = ReadAsync( pDev, WDAClientID, uTID, UpSem, &readSem ,1);
+   if(result == 0)
+   {
+      result = WriteSync( pDev,
+                          pWriteBuffer,
+                          writeBufferSize,
+                          WDAClientID );
+   }
+   if(pWriteBuffer)
+   {
+      kfree( pWriteBuffer );
+      pWriteBuffer = NULL;
+   }
+   if (result < 0)
+   {
+      DBG( "WriteSync Fail\n" );
+      return result;
+   }
+   wait_control_msg_semaphore_timeout(&readSem,QMI_CONTROL_MAX_MSG_DELAY_MS);
+   mb();
+   flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+   spin_lock_irq(&(pDev->notif_lock));
+   barrier();
+   if (down_trylock( &readSem ) == 0)
+   {
+       // Enter critical section
+         // Pop the read data
+         if (PopFromReadMemList( pDev,
+                                 WDAClientID,
+                                 uTID,
+                                 &pReadBuffer,
+                                 &readBufferSize ) == true)
+         {
+            PrintHex( pReadBuffer, readBufferSize );
+            result = 0;
+            // We don't care about the result
+            if(pReadBuffer)
+            kfree( pReadBuffer );
+         }
+         else
+         {
+            // Read mismatch/failure, unlock and continue
+            RemoveAndPopNotifyList(pDev,WDAClientID,uTID,eClearAndReleaseCID);
+         }
+   }
+   else
+   {
+      DBG( "Timeout\n" );
+      result = -1;
+      // Timeout, remove the async read
+      barrier();
+      RemoveAndPopNotifyList(pDev,WDAClientID,uTID,eClearAndReleaseCID);
+   }
+   spin_unlock_irq(&(pDev->notif_lock));
+   LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+   if (result < 0)
+   {
+      DBG( "Data Format Cannot be set\n" );
+   }
+   return result;
+}
+/*===========================================================================
+METHOD:
+   QMICTLGetVersionInfo (Public Method)
+
+DESCRIPTION:
+   send get version info request and parse response
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+
+RETURN VALUE:
+   None
+===========================================================================*/
+int QMICTLGetVersionInfo( sGobiUSBNet * pDev )
+{
+   u8 transactionID;
+   struct semaphore readSem;
+   int result;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   void * pReadBuffer;
+   u16 readBufferSize;
+   unsigned long flags;
+
+   DBG("\n");
+
+   // Send CTL GET VERSION INFO REQ
+   writeBufferSize = QMICTLGetVersionInfoReqSize();
+
+   pWriteBuffer = kmalloc( writeBufferSize, GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+
+   // Start read
+   sema_init( &readSem, SEMI_INIT_DEFAULT_VALUE );
+   mb();
+
+   transactionID = QMIXactionIDGet(pDev);
+
+   // Fill buffer
+   result = QMICTLGetVersionInfoReq( pWriteBuffer,
+                            writeBufferSize,
+                            transactionID);
+
+   if (result < 0)
+   {
+      kfree( pWriteBuffer );
+      return result;
+   }
+
+   DBG("Sending QMI CTL Get Version Info Request, TransactionID: 0x%x\n", transactionID );
+
+   result = ReadAsync( pDev, QMICTL, transactionID, UpSem, &readSem ,1);
+   
+   if (result == 0) {
+       WriteSync( pDev,
+              pWriteBuffer,
+              writeBufferSize,
+              QMICTL );
+   }
+
+   kfree( pWriteBuffer );
+   wait_control_msg_semaphore_timeout(&readSem,QMI_CONTROL_MAX_MSG_DELAY_MS);
+   mb();
+   // Enter critical section
+   flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+   spin_lock_irq(&(pDev->notif_lock));
+   barrier();
+   if (down_trylock( &readSem ) == 0)
+   {
+      // Pop the read data
+      if (PopFromReadMemList( pDev,
+                              QMICTL,
+                              transactionID,
+                              &pReadBuffer,
+                              &readBufferSize ) == true)
+      {
+         // Success
+         PrintHex(pReadBuffer, readBufferSize);
+         spin_unlock_irq(&(pDev->notif_lock));
+
+         // End critical section
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+
+         // We care about the result: call Response  function
+         result = QMICTLGetVersionInfoResp(
+                      pReadBuffer,
+                      readBufferSize,
+                      &pDev->svcVersion[0], 
+                      sizeof(pDev->svcVersion));        
+
+         if(pReadBuffer)
+             kfree( pReadBuffer );
+
+         if (result != 0)
+         {
+            DBG( "Could not parse version info correctly in QMI response %d\n",result );
+            return result;
+         }
+      }
+      else
+      {
+         // Read mismatch/failure, unlock and continue
+         RemoveAndPopNotifyList(pDev,QMICTL,0,eClearCID);
+         spin_unlock_irq(&(pDev->notif_lock));
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         result = -1;
+      }
+   }
+   else
+   {
+      // Timeout, remove the async read
+      RemoveAndPopNotifyList(pDev,QMICTL,0,eClearCID);
+      spin_unlock_irq(&(pDev->notif_lock));
+      // End critical section
+      LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+      result = -1;
+   }
+
+   if (result < 0)
+   {
+      DBG( "QMI CTL Get Version Info error code %d\n", result );
+      return result;
+   }
+
+   // Success
+   return 0;
+}
+/*===========================================================================
+METHOD:
+   QMIWDASetDataFormat (Public Method)
+
+DESCRIPTION:
+   Register WDA client
+   send Data format request and parse response
+   Release WDA client
+
+PARAMETERS:
+   pDev            [ I ] - Device specific memory
+   te_flow_control [ I ] - TE Flow Control Flag
+   iqmuxenable     [ I ] - QMUX Control Flag
+RETURN VALUE:
+   int - 0 for success
+            Negative errno for failure
+===========================================================================*/
+int QMIWDASetDataFormat( sGobiUSBNet * pDev, int te_flow_control , int iqmuxenable)
+{
+   int result;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   void * pReadBuffer;
+   u16 readBufferSize;
+   u16 WDAClientID;
+   unsigned long flags;
+   struct semaphore readSem;
+   u16 uTID=1;
+   //DBG("\n");
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device\n" );
+      return -EFAULT;
+   }
+   barrier();
+   sema_init( &readSem, SEMI_INIT_DEFAULT_VALUE );
+   mb();
+   result = GetClientID( pDev, QMIWDA ,NULL);
+   if (result < 0)
+   {
+      return result;
+   }
+   WDAClientID = result;
+
+   // QMI WDA Set Data Format Request
+   writeBufferSize = QMIWDASetDataFormatReqSize(te_flow_control,iqmuxenable);
+   pWriteBuffer = kmalloc( writeBufferSize, GOBI_GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      ReleaseClientID( pDev, WDAClientID );
+      return -ENOMEM;
+   }
+
+   result = QMIWDASetDataFormatReq( pWriteBuffer,
+                                    writeBufferSize,
+                                    uTID,
+                                    te_flow_control,
+                                    pDev->iDataMode,
+                                    pDev->mpIntf->cur_altsetting->desc.bInterfaceNumber,
+                                    iqmuxenable);
+   if (result < 0)
+   {
+      kfree( pWriteBuffer );
+      ReleaseClientID( pDev, WDAClientID );
+      return result;
+   }
+
+   result = ReadAsync( pDev, WDAClientID, uTID, UpSem, &readSem ,1);
+   if(result == 0)
+   {
+      result = WriteSync( pDev,
+                          pWriteBuffer,
+                          writeBufferSize,
+                          WDAClientID );
+   }
+   if(pWriteBuffer)
+   {
+      kfree( pWriteBuffer );
+      pWriteBuffer = NULL;
+   }
+   if (result < 0)
+   {
+      DBG( "WriteSync Fail\n" );
+      ReleaseClientID( pDev, WDAClientID );
+      return result;
+   }
+   wait_control_msg_semaphore_timeout(&readSem,QMI_CONTROL_MAX_MSG_DELAY_MS);
+   mb();
+   flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+   spin_lock_irq(&(pDev->notif_lock));
+   barrier();
+   if (down_trylock( &readSem ) == 0)
+   {
+       // Enter critical section
+         // Pop the read data
+         if (PopFromReadMemList( pDev,
+                                 WDAClientID,
+                                 uTID,
+                                 &pReadBuffer,
+                                 &readBufferSize ) == true)
+         {
+            u32 *pULDatagram = NULL;
+            u32 *pULDatagramSize = NULL;
+            if(iqmuxenable)
+            {
+               pULDatagram = &pDev->ULDatagram;
+               pULDatagramSize = &pDev->ULDatagramSize;
+            }
+            result = QMIWDASetDataFormatResp(pReadBuffer,
+                                                  readBufferSize,
+                                                  pDev->iDataMode,
+                                                  pULDatagram,
+                                                  pULDatagramSize);
+            // We don't care about the result
+            if(pReadBuffer)
+            kfree( pReadBuffer );
+         }
+         else
+         {
+            // Read mismatch/failure, unlock and continue
+            RemoveAndPopNotifyList(pDev,WDAClientID,uTID,eClearAndReleaseCID);
+         }
+   }
+   else
+   {
+      DBG( "Timeout\n" );
+      result = -1;
+      // Timeout, remove the async read
+      barrier();
+      RemoveAndPopNotifyList(pDev,WDAClientID,uTID,eClearAndReleaseCID);
+   }
+   spin_unlock_irq(&(pDev->notif_lock));
+   LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+   if (result < 0)
+   {
+      DBG( "Data Format Cannot be set\n" );
+   }
+   if(iqmuxenable!=0)
+   {
+      /* Set QMAP Aggregation size*/
+      result = QMIWDASetQMAP( pDev , WDAClientID);
+   }
+   ReleaseClientID( pDev, WDAClientID );
+
+   // Success
+   return result;
+}
+
+#define gobi_mdelay_interruptible(n) (\
+   (__builtin_constant_p(n) && (n)<=MAX_UDELAY_MS) ? udelay((n)*1000) : \
+   ({unsigned long __ms=(n); \
+   while (__ms--){ \
+      udelay(1000); \
+      if(signal_pending(current)){\
+         break;\
+      } \
+   };\
+   }))
+
+void wait_ms(unsigned int ms) {
+   if(in_atomic())
+   {
+      DBG("preempt_ensabled\n");
+      return ;
+   }
+   if (!in_interrupt()) 
+   {
+       schedule_timeout_interruptible(1 + ms * HZ / 1000);
+   }
+   else
+   {
+      barrier();
+      gobi_mdelay_interruptible(ms);
+   }
+}
+
+void wait_control_msg_semaphore_timeout(struct semaphore *pSem, unsigned int timeout)
+{
+    unsigned int totaltime = 0;
+    if(pSem==NULL)
+    {
+        return;
+    }
+    do
+    {
+        wait_ms(QMI_CONTROL_MSG_DELAY_MS/2);
+        if (down_trylock( pSem ) == 0)
+        {
+            up(pSem);
+            return;
+        }
+        if(signal_pending(current))
+        {
+            return ;
+        }
+        totaltime +=QMI_CONTROL_MSG_DELAY_MS/2;
+    }while(totaltime<timeout);
+    DBG("wait timeout\n");
+    return ;
+}
+
+/*===========================================================================
+METHOD:
+   RemoveAndPopNotifyList (Public Method)
+
+DESCRIPTION:
+   Remove first Notify entry from this client's notify list
+   and Run function
+
+   Caller MUST have lock on mClientMemLock
+
+PARAMETERS:
+   pDev              [ I ] - Device specific memory
+   clientID          [ I ] - Requester's client ID
+   transactionID     [ I ] - Transaction ID or 0 for any
+
+RETURN VALUE:
+   bool
+===========================================================================*/
+int RemoveAndPopNotifyList(
+   sGobiUSBNet *      pDev,
+   u16              clientID,
+   u16              transactionID ,
+   int              iClearClientID)
+{
+   sClientMemList * pClientMem;
+   sNotifyList * pDelNotifyList, ** ppNotifyList;
+   sClientMemList ** ppDelClientMem;
+   sClientMemList * pNextClientMem;
+   mb();
+   if(pDev==NULL)
+   {
+      DBG("NULL");
+      return eNotifyListEmpty;
+   }
+#ifdef CONFIG_SMP
+   // Verify Lock
+   #if _IGNORE_DISCONNECT_SPIN_LOCK_CHECK_
+   if(!IsDeviceDisconnect(pDev))
+   #endif
+   if (LocalClientMemLockSpinIsLock( pDev ) == 0)
+   {
+      DBG( "unlocked\n" );
+      BUG();
+   }
+#endif
+   do
+   {
+      // Get this client's memory location
+      pClientMem = FindClientMem( pDev, clientID );
+      if (pClientMem == NULL)
+      {
+         DBG( "Could not find this client's memory 0x%04X\n", clientID );
+         return eNotifyListEmpty;
+      }
+
+      ppNotifyList = &(pClientMem->mpReadNotifyList);
+      pDelNotifyList = NULL;
+      // Remove from list
+      CLIENT_READMEM_SNAPSHOT(clientID,pDev);
+      while (*ppNotifyList != NULL)
+      {
+         // Do we care about transaction ID?
+         if (transactionID == 0
+         ||  (*ppNotifyList)->mTransactionID == 0
+         ||  transactionID == (*ppNotifyList)->mTransactionID)
+         {
+            pDelNotifyList = *ppNotifyList;
+            mb();
+            DBG( "Remove Notify TID = %x\n", (*ppNotifyList)->mTransactionID );
+            break;
+         }
+
+         DBG( "skipping data TID = %x\n", (*ppNotifyList)->mTransactionID );
+
+         // next
+         ppNotifyList = &(*ppNotifyList)->mpNext;
+      }
+      mb();
+      if (pDelNotifyList != NULL)
+      {
+         // Remove element
+         *ppNotifyList = (*ppNotifyList)->mpNext;
+         pDelNotifyList->mpNext = NULL;
+         pDelNotifyList->mpNotifyFunct = NULL;
+         pDelNotifyList->mpData = NULL;
+         pDelNotifyList->mTransactionID = 0;
+         // Delete memory
+         kfree( pDelNotifyList );
+         pDelNotifyList = NULL;
+         mb();
+      }
+      else
+      {
+         void *pFreeData = NULL;
+         u16 FreeDataSize;
+         //Remove From memory List
+         while(PopFromReadMemList( pDev,
+             clientID,
+             transactionID,
+             &pFreeData,
+             &FreeDataSize ) == true )
+         {
+             DBG( "Remove Mem ClientID: 0x%x, data TID = 0x%x\n", clientID,transactionID);
+             kfree( pFreeData );
+             pFreeData = NULL;
+         }
+         DBG( "no one to notify for TID 0x%x\n", transactionID );
+         mb();
+         break;//return eNotifyListEmpty;
+      }
+   }while(ppNotifyList!=NULL);
+
+
+   ppDelClientMem = &pDev->mQMIDev.mpClientMemList;
+   while (*ppDelClientMem != NULL)
+   {
+      if ((*ppDelClientMem)->mClientID == clientID)
+      {
+         pNextClientMem = (*ppDelClientMem)->mpNext;
+         kfree( *ppDelClientMem );
+         *ppDelClientMem = NULL;
+
+         // Overwrite the pointer that was to this client mem
+         *ppDelClientMem = pNextClientMem;
+      }
+      else
+      {
+         // I now point to (a pointer of ((the node I was at)'s mpNext))
+          if(*ppDelClientMem==NULL)
+          {
+              DBG("ppDelClientMem NULL %d\r\n",__LINE__);
+              break;
+          }
+         ppDelClientMem = &(*ppDelClientMem)->mpNext;
+      }
+      mb();
+   }
+   mb();
+   return eNotifyListEmpty;
+}
+
+/*===========================================================================
+METHOD:
+   SetPowerSaveMode (Public Method)
+
+DESCRIPTION:
+   Set mode in power save mode
+
+PARAMETERS:
+   pDev     [ I ] - Device specific memory
+   mode     [ I ] - power save mode, 0:wakeup ; 1:suspend
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for failure
+===========================================================================*/
+int SetPowerSaveMode(sGobiUSBNet *pDev,u8 mode)
+{
+   int result;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   void * pReadBuffer;
+   u16 readBufferSize;
+   u8 transactionID;
+   unsigned long flags;
+   struct semaphore readSem;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      printk(KERN_ERR "Invalid device!\n" );
+      return -ENXIO;
+   }
+
+   if(iIsRemoteWakeupSupport(pDev->mpNetDev)==0)
+   {
+      DBG("remote wakeup not supported\n");
+      return 0;
+   }
+   sema_init( &readSem, SEMI_INIT_DEFAULT_VALUE );
+   mb();
+   writeBufferSize = QMICTLSetPowerSaveModeReqSize();
+   pWriteBuffer = kmalloc( writeBufferSize, GOBI_GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+
+   transactionID = QMIXactionIDGet(pDev);
+   result = ReadAsync( pDev, QMICTL, transactionID, UpSem, &readSem ,1);
+
+    result = QMICTLSetPowerSaveModeReq(pWriteBuffer,
+                                     writeBufferSize,
+                                     transactionID,
+                                     mode );
+   if (result < 0)
+   {
+       kfree( pWriteBuffer );
+       return result;
+   }
+   result = WriteSyncNoResume( pDev,
+          pWriteBuffer,
+          writeBufferSize,
+          QMICTL );
+   kfree( pWriteBuffer );
+
+   if (result < 0)
+   {
+        DBG( "bad write data %d\n", result );
+        return result;
+   }
+   wait_control_msg_semaphore_timeout(&readSem, QMI_CONTROL_MAX_MSG_DELAY_MS);
+   mb();
+   // Enter critical section
+   flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+   spin_lock_irq(&(pDev->notif_lock));
+   barrier();
+   if (down_trylock( &readSem ) == 0)
+   {
+      // Pop the read data
+      if (PopFromReadMemList( pDev,
+                              QMICTL,
+                              transactionID,
+                              &pReadBuffer,
+                              &readBufferSize ) == true)
+      {
+         // Success
+         spin_unlock_irq(&(pDev->notif_lock));
+         // End critical section
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         result = QMICTLSetPowerSaveModeResp(pReadBuffer,
+                                               readBufferSize);
+    
+         // We don't care about the result
+         if(pReadBuffer)
+         kfree( pReadBuffer );
+         return result;
+      }
+      else
+      {
+         // Read mismatch/failure, unlock and continue
+         RemoveAndPopNotifyList(pDev,QMICTL,0,eClearAndReleaseCID);
+      }
+   }
+   else
+   {
+      // Timeout, remove the async read
+      RemoveAndPopNotifyList(pDev,QMICTL,0,eClearAndReleaseCID);
+      // End critical section
+      result = -1;
+   }
+   spin_unlock_irq(&(pDev->notif_lock));
+   LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+   return result;
+
+}
+
+/*==========================================================================
+METHOD:
+   WriteSyncNoResume (Public Method)
+
+DESCRIPTION:
+   Start synchronous write without resume device
+
+PARAMETERS:
+   pDev                 [ I ] - Device specific memory
+   pWriteBuffer         [ I ] - Data to be written
+   writeBufferSize      [ I ] - Size of data to be written
+   clientID             [ I ] - Client ID of requester
+
+RETURN VALUE:
+   int - write size (includes QMUX)
+         negative errno for failure
+============================================================================*/
+int WriteSyncNoResume(
+   sGobiUSBNet *          pDev,
+   char *                 pWriteBuffer,
+   int                    writeBufferSize,
+   u16                    clientID )
+{
+   int i;
+   int result;
+   int iLockRetry =0;
+   //DBG("\n");
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return -ENXIO;
+   }
+   if(IsDeviceDisconnect(pDev))
+   {
+      DBG( "Device Disconnected!\n" );
+      return -ENXIO;
+   }
+   if (pDev->mbUnload >= eStatUnloading)
+   {
+      DBG( "Unloading device!\n" );
+      return -ENXIO;
+   }
+   // Fill writeBuffer with QMUX
+   result = FillQMUX( clientID, pWriteBuffer, writeBufferSize );
+   if (result < 0)
+   {
+      return result;
+   }
+
+   // Wake device
+   #ifdef CONFIG_PM
+   UsbAutopmGetInterface( pDev->mpIntf );
+   #else
+   gobi_usb_autopm_get_interface( pDev->mpIntf );
+   #endif
+
+   DBG( "Actual Write:\n" );
+   PrintHex( pWriteBuffer, writeBufferSize );
+
+   // Write Control URB, protect with read semaphore to track in-flight USB control writes in case of disconnect
+   for(i=0;i<USB_WRITE_RETRY;i++)
+   {
+      
+      if(isModuleUnload(pDev))
+      {
+         DBG( "unloaded\n" );
+         return -EFAULT;
+      }
+      pDev->iShutdown_read_sem= __LINE__;
+      if(signal_pending(current))
+      {
+         return -ERESTARTSYS;
+      }
+
+      iLockRetry = 0;
+      mb();
+      while(down_read_trylock(&(pDev->shutdown_rwsem))!=1)
+      {
+         wait_ms(5);
+         mb();
+         if(iLockRetry++>100)
+         {
+            DBG("down_read_trylock timeout");
+            return -EFAULT;
+         }
+         if(pDev==NULL)
+         {
+            DBG( "NULL\n" );
+            return -EFAULT;
+         }
+         if (pDev->mbUnload >= eStatUnloading)
+         {
+            DBG( "unloaded\n" );
+            return -EFAULT;
+         }
+      }
+      mb();
+      result = Gobi_usb_control_msg(pDev->mpIntf, pDev->mpNetDev->udev, usb_sndctrlpipe( pDev->mpNetDev->udev, 0 ),
+             SEND_ENCAPSULATED_COMMAND,
+             USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+             0, pDev->mpIntf->cur_altsetting->desc.bInterfaceNumber,
+             (void*)pWriteBuffer, writeBufferSize,
+             USB_WRITE_TIMEOUT );
+       up_read(&pDev->shutdown_rwsem);
+       if(signal_pending(current))
+       {
+          return -ERESTARTSYS;
+       }
+       if (IsDeviceDisconnect(pDev) )
+       {
+         return -ENXIO;
+       }
+       if(pDev==NULL)
+       {
+          return -EFAULT;
+       }
+       
+       pDev->iShutdown_read_sem=- __LINE__;
+       
+       if (pDev->mbUnload >= eStatUnloading)
+       {
+          DBG( "unloaded\n" );
+          return -EFAULT;
+       }
+
+       if (signal_pending(current))
+       {
+           return -ERESTARTSYS;
+       }
+
+       if (result < 0)
+       {
+          printk(KERN_WARNING "usb_control_msg failed (%d)", result);
+       }
+       // Control write transfer may occasionally timeout with certain HCIs, attempt a second time before reporting an error
+       if (result == -ETIMEDOUT)
+       {
+           pDev->writeTimeoutCnt++;
+           printk(KERN_WARNING "Write URB timeout, cnt(%d)\n", pDev->writeTimeoutCnt);
+       }
+       else if(result < 0 )
+       {
+          DBG( "%s no device!\n" ,__FUNCTION__);
+           return result;
+       }
+       else
+       {
+           break;
+       }
+       if (IsDeviceValid( pDev ) == false)
+       {
+          DBG( "%s Invalid device!\n" ,__FUNCTION__);
+          return -ENXIO;
+       }
+       if (pDev->mbUnload > eStatUnloading)
+       {
+         DBG( "unloaded\n" );
+         return -EFAULT;
+       }
+   }
+
+   // Write is done, release device
+   UsbAutopmPutInterface(pDev->mpIntf);
+   return result;
+}
+
+int ReleaseNotifyList(sGobiUSBNet *pDev,u16 clientID,u8 transactionID)
+{
+   unsigned long flags;
+   flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+   // Timeout, remove the async read
+   NotifyAndPopNotifyList( pDev, clientID, transactionID );
+   // End critical section
+   LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+   return 0;
+}
+
+#ifdef CONFIG_PM
+/*===========================================================================
+METHOD:
+   ConfigPowerSaveSettings (Public Method)
+
+DESCRIPTION:
+   Set modem power save mode config
+
+PARAMETERS:
+   pDev      [ I ] - Device specific memory
+   service   [ I ] - QMI service number
+   indication[ I ] - QMI indication number
+
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for failure
+===========================================================================*/
+int ConfigPowerSaveSettings(sGobiUSBNet *pDev, u8 service, u8 indication)
+{
+   int result;
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   void * pReadBuffer;
+   u16 readBufferSize;
+   u8 transactionID;
+   unsigned long flags;
+   struct semaphore readSem;
+   
+   if (IsDeviceValid(pDev) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return -ENXIO;
+   }
+   
+   if(iIsRemoteWakeupSupport(pDev->mpNetDev)==0)
+   {
+      DBG("remote wakeup not supported\n");
+      return 0;
+   }
+   
+   sema_init( &readSem, SEMI_INIT_DEFAULT_VALUE );
+   mb();
+
+   writeBufferSize = QMICTLConfigPowerSaveSettingsReqSize();
+   pWriteBuffer = kmalloc( writeBufferSize, GOBI_GFP_KERNEL );
+   if (pWriteBuffer == NULL)
+   {
+      return -ENOMEM;
+   }
+    
+    transactionID = QMIXactionIDGet(pDev);
+    result = ReadAsync( pDev, QMICTL, transactionID, UpSem, &readSem ,1);
+    result = QMICTLConfigPowerSaveSettingsReq(pWriteBuffer,
+                                              writeBufferSize,
+                                              transactionID,
+                                              service,
+                                              indication);
+    if (result < 0)
+    {
+        kfree( pWriteBuffer );
+        return result;
+    }
+
+    result = WriteSyncNoResume( pDev,
+                      pWriteBuffer,
+                      writeBufferSize,
+                      QMICTL );
+    kfree( pWriteBuffer );
+
+   if (result < 0)
+   {
+       DBG( "bad write data %d\n", result );
+       return result;
+   }
+   wait_control_msg_semaphore_timeout(&readSem,QMI_CONTROL_MAX_MSG_DELAY_MS);
+   mb();
+   // Enter critical section
+   flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+   spin_lock_irq(&(pDev->notif_lock));
+   barrier();
+   if (down_trylock( &readSem ) == 0)
+   {
+      // Pop the read data
+      if (PopFromReadMemList( pDev,
+                              QMICTL,
+                              transactionID,
+                              &pReadBuffer,
+                              &readBufferSize ) == true)
+      {
+         // Success
+         spin_unlock_irq(&(pDev->notif_lock));
+         // End critical section
+         LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+         result = QMICTLConfigPowerSaveSettingsResp(pReadBuffer,
+                                               readBufferSize);
+    
+         // We don't care about the result
+         if(pReadBuffer)
+         kfree( pReadBuffer );
+         return result;
+      }
+      else
+      {
+         // Read mismatch/failure, unlock and continue
+         RemoveAndPopNotifyList(pDev,QMICTL,0,eClearAndReleaseCID);
+      }
+    }
+   else
+   {
+      // Timeout, remove the async read
+      RemoveAndPopNotifyList(pDev,QMICTL,0,eClearAndReleaseCID);
+      // End critical section
+      result = -1;
+   }
+   spin_unlock_irq(&(pDev->notif_lock));
+   LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+   return result;
+}
+#endif
+
+void RemoveProcessFile(sGobiUSBNet *pDev)
+{
+   char qcqmi_dev_name[10]={0};
+   if(pDev->mQMIDev.proc_file != NULL)
+   {
+      sprintf(qcqmi_dev_name, "qcqmi%d", (int)pDev->mQMIDev.qcqmi);
+      remove_proc_entry(qcqmi_dev_name, NULL);
+      pDev->mQMIDev.proc_file = NULL;
+      DBG("remove:%s",qcqmi_dev_name);
+   }
+   return;
+}
+
+void RemoveCdev(sGobiUSBNet * pDev)
+{
+   if(pDev->mQMIDev.mbCdevIsInitialized==true)
+   {
+      pDev->mQMIDev.mbCdevIsInitialized=false;
+      if (IS_ERR( pDev->mQMIDev.mpDevClass ) == false)
+      {
+         device_destroy( pDev->mQMIDev.mpDevClass,
+                         pDev->mQMIDev.mDevNum );
+         cdev_del( &pDev->mQMIDev.mCdev );
+         unregister_chrdev_region( pDev->mQMIDev.mDevNum, 1 );
+      }
+   }
+}
+
+/*===========================================================================
+WriteSyncNoRetry
+   WriteSync (Public Method)
+
+DESCRIPTION:
+   Start synchronous write no retry
+
+PARAMETERS:
+   pDev                 [ I ] - Device specific memory
+   pWriteBuffer         [ I ] - Data to be written
+   writeBufferSize      [ I ] - Size of data to be written
+   clientID             [ I ] - Client ID of requester
+
+RETURN VALUE:
+   int - write size (includes QMUX)
+         negative errno for failure
+===========================================================================*/
+int WriteSyncNoRetry(
+   sGobiUSBNet *          pDev,
+   char *                 pWriteBuffer,
+   int                    writeBufferSize,
+   u16                    clientID )
+{
+   int result = -1;
+   int iLockRetry =0;
+
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "Invalid device!\n" );
+      return -ENXIO;
+   }
+   if(IsDeviceDisconnect(pDev))
+   {
+      DBG( "Device Disconnected!\n" );
+      return -ENXIO;
+   }
+   if (pDev->mbUnload >= eStatUnloading)
+   {
+      DBG( "Unloading device!\n" );
+      return -ENXIO;
+   }
+   // Fill writeBuffer with QMUX
+   result = FillQMUX( clientID, pWriteBuffer, writeBufferSize );
+   if (result < 0)
+   {
+      return result;
+   }
+
+   // Wake device
+   result = gobi_usb_autopm_get_interface( pDev->mpIntf );
+   if (result < 0)
+   {
+      DBG( "unable to resume interface: %d\n", result );
+
+      // Likely caused by device going from autosuspend -> full suspend
+      if (result == -EPERM)
+      {
+#ifdef CONFIG_PM
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,33 ))
+         pDev->mpNetDev->udev->auto_pm = 0;
+#endif
+         GobiNetSuspend( pDev->mpIntf, PMSG_SUSPEND );
+#endif /* CONFIG_PM */
+      }
+      return result;
+   }
+
+   DBG( "Actual Write:\n" );
+   PrintHex( pWriteBuffer, writeBufferSize );
+
+  
+  if(isModuleUnload(pDev))
+  {
+     DBG( "unloaded\n" );
+     return -EFAULT;
+  }
+  pDev->iShutdown_read_sem= __LINE__;
+
+  iLockRetry = 0;
+  mb();
+  while(down_read_trylock(&(pDev->shutdown_rwsem))!=1)
+  {
+     wait_ms(5);
+     mb();
+     if(iLockRetry++>100)
+     {
+        DBG("down_read_trylock timeout");
+        return -EFAULT;
+     }
+     if(pDev==NULL)
+     {
+        DBG( "NULL\n" );
+        return -EFAULT;
+     }
+     if (pDev->mbUnload >= eStatUnloading)
+     {
+        DBG( "unloaded\n" );
+        return -EFAULT;
+     }
+  }
+  mb();
+  result = Gobi_usb_control_msg(pDev->mpIntf, pDev->mpNetDev->udev, usb_sndctrlpipe( pDev->mpNetDev->udev, 0 ),
+         SEND_ENCAPSULATED_COMMAND,
+         USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+         0, pDev->mpIntf->cur_altsetting->desc.bInterfaceNumber,
+         (void*)pWriteBuffer, writeBufferSize,
+         50 );//50ms timeout
+   up_read(&pDev->shutdown_rwsem);
+   if(signal_pending(current))
+   {
+      return -ERESTARTSYS;
+   }
+   if (IsDeviceDisconnect(pDev) )
+   {
+      return -ENXIO;
+   }
+   if(pDev==NULL)
+   {
+      return -EFAULT;
+   }
+   
+   pDev->iShutdown_read_sem=- __LINE__;
+   
+   if (pDev->mbUnload >= eStatUnloading)
+   {
+      DBG( "unloaded\n" );
+      return -EFAULT;
+   }
+   if (result < 0)
+   {
+      printk(KERN_WARNING "usb_control_msg failed (%d)", result);
+   }
+   // Control write transfer may occasionally timeout with certain HCIs, attempt a second time before reporting an error
+   if (result == -ETIMEDOUT)
+   {
+       pDev->writeTimeoutCnt++;
+       printk(KERN_WARNING "Write URB timeout, cnt(%d)\n", pDev->writeTimeoutCnt);
+   }
+   else if(result < 0 )
+   {
+      DBG( "%s no device!\n" ,__FUNCTION__);
+      gobi_usb_autopm_put_interface( pDev->mpIntf );
+       return result;
+   }
+   
+   if (IsDeviceValid( pDev ) == false)
+   {
+      DBG( "%s Invalid device!\n" ,__FUNCTION__);
+      return -ENXIO;
+   }
+   if (pDev->mbUnload > eStatUnloading)
+   {
+     DBG( "unloaded\n" );
+     return -EFAULT;
+   }
+
+   // Write is done, release device
+   gobi_usb_autopm_put_interface( pDev->mpIntf );
+
+
+   return result;
+}
+
+int Gobi_usb_control_msg(struct usb_interface *intf,struct usb_device *dev, unsigned int pipe, __u8 request,
+                     __u8 requesttype, __u16 value, __u16 index, void *data,
+                      __u16 size, int timeout)
+{
+   if(dev==NULL)
+   return -ENODEV;
+   mb();
+   if(intf==NULL)
+      return -ENODEV;
+   #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,33 ))
+   if(intf->resetting_device)
+   {
+      return -ENXIO;
+   }
+   #endif
+   if (dev->parent->state == USB_STATE_NOTATTACHED )
+   {
+      return -ENXIO;
+   }
+   if (dev->state == USB_STATE_NOTATTACHED )
+   {
+      return -ENXIO;
+   }
+   return usb_control_msg(dev,pipe,request,requesttype,value,index,data,size,timeout);
+      
+}
+
+bool IsDeviceDisconnect(sGobiUSBNet *pDev)
+{
+   if(!pDev)
+      return true;
+   mb();
+   #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,33 ))
+   if(pDev->mpIntf==NULL)
+   {
+      return true;
+   }
+   if(pDev->mpIntf->resetting_device)
+   {
+      pDev->iUSBState = USB_STATE_NOTATTACHED;
+      mb();
+      return true;
+   }
+   #endif
+   if(pDev->iUSBState == USB_STATE_NOTATTACHED)
+      return true;
+   if(!interface_to_usbdev(pDev->mpIntf))
+      return true;
+   if (interface_to_usbdev(pDev->mpIntf)->state == USB_STATE_NOTATTACHED )
+   {
+      pDev->iUSBState = USB_STATE_NOTATTACHED;
+      mb();
+      return true;
+   }
+   if(pDev->mpIntf->condition == USB_INTERFACE_UNBINDING)
+   {
+      pDev->iUSBState = USB_STATE_NOTATTACHED;
+      mb();
+      return true;
+   }
+   if(pDev->mpIntf->condition == USB_INTERFACE_UNBOUND)
+   {
+      pDev->iUSBState = USB_STATE_NOTATTACHED;
+      mb();
+      return true;
+   }
+   return false;
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,33 ))
+void gobi_usb_autopm_enable(struct usb_interface *intf)
+{
+   if(IsInterfacefDisconnected(intf))
+   {
+      return ;
+   }
+   usb_autopm_enable( intf );
+}
+#endif
+void gobi_usb_autopm_put_interface(struct usb_interface *intf)
+{
+   if(IsInterfacefDisconnected(intf))
+   {
+      return ;
+   }
+   usb_autopm_put_interface(intf);
+}
+
+int gobi_usb_autopm_get_interface_async(struct usb_interface *intf)
+{
+   if(IsInterfacefDisconnected(intf))
+   {
+      return -ENXIO;
+   }
+   return usb_autopm_get_interface_async(intf);
+}
+
+void gobi_usb_autopm_get_interface_no_resume(struct usb_interface *intf)
+{
+   if(IsInterfacefDisconnected(intf))
+   {
+      return ;
+   }
+   #if (LINUX_VERSION_CODE < KERNEL_VERSION( 3,0,0 ))
+   usb_autopm_get_interface_async(intf);
+   return ;
+   #else
+   usb_autopm_get_interface_no_resume(intf);
+   #endif
+}
+
+void gobi_usb_autopm_put_interface_no_resume(struct usb_interface *intf)
+{
+   if(IsInterfacefDisconnected(intf))
+   {
+      return ;
+   }
+   #if (LINUX_VERSION_CODE < KERNEL_VERSION( 3,0,0 ))
+   usb_autopm_put_interface_async(intf);
+   return ;
+   #else
+   usb_autopm_put_interface_no_suspend(intf);
+   #endif
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,29 ))
+void usb_autopm_put_interface_async(struct usb_interface *intf)
+{
+   struct usb_device   *udev = interface_to_usbdev(intf);
+   int         status = 0;
+
+   if (intf->condition == USB_INTERFACE_UNBOUND) {
+      status = -ENODEV;
+   } else {
+      udev->last_busy = jiffies;
+      --intf->pm_usage_cnt;
+      if (udev->autosuspend_disabled || udev->autosuspend_delay < 0)
+         status = -EPERM;
+      else if (intf->pm_usage_cnt <= 0 &&
+            !timer_pending(&udev->autosuspend.timer)) {
+         queue_delayed_work(ksuspend_usb_wq, &udev->autosuspend,
+               round_jiffies_up_relative(
+                  udev->autosuspend_delay));
+      }
+   }
+}
+#endif
+void gobi_usb_autopm_put_interface_async(struct usb_interface *intf)
+{
+   if(IsInterfacefDisconnected(intf))
+   {
+      return ;
+   }
+   
+   usb_autopm_put_interface_async(intf);
+}
+
+struct net_device* gobi_qmimux_register_device(struct net_device *real_dev,int iNumber, u8 mux_id)
+{
+   struct net_device *new_dev;
+   struct gobi_qmimux_priv *priv;
+   int err;
+   char szName[64]={0};
+   DBG("Create 0x%x\n",mux_id);
+   snprintf(szName,63,"gobi-%d-%d",iNumber,mux_id-MUX_ID_START);
+   #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,18,0 ))
+   new_dev = alloc_netdev(sizeof(struct gobi_qmimux_priv),
+                szName, NET_NAME_UNKNOWN, ether_setup);
+   #else
+   new_dev = alloc_netdev(sizeof(struct gobi_qmimux_priv),
+                          szName, ether_setup);
+   #endif
+   if(!new_dev)
+   {
+      printk(KERN_WARNING "Memory error alloc netdev");
+      return NULL;
+   }
+   new_dev->netdev_ops = &gobi_qmimux_netdev_ops;
+   new_dev->flags           = IFF_NOARP | IFF_MULTICAST;
+   random_ether_addr(new_dev->dev_addr);
+   if (!new_dev)
+      return NULL;
+   priv = netdev_priv(new_dev);
+   priv->mux_id = mux_id;
+   priv->real_dev = real_dev;
+   new_dev->irq = real_dev->irq;
+
+   err = register_netdevice(new_dev);
+   if (err < 0)
+      goto out_free_newdev;
+   dev_hold(real_dev);
+   return new_dev;
+
+out_free_newdev:
+   free_netdev(new_dev);
+   return NULL;
+}
+
+void gobi_qmimux_unregister_device(struct net_device *dev)
+{
+   struct gobi_qmimux_priv *priv = netdev_priv(dev);
+   struct net_device *real_dev = priv->real_dev;
+   netif_carrier_off(dev);
+   netif_stop_queue(dev);
+   netif_dormant_off(dev);
+   dev_close(dev);
+   netif_device_detach(dev);
+   unregister_netdevice(dev);
+   /* Get rid of the reference to real_dev */
+   dev_put(real_dev);   
+}
+
+int iIsValidQmuxSKB(struct sk_buff *skb)
+{
+   if(!skb)
+      return 0;
+   if(skb->len >= QMUX_HEADER_LENGTH)
+   {
+      return iNumberOfQmuxPacket(skb,0);
+   }
+   return 0;
+}
+
+int PrintQmuxPacket(struct sk_buff *skb)
+{
+   unsigned int offset=0;
+   return 0;
+   NETDBG("SKB->len:%d\n",skb->len);
+   if(skb->len >= QMUX_HEADER_LENGTH)
+   {
+      u32 length = skb->data[2];
+      length = (length<<8) + skb->data[3];
+      //To Fix Incomming packet larger than expected.
+      if(length==(skb->len-QMUX_HEADER_LENGTH))
+      {
+         if(iIsValidQMAPHeaderInSKBData(skb,0)==1)
+         {
+            return 1;
+         }
+         else if((skb->data[0]<0x80)
+         &&(skb->data[1]==0))
+         {
+            return 1;
+         }
+         else
+         {
+            PrintHex (skb->data, skb->len);
+         }
+         return 0;
+      }
+      else if(length<(skb->len-QMUX_HEADER_LENGTH))//
+      {
+         int iNumberOfPacket=1;
+         offset += length + QMUX_HEADER_LENGTH;
+         do
+         {
+            length = skb->data[offset+2];
+            length = (length<<8) + skb->data[offset+3];
+            if((skb->data[offset]!=0)&&(skb->data[offset+1]!=0)&&
+               (skb->data[offset+2]!=0)&&(skb->data[offset+3]!=0))
+            {
+               NETDBG("offset:%d, %02X%02X%02X%02X:length:%d\n",
+                  offset,
+               skb->data[offset],skb->data[offset+1],skb->data[offset+2],skb->data[offset+3]
+               ,length);
+            }
+            if(length==0)
+            {
+               if((skb->data[offset]<0x80)
+               &&(skb->data[offset+1]&0x8F))
+               {
+                  iNumberOfPacket++;
+               }
+               else if((skb->data[offset]<0x80)
+                  &&(skb->data[offset+1]==0))
+               {
+                  iNumberOfPacket++;
+               }
+               else
+               {
+                  return iNumberOfPacket;
+               }
+               if((length+offset)==(skb->len-QMUX_HEADER_LENGTH))
+               {
+                  return iNumberOfPacket;
+               }
+            }
+            offset += length +QMUX_HEADER_LENGTH;
+         }while(offset < skb->len);
+         NETDBG("\niNumberOfPacket:%d\n",iNumberOfPacket);
+         return iNumberOfPacket;
+      }
+      else
+      {
+         NETDBG("Length Not matched.\n");
+      }
+   }
+   return 0;
+}
+
+int iIsQmuxZeroPacket(struct sk_buff *skb)
+{
+   if(skb==NULL)
+      return 0;
+   if(skb->len >= QMUX_HEADER_LENGTH)
+   {
+      u32 length = skb->data[2];
+      length = (length<<8) + skb->data[3];
+      if(length==0)
+      {
+         if((skb->data[0]==0)
+         &&(skb->data[1]==0))
+         {
+            return 1;
+         }
+      }
+   }
+   return 0;
+}
+
+int iIsQmuxPacketComplete(struct sk_buff *skb)
+{
+   if(skb==NULL)
+      return 0;
+   if(skb->len >= QMUX_HEADER_LENGTH)
+   {
+      u32 length = skb->data[2];
+      length = (length<<8) + skb->data[3];
+      if(length==(skb->len-QMUX_HEADER_LENGTH))
+      {
+         if(iIsValidQMAPHeaderInSKBData(skb,0)==1)
+         {
+            return 1;
+         }
+      }
+      else if(length<=(skb->len-QMUX_HEADER_LENGTH))//
+      {
+         if(iIsValidQMAPHeaderInSKBData(skb,0)==1)
+         {
+            return 1;
+         }
+      }
+      else
+      {
+         DBG("Length Not matched.\n");
+         if(iIsValidQMAPHeaderInSKBData(skb,0)==1)
+         {
+            return 0;
+         }
+      }
+   }
+   return 0;
+}
+
+int iNumberOfQmuxPacket(struct sk_buff *skb,int iDisplay)
+{
+   unsigned int offset=0;
+   if(!skb)
+      return 0;
+   if(iDisplay==1)
+   {
+      DBG("Packet Len: 0x%x\n",skb->len);
+      PrintHex(skb->data,skb->len);
+   }
+   if(skb->len >= QMUX_HEADER_LENGTH)
+   {
+      //To Fix Incomming packet larger than expected.
+      u32 length = skb->data[2];
+      length = (length<<8) + skb->data[3];
+      if(length==(skb->len-QMUX_HEADER_LENGTH))
+      {
+         if(iIsValidQMAPHeaderInSKBData(skb,0)==1)
+         {
+            return 1;
+         }
+         else
+         {
+            PrintHex (skb->data, skb->len);
+         }
+         NETDBG("Single Packet:");
+         NetHex(skb->data,4);
+         return 0;
+      }
+      else if(length<(skb->len-QMUX_HEADER_LENGTH))//
+      {
+         int iNumberOfPacket=1;         
+         if(iIsValidQMAPHeaderInSKBData(skb,0)==1)
+         {
+            iNumberOfPacket=1;
+            NETDBG("%d. Packet: %02X%02X %02X%02X .. \n",iNumberOfPacket ,
+               skb->data[offset],
+               skb->data[offset+1],
+               skb->data[offset+2],
+               skb->data[offset+3]);
+         }
+         else
+         {
+            NETDBG("%s:%d Invalid QMAP Packet\n",__FUNCTION__,__LINE__);
+               NETDBG("%d. Packet: %02X%02X %02X%02X .. \n",0,
+               skb->data[offset],
+               skb->data[offset+1],
+               skb->data[offset+2],
+               skb->data[offset+3]);
+            return 0;
+         }
+         offset += length + QMUX_HEADER_LENGTH;
+         do
+         {
+            NETDBG("%d. Packet: %02X%02X %02X%02X .. \n",iNumberOfPacket+1,
+               skb->data[offset],
+               skb->data[offset+1],
+               skb->data[offset+2],
+               skb->data[offset+3]);
+            length = skb->data[offset+2];
+            length = (length<<8) + skb->data[offset+3];
+            NETDBG("iNumberOfPacket:%d, offset:%d/%d len:0x%x\n",
+               iNumberOfPacket,offset
+                  ,skb->len
+                  ,length)
+            if(length>skb->len-offset-QMUX_HEADER_LENGTH)
+            {
+               NETDBG("iNumberOfPacket:%d, offset:%d/%d delta:0x%x\n",
+                  iNumberOfPacket,offset
+                  ,skb->len
+                  ,length-(skb->len-offset-QMUX_HEADER_LENGTH));
+               return iNumberOfPacket;
+            }
+            offset += length +QMUX_HEADER_LENGTH;
+            iNumberOfPacket++;
+         }while(offset < skb->len);
+         return iNumberOfPacket;
+      }
+      else
+      {
+         NETDBG("Length Not matched.\n");
+         NETDBG("Incomplete QMAP Packet %s:%d\n",__FUNCTION__,__LINE__);
+         if(iIsValidQMAPHeaderInSKBData(skb,0)==1)
+         {
+            NETDBG("%d. Packet: %02X%02X %02X%02X .. \n",0,
+               skb->data[offset],
+               skb->data[offset+1],
+               skb->data[offset+2],
+               skb->data[offset+3]);
+            return 0;
+         }
+         NETDBG("Unknown Packet: %02X%02X %02X%02X .. \n",
+               skb->data[offset],
+               skb->data[offset+1],
+               skb->data[offset+2],
+               skb->data[offset+3]);
+         return -1;
+      }
+   }
+   return -1;
+}
+
+/***********************************
+         0 - Request, i.e., sender is sending a 
+             QMAP control command to the receiver.
+         1 - Ack, i.e., receiver is acknowledging that 
+             it received a QMAP control command and that 
+            it successfully processed the command.
+         2 - Unsupported command, i.e., receiver does 
+             not support this QMAP control command.
+         3 - Invalid command, i.e., receiver encountered 
+             an error while processing the QMAP control command, 
+             probably because QMAP control command is malformed.
+      **************************************/
+int iGetQmuxIDFromSKB(struct sk_buff *skb)
+{
+   if(iIsValidQmuxSKB(skb))
+   {
+      return (int)skb->data[1];
+   }
+   return -1;
+}
+
+u32 u32GetSKBQMAPPacketLength(struct sk_buff *skb,int iOffset)
+{
+   if(skb==NULL)      
+      return 0;
+   if(skb->len < QMUX_HEADER_LENGTH)   
+   {      
+      return 0;   
+   }
+   else if(iOffset>skb->len)
+   {
+      return 0;
+   }
+   else   
+   {      
+      u32 length = skb->data[iOffset+2];
+      length = (length<<8) + skb->data[iOffset+3];
+      return length;   
+   }   
+   return 0;
+}
+
+int iIsValidQMAPHeaderInSKBData(struct sk_buff *pSKB, int iOffset)
+{
+   if(iOffset<0)
+      return 0;
+   if(!pSKB)
+      return 0;
+   if(pSKB->len<QMUX_HEADER_LENGTH)
+   {
+      return 0;
+   }
+   if(pSKB->len<iOffset +QMUX_HEADER_LENGTH)
+   {
+      return 0;
+   }
+   if((pSKB->data[iOffset+1]&0x8F)||
+      (pSKB->data[iOffset+1]==0x00))
+   {
+      //Downlink padding bytes Less or equal 64 Bytes
+      if(pSKB->data[iOffset] > QMAP_MAX_PADDING_BYTES)
+      {
+         return 0;
+      }
+      else
+      {
+         return 1;
+      }
+   }
+   return 0;
+}
+
+int iIsCMDQMAPHeaderInSKBData(struct sk_buff *pSKB, int iOffset)
+{
+   u32 length = 0;
+   if(iOffset<0)
+      return 0;
+   if(!pSKB)
+      return 0;
+   if(pSKB->len<QMUX_HEADER_LENGTH)
+   {
+      return 0;
+   }
+   length = u32GetSKBQMAPPacketLength(pSKB,iOffset);
+   if(pSKB->len < length)
+   {
+      return 0;
+   }
+   if(pSKB->data[iOffset]==0x80)
+   {
+      return 1;
+   }
+   return 0;
+}
+
+
+int iIsZeroQMAPHeaderInSKBData(struct sk_buff *pSKB, int iOffset)
+{
+   if(iOffset<0)
+      return 0;
+   if(!pSKB)
+      return 0;
+   if(pSKB->len<QMUX_HEADER_LENGTH)
+   {
+      return 0;
+   }
+   if(pSKB->len!=iOffset +QMUX_HEADER_LENGTH)
+   {
+      return 0;
+   }
+   if((pSKB->data[iOffset]==0x00)
+         &&(pSKB->data[iOffset+1]==0x00)
+         &&(pSKB->data[iOffset+2]==0x00)
+         &&(pSKB->data[iOffset+3]==0x00))
+   {
+      return 1;
+   }
+   return 0;
+}
+
+/*===========================================================================
+METHOD:
+   NetHex (Public Method)
+
+DESCRIPTION:
+   Print Hex data, for QMAP debug purposes
+
+PARAMETERS:
+   pBuffer       [ I ] - Data buffer
+   bufSize       [ I ] - Size of data buffer
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void NetHex(
+   void *      pBuffer,
+   u16         bufSize )
+{
+   char * pPrintBuf;
+   u16 pos;
+   int status;
+   if(!(debug & DEBUG_NETMASK))
+      return ;
+   if(bufSize==(u16)(-1))
+   {
+       DBG( "No Data\n" );
+   }
+   pPrintBuf = kmalloc( bufSize * 3 + 1, GFP_ATOMIC );
+   if (pPrintBuf == NULL)
+   {
+      DBG( "Unable to allocate buffer\n" );
+      return;
+   }
+   memset( pPrintBuf, 0 , bufSize * 3 + 1 );
+   for (pos = 0; pos < bufSize; pos++)
+   {
+      status = snprintf( (pPrintBuf + (pos * 3)),
+                         4,
+                         "%02X ",
+                         *(u8 *)(pBuffer + pos) );
+      if (status != 3)
+      {
+         DBG( "snprintf error %d\n", status );
+         kfree( pPrintBuf );
+         return;
+      }
+   }
+   printk( "   : %s\n", pPrintBuf );
+   kfree( pPrintBuf );
+   pPrintBuf = NULL;
+   return;
+}
+
+/*===========================================================================
+METHOD:
+   ErrHex (Public Method)
+
+DESCRIPTION:
+   Print Hex data, for QMAP debug purposes
+
+PARAMETERS:
+   pBuffer       [ I ] - Data buffer
+   bufSize       [ I ] - Size of data buffer
+
+RETURN VALUE:
+   None
+===========================================================================*/
+void ErrHex(
+   void *      pBuffer,
+   u16         bufSize )
+{
+   char * pPrintBuf;
+   u16 pos;
+   int status;
+   if(bufSize==(u16)(-1))
+   {
+       DBG( "No Data\n" );
+   }
+   pPrintBuf = kmalloc( bufSize * 3 + 1, GFP_ATOMIC );
+   if (pPrintBuf == NULL)
+   {
+      DBG( "Unable to allocate buffer\n" );
+      return;
+   }
+   memset( pPrintBuf, 0 , bufSize * 3 + 1 );
+   for (pos = 0; pos < bufSize; pos++)
+   {
+      status = snprintf( (pPrintBuf + (pos * 3)),
+                         4,
+                         "%02X ",
+                         *(u8 *)(pBuffer + pos) );
+      if (status != 3)
+      {
+         DBG( "snprintf error %d\n", status );
+         kfree( pPrintBuf );
+         return;
+      }
+   }
+   printk( "   : %s\n", pPrintBuf );
+   kfree( pPrintBuf );
+   pPrintBuf = NULL;
+   return;
+}
+
+/*===========================================================================
+GobiInitWorkQueue
+   GobiInitWorkQueue (Private Method)
+
+DESCRIPTION:
+   Init and Create workqueue in device specifc memory.
+
+PARAMETERS:
+   pGobiDev                 [ I ] - Pointer to Device specific memory
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int GobiInitWorkQueue(sGobiUSBNet *pGobiDev)
+{
+   char szProcessName[MAX_WQ_PROC_NAME_SIZE]={0};
+   int tableindex = -1;
+   int interfaceindex = 0;
+   if(pGobiDev==NULL)
+      return -1;
+   interfaceindex = GetPrivateWorkQueuesInterfaceTableIndex(pGobiDev);
+    
+   tableindex = AddPrivateWorkQueues(pGobiDev);
+   if((tableindex<0) || (tableindex>=MAX_QCQMI))
+   {
+      return -1;
+   }
+   
+   memset(&szProcessName,0,sizeof(szProcessName));
+   if(GenerateProcessName("gobiprobe",&szProcessName[0],MAX_WQ_PROC_NAME_SIZE-1,pGobiDev)!=0)
+   {
+      return -1;
+   }
+   pGobiDev->wqprobe = GetPrivateWorkQueuesWQByTableIndex(tableindex,interfaceindex,eWQ_PROBE);
+   if(pGobiDev->wqprobe==NULL)
+   {
+      pGobiDev->wqprobe = create_workqueue(szProcessName);
+      if (!pGobiDev->wqprobe)
+      {
+        printk("Create Work Queue Probe Failed\n");
+        return -1;
+      }
+      SetPrivateWorkQueuesWQByTableIndex(tableindex,interfaceindex,pGobiDev->wqprobe,eWQ_PROBE);
+   }
+   memset(&szProcessName,0,sizeof(szProcessName));
+   if(GenerateProcessName("gobireadcb",&szProcessName[0],MAX_WQ_PROC_NAME_SIZE-1,pGobiDev)!=0)
+   {
+      return -1;
+   }
+   pGobiDev->wqProcessReadCallback = GetPrivateWorkQueuesWQByTableIndex(tableindex,interfaceindex,eWQ_URBCB);
+   if(pGobiDev->wqProcessReadCallback==NULL)
+   {
+      pGobiDev->wqProcessReadCallback = create_workqueue(szProcessName);
+      if (!pGobiDev->wqProcessReadCallback)
+      {
+        printk("Create Work Queue Probe Failed\n");
+        return -1;
+      }
+      SetPrivateWorkQueuesWQByTableIndex(tableindex,interfaceindex,pGobiDev->wqProcessReadCallback,eWQ_URBCB);
+   }
+   return 0;
+}
+
+/*===========================================================================
+GobiDestoryWorkQueue
+   GobiDestoryWorkQueue (Private Method)
+
+DESCRIPTION:
+   Destory workqueues in device specific memory. 
+
+PARAMETERS:
+   pGobiDev                 [ I ] - Pointer to Device specific memory
+RETURN VALUE:
+   NULL
+===========================================================================*/
+void GobiDestoryWorkQueue(sGobiUSBNet *pGobiDev)
+{
+   int interfaceindex = 0;
+   int tableindex = 0;
+   if(pGobiDev==NULL)
+      return ;
+   
+   interfaceindex = GetPrivateWorkQueuesInterfaceTableIndex(pGobiDev);
+   tableindex = GetPrivateWorkQueuesIndex(pGobiDev);
+   
+   GobiCancelReadCallBackWorkQueue(pGobiDev);
+
+   GobiCancelProbeWorkQueue(pGobiDev);
+      
+   ClearPrivateWorkQueuesProcessByTableIndex(tableindex,
+                  interfaceindex);
+   
+}
+
+/*===========================================================================
+iRemoveQMAPPaddingBytes
+
+   RemoveQMAPPaddingBytes (Private Method)
+
+DESCRIPTION:
+   Remove QMAP header and padding in SKB buffer. 
+
+PARAMETERS:
+   skb                 [ I ] - Pointer to sk_buff pointer
+RETURN VALUE:
+   int - 0 for success
+         Negative errno for error
+===========================================================================*/
+int iRemoveQMAPPaddingBytes(struct sk_buff *skb)
+{
+   u8 padding_lenth = 0;
+   if(skb==NULL)
+   return -1;
+   padding_lenth = (u8)skb->data[0];
+
+   if(padding_lenth>0)
+   {
+      NETDBG("padding_lenth:%d\n",padding_lenth);
+      if((padding_lenth<=QMAP_MAX_PADDING_BYTES)&&
+          skb->len >= padding_lenth)
+      {
+         skb_trim(skb,skb->len - padding_lenth);
+      }
+      else
+      {
+         return -1;
+      }
+   }
+   if(skb->len>=QMUX_HEADER_LENGTH)
+   {
+      skb_pull(skb,QMUX_HEADER_LENGTH);
+   }
+   else
+   {
+      return -1;
+   }
+   return 0;
+}
+
+int IsOtherTaskUsingFilp(struct file *pFilp)
+{
+   sQMIFilpStorage * pFilpData = NULL;
+   long refcnt = 0;
+   if(pFilp ==NULL)
+   {
+      return 0;
+   }
+
+   refcnt = atomic_long_read(&pFilp->f_count);
+   if (refcnt == 1)
+   {
+      return 0;
+   }   
+   pFilpData = (sQMIFilpStorage *)pFilp->private_data;
+   if (pFilpData == NULL)
+   {
+      return 0;
+   }
+   if(IsDeviceDisconnect(pFilpData->mpDev))
+   {
+      return 0;
+   }
+   if((pFilpData->pOpenTask!=pFilpData->pReadTask)||
+      (pFilpData->pOpenTask!=pFilpData->pWriteTask)||
+      (pFilpData->pOpenTask!=pFilpData->pIOCTLTask))
+   {
+      return 1;
+   }
+   return 0;
+}
+
+int IsOpenTaskIsCurrent(struct file *pFilp)
+{
+   sQMIFilpStorage * pFilpData = NULL;
+   if(pFilp ==NULL)
+   {
+      return 0;
+   }
+   pFilpData = (sQMIFilpStorage *)pFilp->private_data;
+   if (pFilpData == NULL)
+   {
+      return 0;
+   }
+   if(IsDeviceDisconnect(pFilpData->mpDev))
+   {
+      return 0;
+   }
+   #if 0
+   printk(KERN_INFO "c/o/r/w/i %d/%d/%d/%d/%d\n",
+   task_pid_nr(current),
+   task_pid_nr(pFilpData->pOpenTask),
+   task_pid_nr(pFilpData->pReadTask),
+   task_pid_nr(pFilpData->pWriteTask),
+   task_pid_nr(pFilpData->pIOCTLTask));
+   #endif
+   if(pFilpData->pOpenTask==current)
+   {
+      return 1;
+   }
+
+   return 0;
+}
+
+int IsCurrentTaskExit(void)
+{
+    if(current->flags & PF_EXITING)
+        return 1;
+    return 0;
+}
+
+/*===========================================================================
+gobi_work_busy
+
+   gobi_work_busy (Private Method)
+
+DESCRIPTION:
+   Check delayed work is busy. 
+
+PARAMETERS:
+   dw                 [ I ] - Pointer to delayed_work pointer
+RETURN VALUE:
+   int - 0 not busy
+===========================================================================*/
+int gobi_work_busy(struct delayed_work *dw)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,36 ))
+   if(work_pending(&dw->work))
+      return 1;
+   return 0;
+#else
+   return work_busy(&dw->work);
+#endif
+}
+
+/*===========================================================================
+ClientTransactionIDExist
+   ClientTransactionIDExist (Private Method)
+
+DESCRIPTION:
+   Check Client Transcation ID already in notify list
+
+PARAMETERS:
+   pGobiDev                 [ I ] - Pointer to Device specific memory.
+   clientID                 [ I ] - Client ID.
+   u16TransactionID         [ I ] - Transaction ID.
+RETURN VALUE:
+    int - 1 Found Transcation ID in client.
+          0 Not found Transcation ID in client.
+===========================================================================*/
+int ClientTransactionIDExist(sGobiUSBNet *pDev, u16 clientID,u16 u16TransactionID)
+{
+   sClientMemList * pClientMem;
+   sNotifyList ** ppThisNotifyList;
+   if(pDev==NULL)
+   {
+      DBG("NULL");
+      return 0;
+   }
+
+#ifdef CONFIG_SMP
+   // Verify Lock
+   #if _IGNORE_DISCONNECT_SPIN_LOCK_CHECK_
+   if(!IsDeviceDisconnect(pDev))
+   #endif
+   if (LocalClientMemLockSpinIsLock( pDev ) == 0)
+   {
+      DBG( "unlocked\n" );
+      BUG();
+   }
+#endif
+
+   // Get this client's memory location
+   pClientMem = FindClientMem( pDev, clientID );
+   if (pClientMem == NULL)
+   {
+      DBG( "Could not find this client's memory 0x%04X\n", clientID );
+      return 0;
+   }
+
+   // Go to last URBList entry
+   ppThisNotifyList = &pClientMem->mpReadNotifyList;
+   while (*ppThisNotifyList != NULL)
+   {
+      if((*ppThisNotifyList)->mTransactionID==u16TransactionID)
+      {
+         return 1;
+      }
+      ppThisNotifyList = &(*ppThisNotifyList)->mpNext;
+   }
+   return 0;
+}
+
+/*===========================================================================
+ReadCallbackInt
+
+   ReadCallbackInt (Private Method)
+
+DESCRIPTION:
+   Queue URB to be process. 
+
+PARAMETERS:
+   pReadURB                 [ I ] - Pointer to urb pointer
+RETURN VALUE:
+   none
+===========================================================================*/
+void ReadCallbackInt( struct urb * pReadURB )
+{
+   sGobiUSBNet * pDev;
+   if (pReadURB == NULL)
+   {
+      DBG( "bad read URB\n" );
+      return;
+   }
+   pDev = pReadURB->context;
+   pDev->pReadURB = pReadURB;
+   gobiProcessReadURB(pDev);
+   return ;
+}
+
+/*===========================================================================
+ProcessReadWorkFunction
+
+   ProcessReadWorkFunction (Private Method)
+
+DESCRIPTION:
+   Process ReadCallback. 
+
+PARAMETERS:
+   w                 [ I ] - Pointer to work_struct pointer
+RETURN VALUE:
+   none
+===========================================================================*/
+static void ProcessReadWorkFunction(struct work_struct *w)
+{
+   struct delayed_work *dwork;
+   sGobiUSBNet *pGobiDev = NULL;
+   dwork = to_delayed_work(w);
+   pGobiDev = container_of(dwork, sGobiUSBNet, dwProcessReadCallback);
+   if(pGobiDev!=NULL)
+   {
+      DBG("ResubmitIntURB\n");
+      ReadCallback(pGobiDev->pReadURB);
+   }
+   else
+   {
+      DBG("pGobiDev NULL\n");
+   }
+}
+
+/*===========================================================================
+gobiProcessReadURB
+
+   gobiProcessReadURB (Private Method)
+
+DESCRIPTION:
+   Add delayed work to wqProcessReadCallback.
+
+PARAMETERS:
+   pGobiDev                 [ I ] - Pointer to sGobiUSBNet pointer
+RETURN VALUE:
+   none
+===========================================================================*/
+static void gobiProcessReadURB(sGobiUSBNet *pGobiDev)
+{
+   INIT_DELAYED_WORK(&pGobiDev->dwProcessReadCallback,
+            ProcessReadWorkFunction);
+   queue_delayed_work(pGobiDev->wqProcessReadCallback, &pGobiDev->dwProcessReadCallback, 0);
+}
+/*===========================================================================
+GenerateProcessName
+
+   GenerateProcessName (Private Method)
+
+DESCRIPTION:
+   Generate workqueue name with prefix.
+
+PARAMETERS:
+   pPrefix                 [ I ] - work queue name prefix
+   szProcessName           [ O ] - strore generated process name 
+   sizeofName              [ I ] - size of process name
+   pGobiDev                [ I ] - Pointer to sGobiUSBNet pointer
+RETURN VALUE:
+   int - 0 Suceesss.
+       - -1 Error.
+===========================================================================*/
+int GenerateProcessName(const char *pPrefix,char *szProcessName,unsigned sizeofName,sGobiUSBNet *pGobiDev )
+{
+    struct usb_device *dev = NULL;
+    if(pGobiDev==NULL)
+    {
+        return -1;
+    }
+    dev = interface_to_usbdev(pGobiDev->mUsb_Interface);
+    snprintf(szProcessName,sizeofName,"%s-%d-%d-%s:%d.%d",
+      pPrefix,
+      (int)pGobiDev->mQMIDev.qcqmi,   
+      dev->bus->busnum, dev->devpath,    
+      dev->actconfig->desc.bConfigurationValue,   
+      pGobiDev->mUsb_Interface->cur_altsetting->desc.bInterfaceNumber);
+    return 0;
+}
+
+/*===========================================================================
+GetPrivateWorkQueuesInterfaceTableIndex
+
+   GetPrivateWorkQueuesInterfaceTableIndex (Private Method)
+
+DESCRIPTION:
+   Get table interface(GobiPrivateWorkQueues) index by USB interface number.
+
+PARAMETERS:
+   pGobiDev                [ I ] - Pointer to sGobiUSBNet pointer
+RETURN VALUE:
+    int - 0 interface 8(default).
+        - 1 interface 10.
+===========================================================================*/
+int GetPrivateWorkQueuesInterfaceTableIndex(sGobiUSBNet *pGobiDev)
+{
+   if(pGobiDev->mUsb_Interface->cur_altsetting->desc.bInterfaceNumber==10)
+      return 1;
+   return 0;
+}
+
+/*===========================================================================
+AddPrivateWorkQueues
+
+   AddPrivateWorkQueues (Private Method)
+
+DESCRIPTION:
+   Add pGObiDev USB interface device to GobiPrivateWorkQueues.
+
+PARAMETERS:
+   pGobiDev                [ I ] - Pointer to sGobiUSBNet pointer
+RETURN VALUE:
+    int - 0 - MAX_QCQMI-1 GobiPrivateWorkQueues workqueue index.
+===========================================================================*/
+int AddPrivateWorkQueues(sGobiUSBNet *pGobiDev)
+{
+   int i=0,j=0;
+   char szProcessName[MAX_WQ_PROC_NAME_SIZE];
+   memset(&szProcessName,0,sizeof(szProcessName));
+   if(pGobiDev->mUsb_Interface->cur_altsetting->desc.bInterfaceNumber==10)
+   {
+      j = 1;
+   }
+   if(GenerateProcessName("gobi",&szProcessName[0],MAX_WQ_PROC_NAME_SIZE-1,pGobiDev)!=0)
+   {
+      return -1;
+   }
+   i = GetPrivateWorkQueuesIndex(pGobiDev);
+   if(i<MAX_QCQMI)
+   {
+      DBG("%s REUSE %d:%d :%s",__FUNCTION__,i,j,szProcessName);
+      return i;
+   }
+   for(i=0;i<MAX_QCQMI;i++)
+   {
+      if(strlen(GobiPrivateWorkQueues[i][j].szProcessName)==0)
+      {
+         strncpy(GobiPrivateWorkQueues[i][j].szProcessName,szProcessName,strlen(szProcessName));
+         DBG("%s ADD %d:%d :%s",__FUNCTION__,i,j,szProcessName);
+         return i;
+      }
+   }
+   return -1;
+}
+
+/*===========================================================================
+GetPrivateWorkQueuesIndex
+
+   GetPrivateWorkQueuesIndex (Private Method)
+
+DESCRIPTION:
+   Get pGObiDev index in GobiPrivateWorkQueues.
+
+PARAMETERS:
+   pGobiDev                [ I ] - Pointer to sGobiUSBNet pointer
+RETURN VALUE:
+    int - 0 - MAX_QCQMI-1 GobiPrivateWorkQueues workqueue index.
+===========================================================================*/
+int GetPrivateWorkQueuesIndex(sGobiUSBNet *pGobiDev)
+{
+   int i=0,j=0;
+   char szProcessName[MAX_WQ_PROC_NAME_SIZE];
+   memset(&szProcessName,0,sizeof(szProcessName));
+   j = GetPrivateWorkQueuesInterfaceTableIndex(pGobiDev);
+   if(GenerateProcessName("gobi",&szProcessName[0],MAX_WQ_PROC_NAME_SIZE-1,pGobiDev)!=0)
+   {
+      return -1;
+   }
+   for(i=0;i<MAX_QCQMI;i++)
+   {
+      if( 
+             (strlen(GobiPrivateWorkQueues[i][j].szProcessName)>0) && 
+             (strlen(GobiPrivateWorkQueues[i][j].szProcessName)==strlen(szProcessName)) &&
+             (strncmp(GobiPrivateWorkQueues[i][j].szProcessName,szProcessName,strlen(szProcessName))==0)
+             )
+      {
+         DBG("%s FOUND :%s\n",__FUNCTION__,szProcessName);
+         return i;
+      }
+   }
+   return i;
+}
+
+/*===========================================================================
+iClearWorkQueuesByTableIndex
+
+   iClearWorkQueuesByTableIndex (Private Method)
+
+DESCRIPTION:
+   Clear index in GobiPrivateWorkQueues device workqueues.
+
+PARAMETERS:
+   index                [ I ] - index of GobiPrivateWorkQueues device to be cleared
+RETURN VALUE:
+    none
+===========================================================================*/
+int iClearWorkQueuesByTableIndex(int index)
+{
+   int i=0,j=0;
+   i = index;
+   if((i>=0)&&(i<MAX_QCQMI))
+   {
+      for(j=0;j<MAX_QCQMI_PER_INTF;j++)
+      {
+         if(strlen(GobiPrivateWorkQueues[i][j].szProcessName)>0)
+         {
+            DBG("%s clear %d:%d :%s",__FUNCTION__,
+            i,j,
+            GobiPrivateWorkQueues[i][j].szProcessName);
+         }
+         memset(&GobiPrivateWorkQueues[i][j].szProcessName,0,sizeof(GobiPrivateWorkQueues[i][j].szProcessName));
+         if(GobiPrivateWorkQueues[i][j].wqprobe!=NULL)
+         {
+            DBG("%s wqprobe %d:%d :%s",
+               __FUNCTION__,i,j,
+            GobiPrivateWorkQueues[i][j].szProcessName);
+            SetPrivateWorkQueuesWQByTableIndex(i,j,NULL,eWQ_PROBE);
+         }
+         GobiPrivateWorkQueues[i][j].wqprobe=NULL;
+         if(GobiPrivateWorkQueues[i][j].wqProcessReadCallback!=NULL)
+         {
+            DBG("%s wqProcessReadCallback %d:%d :%s",
+               __FUNCTION__,i,j,
+            GobiPrivateWorkQueues[i][j].szProcessName);
+            SetPrivateWorkQueuesWQByTableIndex(i,j,NULL,eWQ_URBCB);
+         }
+         GobiPrivateWorkQueues[i][j].wqProcessReadCallback=NULL;
+      }
+   }
+   return 0;
+}
+
+/*===========================================================================
+GetPrivateWorkQueuesWQByTableIndex
+
+   GetPrivateWorkQueuesWQByTableIndex (Private Method)
+
+DESCRIPTION:
+   Get GobiPrivateWorkQueues workqueue with specific device index(i), 
+   interface index(j), and work queue type.
+
+PARAMETERS:
+   i                 [ I ] - index of GobiPrivateWorkQueues device.
+   j                 [ I ] - index of GobiPrivateWorkQueues interface.
+   type              [ I ] - work queue type.
+RETURN VALUE:
+    struct workqueue_struct pointer:
+         - NULL fail.
+===========================================================================*/
+struct workqueue_struct *GetPrivateWorkQueuesWQByTableIndex(int i,int j,int type)
+{
+   if ((j<0) ||(j>=MAX_QCQMI_PER_INTF))
+      return NULL;
+   if((i<0)||(i>=MAX_QCQMI))
+      return NULL;
+   
+   switch(type)
+   {
+      case eWQ_PROBE:
+         if(GobiPrivateWorkQueues[i][j].wqprobe!=NULL)
+         {
+            return GobiPrivateWorkQueues[i][j].wqprobe;
+         }
+         break;
+      case eWQ_URBCB:
+         if(GobiPrivateWorkQueues[i][j].wqProcessReadCallback!=NULL)
+         {
+            return GobiPrivateWorkQueues[i][j].wqProcessReadCallback;
+         }
+         break;
+      default:
+         break;
+   }
+
+   return NULL;
+}
+
+/*===========================================================================
+SetPrivateWorkQueuesWQByTableIndex
+
+   SetPrivateWorkQueuesWQByTableIndex (Private Method)
+
+DESCRIPTION:
+   Set GobiPrivateWorkQueues workqueue with specific device index(i), 
+   interface index(j), and work queue type.
+
+PARAMETERS:
+   i                 [ I ] - index of GobiPrivateWorkQueues device.
+   j                 [ I ] - index of GobiPrivateWorkQueues interface.
+   wq                [ I ] - work queue pointer to be stored in GobiPrivateWorkQueues
+   type              [ I ] - work queue type.
+RETURN VALUE:
+    int - 0 success.
+    Negative errno for error
+===========================================================================*/
+int SetPrivateWorkQueuesWQByTableIndex(int i,int j,struct workqueue_struct *wq, int type)
+{
+   if ((j<0) ||(j>=MAX_QCQMI_PER_INTF))
+      return -1;
+   if((i<0)||(i>=MAX_QCQMI))
+      return -1;
+   
+   switch(type)
+   {
+      case eWQ_PROBE:
+         if(GobiPrivateWorkQueues[i][j].wqprobe!=NULL)
+         {
+            DBG( "%s wqprobe %d:%d :%s",
+               __FUNCTION__,i,j,
+            GobiPrivateWorkQueues[i][j].szProcessName);
+            flush_workqueue(GobiPrivateWorkQueues[i][j].wqprobe);
+            DBG( "%s wq wqprobe %d:%d :%s",
+               __FUNCTION__,i,j,
+            GobiPrivateWorkQueues[i][j].szProcessName);
+            destroy_workqueue(GobiPrivateWorkQueues[i][j].wqprobe);
+         }
+         GobiPrivateWorkQueues[i][j].wqprobe=wq;
+         break;
+      case eWQ_URBCB:
+         if(GobiPrivateWorkQueues[i][j].wqProcessReadCallback!=NULL)
+         {
+            DBG("%s wqProcessReadCallback %d:%d :%s",
+               __FUNCTION__,i,j,
+            GobiPrivateWorkQueues[i][j].szProcessName);
+            flush_workqueue(GobiPrivateWorkQueues[i][j].wqProcessReadCallback);
+            DBG( "%s wqProcessReadCallback destroy_workqueue %d:%d :%s",
+               __FUNCTION__,i,j,
+            GobiPrivateWorkQueues[i][j].szProcessName);
+            destroy_workqueue(GobiPrivateWorkQueues[i][j].wqProcessReadCallback);
+         }
+         GobiPrivateWorkQueues[i][j].wqProcessReadCallback=wq;
+         break;
+      default:
+         break;
+   }
+
+   return 0;
+}
+
+/*===========================================================================
+ClearPrivateWorkQueuesProcessByTableIndex
+
+   ClearPrivateWorkQueuesProcessByTableIndex (Private Method)
+
+DESCRIPTION:
+   Clear GobiPrivateWorkQueues ProcessName with specific device index(i) and
+   interface index(j).
+
+PARAMETERS:
+   i                 [ I ] - index of GobiPrivateWorkQueues device.
+   j                 [ I ] - index of GobiPrivateWorkQueues interface.
+RETURN VALUE:
+    int - 0 success.
+    Negative errno for error
+===========================================================================*/
+int ClearPrivateWorkQueuesProcessByTableIndex(int i,int j)
+{
+    DBG("%s %d:%d ",
+               __FUNCTION__,i,j)
+   if ((j<0) ||(j>=MAX_QCQMI_PER_INTF))
+      return -1;
+   if((i<0)||(i>=MAX_QCQMI))
+      return -1;
+   if( (GobiPrivateWorkQueues[i][j].wqProcessReadCallback==NULL) &&
+       (GobiPrivateWorkQueues[i][j].wqprobe==NULL) )
+   {
+      memset(&GobiPrivateWorkQueues[i][j].szProcessName,0,
+         sizeof(GobiPrivateWorkQueues[i][j].szProcessName));
+   }
+   return 0;
+}
+
+/*===========================================================================
+GobiCancelReadCallBackWorkQueue
+
+   GobiCancelReadCallBackWorkQueue (Private Method)
+
+DESCRIPTION:
+   Cancel device ReadCallBack work queue.
+
+PARAMETERS:
+   pGobiDev          [ I ] - pointer to sGobiUSBNet.
+RETURN VALUE:
+    none
+===========================================================================*/
+void GobiCancelReadCallBackWorkQueue(sGobiUSBNet *pGobiDev)
+{
+   if( (pGobiDev != NULL) && 
+      (pGobiDev->wqProcessReadCallback != NULL))
+   {
+      
+      DBG("%s\n",__FUNCTION__);
+      GobiCancelDelayWorkWorkQueue(pGobiDev,
+         pGobiDev->wqProcessReadCallback,
+         &pGobiDev->dwProcessReadCallback);
+   }
+}
+
+
+/*===========================================================================
+METHOD:
+   TransceiveReleaseClientID (Private Method)
+
+DESCRIPTION:
+   Send/Receive Release QMI client control message.
+
+PARAMETERS:
+   pDev           [ I ] - Device specific memory
+   clientID       [ I ] - Requester's client ID
+
+RETURN VALUE:
+   true - 0 success.
+   false - on error.
+===========================================================================*/
+bool TransceiveReleaseClientID(
+   sGobiUSBNet *    pDev,
+   u16                clientID)
+{
+   void * pWriteBuffer;
+   u16 writeBufferSize;
+   void * pReadBuffer = NULL;
+   u16 readBufferSize;
+   u8 transactionID;
+   int result;
+   unsigned long flags = 0;
+   struct semaphore readSem;
+   bool bRet = true;
+   // Is device is still valid?
+   DBG("clientID:0x%x\n",clientID);
+   if (pDev->mbUnload > eStatUnloaded)
+   {
+      DBG( "unloaded\n" );
+      return false;
+   }
+   // Run QMI ReleaseClientID if this isn't QMICTL
+   if(IsDeviceDisconnect(pDev)==true)
+      return false;
+   barrier();
+   sema_init( &readSem, SEMI_INIT_DEFAULT_VALUE );
+   if ((clientID != QMICTL) && (pDev->mReleaseClientIDFail==0))
+   {
+      // Note: all errors are non fatal, as we always want to delete
+      //    client memory in latter part of function
+
+      writeBufferSize = QMICTLReleaseClientIDReqSize();
+      pWriteBuffer = kmalloc( writeBufferSize, GOBI_GFP_KERNEL );
+      if (pWriteBuffer == NULL)
+      {
+         DBG( "memory error\n" );
+         return false;
+      }
+      else
+      {
+         transactionID = QMIXactionIDGet(pDev);
+         result = QMICTLReleaseClientIDReq( pWriteBuffer,
+                                            writeBufferSize,
+                                            transactionID,
+                                            clientID );
+         if (result < 0)
+         {
+            kfree( pWriteBuffer );
+            DBG( "error %d filling req buffer\n", result );
+         }
+         else
+         {            
+            mb();
+            result = ReadAsync( pDev, QMICTL, transactionID, UpSem, &readSem ,1);
+            if(result == 0)
+            {
+               result = WriteSyncNoRetry( pDev,
+                             pWriteBuffer,
+                             writeBufferSize,
+                             QMICTL );
+               kfree( pWriteBuffer );
+               if(result<0)
+               {
+                  DBG( " WriteSyncNoRetry error %d\n", result );
+                  pDev->mReleaseClientIDFail = 1;
+                  bRet = false;
+                  flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+                  RemoveAndPopNotifyList(pDev,QMICTL,0,eClearCID);
+                  LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+               }
+               else
+               {
+                  wait_control_msg_semaphore_timeout(&readSem,QMI_CONTROL_MAX_MSG_DELAY_MS);
+                  mb();
+                  // Enter critical section
+                  flags = LocalClientMemLockSpinLockIRQSave( pDev , __LINE__);
+                  barrier();
+                  spin_lock_irq(&(pDev->notif_lock));
+                  if (down_trylock( &readSem ) == 0)
+                  {                  
+                     // Pop the read data
+                     if (PopFromReadMemList( pDev,
+                                             QMICTL,
+                                             transactionID,
+                                             &pReadBuffer,
+                                             &readBufferSize ) == true)
+                     {
+                        // End critical section
+                        result = QMICTLReleaseClientIDResp(pReadBuffer,
+                                                              readBufferSize);
+                        if (result < 0)
+                        {
+                           DBG( "error %d parsing response\n", result );
+                           RemoveAndPopNotifyList(pDev,QMICTL,0,eClearCID);
+                        }
+                        // We don't care about the result
+                        if(pReadBuffer)
+                        kfree( pReadBuffer );
+                     }
+                     else
+                     {
+                        // Read mismatch/failure, unlock and continue
+                        RemoveAndPopNotifyList(pDev,QMICTL,0,eClearCID);
+                     }
+                  }
+                  else
+                  {
+                     DBG( "Lock Timeout\n" );
+                     // Timeout, remove the async read
+                     RemoveAndPopNotifyList(pDev,QMICTL,0,eClearCID);
+                     // End critical section
+                  }
+                  spin_unlock_irq(&(pDev->notif_lock));
+                  LocalClientMemUnLockSpinLockIRQRestore ( pDev ,flags,__LINE__);
+               }
+            }
+            else
+            {
+                if(pWriteBuffer)
+                {
+                   kfree( pWriteBuffer );
+                   pWriteBuffer = NULL;
+                }
+            }
+         } 
+      }
+   }
+   return bRet;
+}
+
+
+/*===========================================================================
+GobiCancelDelayWorkWorkQueue
+
+   GobiCancelDelayWorkWorkQueue (Private Method)
+
+DESCRIPTION:
+   Cancel work queue and delayed work.
+
+PARAMETERS:
+   pGobiDev          [ I ] - pointer to sGobiUSBNet.
+   wq                [ I ] - pointer to workqueue_struct.
+   dw                [ I ] - pointer to delayed_work.
+
+RETURN VALUE:
+    none
+===========================================================================*/
+void GobiCancelDelayWorkWorkQueue(
+   sGobiUSBNet *pGobiDev,
+   struct workqueue_struct *wq, 
+   struct delayed_work *dw)
+{
+   if( (pGobiDev != NULL) && 
+      (wq != NULL) && 
+      (dw != NULL) )
+   {
+      
+      int ret = 0;
+      struct usb_device *dev = NULL;
+      unsigned int flag = 0;
+      if( pGobiDev->mUsb_Interface == NULL )
+      {
+         return ;
+      }
+      dev = interface_to_usbdev(pGobiDev->mUsb_Interface);
+      ret = usb_lock_device_for_reset(dev, NULL);
+      if(ret==0)
+      {
+
+         //Prevent Deadlock GobiUSBLockReset
+         usb_unlock_device(dev);
+         flag = gobi_work_busy(dw);
+         if(flag)
+         {
+            #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,36 ))
+            if(flag & WORK_BUSY_RUNNING)
+            {
+               DBG("flush_delayed_work %d\n",
+                   pGobiDev->mpIntf->cur_altsetting->desc.bInterfaceNumber);
+               flush_delayed_work(dw);
+            }
+            #endif
+            if(cancel_delayed_work (dw))
+            {
+               DBG("flush_workqueue %d\n",
+                   pGobiDev->mpIntf->cur_altsetting->desc.bInterfaceNumber);
+               flush_workqueue(wq);
+            }
+         }
+         else
+         {
+            DBG("flush_work \n %d\n",
+               pGobiDev->mpIntf->cur_altsetting->desc.bInterfaceNumber);
+            flush_work(&dw->work);
+         }
+      }
+   }
+}
+
+/*===========================================================================
+GobiCancelProbeWorkQueue
+
+   GobiCancelProbeWorkQueue (Private Method)
+
+DESCRIPTION:
+   Cancel device Probe work queue.
+
+PARAMETERS:
+   pGobiDev          [ I ] - pointer to sGobiUSBNet.
+RETURN VALUE:
+    none
+===========================================================================*/
+void GobiCancelProbeWorkQueue(sGobiUSBNet *pGobiDev)
+{
+   if( (pGobiDev != NULL) && 
+      (pGobiDev->wqprobe != NULL))
+   {
+      
+      DBG("%s\n",__FUNCTION__);
+      GobiCancelDelayWorkWorkQueue(pGobiDev,
+         pGobiDev->wqprobe,
+         &pGobiDev->dwprobe);
+   }
+}
+
diff --git a/drivers/net/usb/QMIDevice.h b/drivers/net/usb/QMIDevice.h
new file mode 100644
index 00000000..b87e33dc
--- /dev/null
+++ b/drivers/net/usb/QMIDevice.h
@@ -0,0 +1,550 @@
+/*===========================================================================
+FILE:
+   QMIDevice.h
+
+DESCRIPTION:
+   Functions related to the QMI interface device
+   
+FUNCTIONS:
+   Generic functions
+      IsDeviceValid
+      PrintHex
+      GobiSetDownReason
+      GobiClearDownReason
+      GobiTestDownReason
+
+   Driver level asynchronous read functions
+      ResubmitIntURB
+      ReadCallback
+      IntCallback
+      StartRead
+      KillRead
+
+   Internal read/write functions
+      ReadAsync
+      UpSem
+      ReadSync
+      WriteSyncCallback
+      WriteSync
+
+   Internal memory management functions
+      GetClientID
+      ReleaseClientID
+      FindClientMem
+      AddToReadMemList
+      PopFromReadMemList
+      AddToNotifyList
+      NotifyAndPopNotifyList
+      AddToURBList
+      PopFromURBList
+
+   Internal userspace wrapper functions
+      UserspaceunlockedIOCTL
+
+   Userspace wrappers
+      UserspaceOpen
+      UserspaceIOCTL
+      UserspaceClose
+      UserspaceRead
+      UserspaceWrite
+      UserspacePoll
+
+   Initializer and destructor
+      RegisterQMIDevice
+      DeregisterQMIDevice
+
+   Driver level client management
+      QMIReady
+      QMIWDSCallback
+      SetupQMIWDSCallback
+      QMIDMSGetMEID
+      QMIDMSSWISetFCCAuth
+      QMICTLGetVersionInfo
+
+Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Code Aurora Forum nor
+      the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+Alternatively, provided that this notice is retained in full, this software
+may be relicensed by the recipient under the terms of the GNU General Public
+License version 2 ("GPL") and only version 2, in which case the provisions of
+the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
+software under the GPL, then the identification text in the MODULE_LICENSE
+macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
+recipient changes the license terms to the GPL, subsequent recipients shall
+not relicense under alternate licensing terms, including the BSD or dual
+BSD/GPL terms.  In addition, the following license statement immediately
+below and between the words START and END shall also then apply when this
+software is relicensed under the GPL:
+
+START
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License version 2 and only version 2 as
+published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+END
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+//---------------------------------------------------------------------------
+// Pragmas
+//---------------------------------------------------------------------------
+#pragma once
+
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+#include "Structs.h"
+#include "QMI.h"
+
+#define MAX_QCQMI 255
+#define MAX_QCQMI_PER_INTF 2
+#define SEMI_INIT_DEFAULT_VALUE 0
+#define QMI_CONTROL_MSG_DELAY_MS 100
+#define QMI_CONTROL_MAX_MSG_DELAY_MS QMI_CONTROL_MSG_DELAY_MS * 5
+// QMI CTL
+#define QMI_CTL_IND 0x02
+#define QMI_CTL_SYNC_IND 0x0027
+
+extern int qcqmi_table[MAX_QCQMI];
+extern int qmux_table[MAX_QCQMI];
+extern sGobiPrivateWorkQueues GobiPrivateWorkQueues[MAX_QCQMI][MAX_QCQMI_PER_INTF];
+//Register State
+enum {
+   eClearCID=0,
+   eClearAndReleaseCID=1,
+   eForceClearAndReleaseCID=2,
+};
+
+//Work queue type
+enum {
+   eWQ_PROBE=0,
+   eWQ_URBCB=1,
+};
+
+/*=========================================================================*/
+// Generic functions
+/*=========================================================================*/
+
+// Basic test to see if device memory is valid
+
+bool IsDeviceDisconnect(sGobiUSBNet *pDev);
+
+#ifdef CONFIG_PM
+bool bIsSuspend(sGobiUSBNet *pGobiDev);
+#endif
+
+void UsbAutopmGetInterface(struct usb_interface * intf);
+void UsbAutopmPutInterface(struct usb_interface * intf);
+
+// Print Hex data, for debug purposes
+void PrintHex(
+   void *         pBuffer,
+   u16            bufSize );
+
+// Print Hex data, for QMAP debug purposes
+void NetHex(
+   void *      pBuffer,
+   u16         bufSize );
+// Print Hex data, for QMAP purposes
+void ErrHex(
+   void *         pBuffer,
+   u16            bufSize );
+
+// Sets mDownReason and turns carrier off
+void GobiSetDownReason(
+   sGobiUSBNet *    pDev,
+   u8                 reason );
+
+// Clear mDownReason and may turn carrier on
+void GobiClearDownReason(
+   sGobiUSBNet *    pDev,
+   u8                 reason );
+
+// Tests mDownReason and returns whether reason is set
+bool GobiTestDownReason(
+   sGobiUSBNet *    pDev,
+   u8                 reason );
+
+/*=========================================================================*/
+// Driver level asynchronous read functions
+/*=========================================================================*/
+
+// Resubmit interrupt URB, re-using same values
+int ResubmitIntURB(sGobiUSBNet * pDev, struct urb * pIntURB );
+
+// Read callback
+//    Put the data in storage and notify anyone waiting for data
+void ReadCallback( struct urb * pReadURB );
+
+// Inturrupt callback
+//    Data is available, start a read URB
+void IntCallback( struct urb * pIntURB );
+
+
+// ReadCallback Intrrupt routine
+void ReadCallbackInt( struct urb * pReadURB );
+
+// Start continuous read "thread"
+int StartRead( sGobiUSBNet * pDev );
+
+// Kill continuous read "thread"
+void KillRead( sGobiUSBNet * pDev );
+
+/*=========================================================================*/
+// Internal read/write functions
+/*=========================================================================*/
+
+// Start asynchronous read
+//     Reading client's data store, not device
+int ReadAsync(
+   sGobiUSBNet *    pDev,
+   u16                clientID,
+   u16                transactionID,
+   void               (*pCallback)(sGobiUSBNet *, u16, void *),
+   void *             pData ,
+   int                iSpinLock);
+
+// Notification function for synchronous read
+void UpSem( 
+   sGobiUSBNet *    pDev,
+   u16                clientID,
+   void *             pData );
+
+// Start synchronous read
+//     Reading client's data store, not device
+int ReadSync(
+   sGobiUSBNet *    pDev,
+   void **            ppOutBuffer,
+   u16                clientID,
+   u16                transactionID,
+   int                *iID,
+   struct semaphore   *pReadSem,
+   int                *iIsClosing);
+
+// Write callback
+void WriteSyncCallback( struct urb * pWriteURB );
+
+// Start synchronous write
+int WriteSync(
+   sGobiUSBNet *    pDev,
+   char *             pInWriteBuffer,
+   int                size,
+   u16                clientID );
+
+// Start synchronous write without resume device
+int WriteSyncNoResume(
+   sGobiUSBNet *    pDev,
+   char *             pInWriteBuffer,
+   int                size,
+   u16                clientID );
+
+// Start synchronous write no retry
+int WriteSyncNoRetry(
+   sGobiUSBNet *    pDev,
+   char *             pInWriteBuffer,
+   int                size,
+   u16                clientID );
+
+/*=========================================================================*/
+// Internal memory management functions
+/*=========================================================================*/
+
+// Create client and allocate memory
+int GetClientID( 
+   sGobiUSBNet *      pDev,
+   u8                 serviceType,
+   struct semaphore   *pReadSem);
+
+// Release client and free memory
+bool ReleaseClientID(
+   sGobiUSBNet *      pDev,
+   u16                clientID);
+
+// Find this client's memory
+sClientMemList * FindClientMem(
+   sGobiUSBNet *      pDev,
+   u16                  clientID );
+
+// Add Data to this client's ReadMem list
+bool AddToReadMemList( 
+   sGobiUSBNet *      pDev,
+   u16                  clientID,
+   u16                  transactionID,
+   void *               pData,
+   u16                  dataSize );
+
+// Remove data from this client's ReadMem list if it matches 
+// the specified transaction ID.
+bool PopFromReadMemList( 
+   sGobiUSBNet *      pDev,
+   u16                  clientID,
+   u16                  transactionID,
+   void **              ppData,
+   u16 *                pDataSize );
+
+// Add Notify entry to this client's notify List
+bool AddToNotifyList( 
+   sGobiUSBNet *      pDev,
+   u16                  clientID,
+   u16                  transactionID,
+   void                 (* pNotifyFunct)(sGobiUSBNet *, u16, void *),
+   void *               pData );
+
+int RemoveAndPopNotifyList(
+   sGobiUSBNet *      pDev,
+   u16              clientID,
+   u16              transactionID ,
+   int              iClearCID);
+
+// Remove first Notify entry from this client's notify list 
+//    and Run function
+int NotifyAndPopNotifyList( 
+   sGobiUSBNet *      pDev,
+   u16                  clientID,
+   u16                  transactionID );
+
+// Add URB to this client's URB list
+bool AddToURBList( 
+   sGobiUSBNet *      pDev,
+   u16                  clientID,
+   struct urb *         pURB );
+
+// Remove URB from this client's URB list
+struct urb * PopFromURBList( 
+   sGobiUSBNet *      pDev,
+   u16                  clientID );
+
+/*=========================================================================*/
+// Internal userspace wrappers
+/*=========================================================================*/
+
+// Userspace unlocked ioctl
+long UserspaceunlockedIOCTL(
+   struct file *     pFilp,
+   unsigned int      cmd,
+   unsigned long     arg );
+
+/*=========================================================================*/
+// Userspace wrappers
+/*=========================================================================*/
+
+// Userspace open
+int UserspaceOpen( 
+   struct inode *   pInode, 
+   struct file *    pFilp );
+
+// Userspace ioctl
+int UserspaceIOCTL(
+   struct inode *    pUnusedInode,
+   struct file *     pFilp,
+   unsigned int      cmd,
+   unsigned long     arg );
+
+// Userspace close
+int UserspaceClose( 
+   struct file *       pFilp,
+   fl_owner_t          unusedFileTable );
+
+// Userspace read (synchronous)
+ssize_t UserspaceRead( 
+   struct file *        pFilp,
+   char __user *        pBuf, 
+   size_t               size,
+   loff_t *             pUnusedFpos );
+
+// Userspace write (synchronous)
+ssize_t UserspaceWrite(
+   struct file *        pFilp, 
+   const char __user *  pBuf, 
+   size_t               size,
+   loff_t *             pUnusedFpos );
+
+unsigned int UserspacePoll(
+   struct file *                  pFilp,
+   struct poll_table_struct *     pPollTable );
+
+/*=========================================================================*/
+// Initializer and destructor
+/*=========================================================================*/
+
+// QMI Device initialization function
+int RegisterQMIDevice( sGobiUSBNet * pDev, int is9x15 );
+
+// QMI Device cleanup function
+void DeregisterQMIDevice( sGobiUSBNet * pDev );
+
+/*=========================================================================*/
+// Driver level client management
+/*=========================================================================*/
+
+// Check if QMI is ready for use
+int QMIReady(
+   sGobiUSBNet *    pDev,
+   u16                timeout );
+
+// QMI WDS callback function
+void QMIWDSCallback(
+   sGobiUSBNet *    pDev,
+   u16                clientID,
+   void *             pData );
+
+// Fire off reqests and start async read for QMI WDS callback
+int SetupQMIWDSCallback( sGobiUSBNet * pDev );
+
+int SetupQMIQOSCallback( sGobiUSBNet * pDev );
+
+// Register client, send req and parse MEID response, release client
+int QMIDMSGetMEID( sGobiUSBNet * pDev );
+
+// Register client, send req and parse FCC Authentication response, release client
+int QMIDMSSWISetFCCAuth( sGobiUSBNet * pDev );
+
+// Register client, send req and parse Data format response, release client
+int QMIWDASetDataFormat( sGobiUSBNet * pDev, int te_flow_control , int iqmuxenable);
+
+// Send set QMAP Data format request and parse response
+int QMIWDASetQMAP( sGobiUSBNet * pDev , u16 WDAClientID);
+
+// send req and parse Data format response
+int QMICTLSetDataFormat( sGobiUSBNet * pDev );
+
+// send req and parse Data format response
+int QMICTLGetVersionInfo( sGobiUSBNet * pDev );
+
+// Initialize Read Sync tasks semaphore
+void InitSemID(sGobiUSBNet * pDev);
+
+
+/***************************************************************************/
+// wait_ms
+/**************************************************************************/
+void wait_ms(unsigned int ms) ;
+
+// Userspace Release (synchronous)
+int UserspaceRelease(struct inode *inode, struct file *file);
+
+// Userspace Lock (synchronous)
+int UserSpaceLock(struct file *filp, int cmd, struct file_lock *fl);
+
+// sync memory
+void gobi_flush_work(void);
+
+// Close Opened File Inode
+int CloseFileInode(sGobiUSBNet * pDev,int iCount);
+// Set modem in specific power save mode
+int SetPowerSaveMode(sGobiUSBNet *pDev,u8 mode);
+
+// config modem qmi wakeup filter
+int ConfigPowerSaveSettings(sGobiUSBNet *pDev, u8 service, u8 indication);
+
+// Get TID
+u8 QMIXactionIDGet( sGobiUSBNet *pDev);
+
+// Release Specific Client ID Nofitication From Memory List
+int ReleaseNotifyList(sGobiUSBNet *pDev,u16 clientID,u8 transactionID);
+
+int gobi_kthread_should_stop(void);
+
+// 
+int Gobi_usb_control_msg(struct usb_interface *intf, struct usb_device *dev, unsigned int pipe, __u8 request,
+                     __u8 requesttype, __u16 value, __u16 index, void *data,
+                      __u16 size, int timeout);
+
+int AddClientToMemoryList(sGobiUSBNet *pDev,u16 clientID);
+//Wait control message semaphore to be up with timeout
+void wait_control_msg_semaphore_timeout(struct semaphore *pSem, unsigned int timeout);
+
+static inline int IsInterfacefDisconnected(struct usb_interface *intf)
+{
+   if(!interface_to_usbdev(intf))
+      return 1;
+   if (interface_to_usbdev(intf)->state == USB_STATE_NOTATTACHED )
+   {
+      return 1;
+   }
+   return 0;
+}
+
+static inline int gobi_usb_autopm_get_interface(struct usb_interface *intf)
+{
+   if(IsInterfacefDisconnected(intf))
+   {
+      return -ENXIO;
+   }
+   return usb_autopm_get_interface(intf);
+}
+void gobi_usb_autopm_put_interface(struct usb_interface *intf);
+void gobi_usb_autopm_get_interface_no_resume(struct usb_interface *intf);
+void gobi_usb_autopm_put_interface_no_resume(struct usb_interface *intf);
+int gobi_usb_autopm_get_interface_async(struct usb_interface *intf);
+void gobi_usb_autopm_put_interface_async(struct usb_interface *intf);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,33 ))
+void gobi_usb_autopm_enable(struct usb_interface *intf);
+#endif
+
+//unregister qmap netdev
+void gobi_qmimux_unregister_device(struct net_device *dev);
+//register qmap netdev
+struct net_device * gobi_qmimux_register_device(struct net_device *real_dev,int iNumber, u8 mux_id);
+//Check SKB is a QMUX packet
+int iIsValidQmuxSKB(struct sk_buff *skb);
+//Get MUX ID from skb
+int iGetQmuxIDFromSKB(struct sk_buff *skb);
+//Get Number of QMAP framed Packet In SKB
+int iNumberOfQmuxPacket(struct sk_buff *skb,int iDisplay);
+//Check SKB packet is QMAP framed.
+int iIsQmuxPacketComplete(struct sk_buff *skb);
+//Check NULL QMAP framed packet
+int iIsQmuxZeroPacket(struct sk_buff *skb);
+//Print QMAP Framed packet.
+int PrintQmuxPacket(struct sk_buff *skb);
+//Get QMAP framed packet length.
+u32 u32GetSKBQMAPPacketLength(struct sk_buff *skb,int iOffset);
+//Check QMAP header in SKB.
+int iIsValidQMAPHeaderInSKBData(struct sk_buff *pSKB, int iOffset);
+//Check NULL QMAP header in SKB.
+int iIsZeroQMAPHeaderInSKBData(struct sk_buff *pSKB, int iOffset);
+//Check Command QMAP header in SKB.
+int iIsCMDQMAPHeaderInSKBData(struct sk_buff *pSKB, int iOffset);
+//Remove QMAP header and Padding Bytes
+int iRemoveQMAPPaddingBytes(struct sk_buff *skb);
+
+// Init WorkQueues
+int GobiInitWorkQueue(sGobiUSBNet *pGobiDev);
+// Destory WorkQueues
+void GobiDestoryWorkQueue(sGobiUSBNet *pGobiDev);
+// Clean up work queues in sGobiPrivateWorkQueues
+int iClearWorkQueuesByTableIndex(int index);
+
diff --git a/drivers/net/usb/Readme.txt b/drivers/net/usb/Readme.txt
new file mode 100644
index 00000000..28412fad
--- /dev/null
+++ b/drivers/net/usb/Readme.txt
@@ -0,0 +1,78 @@
+Gobi3000 network driver 2011-07-29-1026
+
+This readme covers important information concerning 
+the Gobi Net driver.
+
+Table of Contents
+
+1. What's new in this release
+2. Known issues
+3. Known platform issues
+
+
+-------------------------------------------------------------------------------
+
+1. WHAT'S NEW
+
+This Release (Gobi3000 network driver 2011-07-29-1026)
+a. Signal the device to leave low power mode on enumeration
+b. Add "txQueueLength" parameter, which will set the Tx Queue Length
+c. Send SetControlLineState message during driver/device removal
+d. Change to new date-based versioning scheme
+
+Prior Release (Gobi3000 network driver 1.0.60) 06/29/2011
+a. Add UserspacePoll() function, to support select()
+b. Fix possible deadlock on GobiUSBNetTXTimeout()
+c. Fix memory leak on data transmission
+
+Prior Release (Gobi3000 network driver 1.0.50) 05/18/2011
+a. Add support for kernels up to 2.6.38
+b. Add support for dynamic interface binding
+
+Prior Release (Gobi3000 network driver 1.0.40) 02/28/2011
+a. In cases of QMI read errors, discard the error and continue reading.
+b. Add "interruptible" parameter, which may be disabled for debugging purposes.
+
+Prior Release (Gobi3000 network driver 1.0.30) 01/05/2011
+a. Fix rare kernel PANIC if a process terminates while file handle close 
+   or device removal is in progress.
+
+Prior Release (Gobi3000 network driver 1.0.20) 11/01/2010
+a. Fix possible kernel WARNING if device removed before QCWWANDisconnect().
+b. Fix multiple memory leaks in error cases.
+
+Prior Release (Gobi3000 network driver 1.0.10) 09/17/2010
+a. Initial release
+
+-------------------------------------------------------------------------------
+
+2. KNOWN ISSUES
+
+No known issues.
+         
+-------------------------------------------------------------------------------
+
+3. KNOWN PLATFORM ISSUES
+
+a. Enabling autosuspend:
+   Autosuspend is supported by the Gobi3000 module and its drivers, 
+   but by default it is not enabled by the open source kernel. As such,
+   the Gobi3000 module will not enter autosuspend unless the
+   user specifically turns on autosuspend with the command:
+      echo auto > /sys/bus/usb/devices/.../power/level
+b. Ksoftirq using 100% CPU:
+   There is a known issue with the open source usbnet driver that can 
+   result in infinite software interrupts. The fix for this is to test 
+   (in the usbnet_bh() function) if the usb_device can submit URBs before 
+   attempting to submit the response URB buffers.
+c. NetworkManager does not recognize connection after resume:
+   After resuming from sleep/hibernate, NetworkManager may not recognize new
+   network connections by the Gobi device. This is a system issue not specific
+   to the Gobi device, which may result in dhcp not being run and the default
+   route not being updated.  One way to fix this is to simply restart the 
+   NetworkManager service.
+
+-------------------------------------------------------------------------------
+
+
+
diff --git a/drivers/net/usb/Structs.h b/drivers/net/usb/Structs.h
new file mode 100644
index 00000000..cb734c5e
--- /dev/null
+++ b/drivers/net/usb/Structs.h
@@ -0,0 +1,599 @@
+/*===========================================================================
+FILE:
+   Structs.h
+
+DESCRIPTION:
+   Declaration of structures used by the Qualcomm Linux USB Network driver
+
+FUNCTIONS:
+   none
+
+Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Code Aurora Forum nor
+      the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+Alternatively, provided that this notice is retained in full, this software
+may be relicensed by the recipient under the terms of the GNU General Public
+License version 2 ("GPL") and only version 2, in which case the provisions of
+the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
+software under the GPL, then the identification text in the MODULE_LICENSE
+macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
+recipient changes the license terms to the GPL, subsequent recipients shall
+not relicense under alternate licensing terms, including the BSD or dual
+BSD/GPL terms.  In addition, the following license statement immediately
+below and between the words START and END shall also then apply when this
+software is relicensed under the GPL:
+
+START
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License version 2 and only version 2 as
+published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+END
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+//---------------------------------------------------------------------------
+// Pragmas
+//---------------------------------------------------------------------------
+#pragma once
+
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/usb.h>
+#include <linux/version.h>
+#include <linux/cdev.h>
+#include <linux/kthread.h>
+#include <linux/poll.h>
+#include <linux/timer.h>
+#include <linux/proc_fs.h>
+#include <linux/workqueue.h>
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,24 ))
+   #include "usbnet.h"
+#else
+   #include <linux/usb/usbnet.h>
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 2,6,25 ))
+   #include <linux/fdtable.h>
+#else
+   #include <linux/file.h>
+#endif
+
+#include <linux/semaphore.h>
+
+#define MAX_MAP (9)
+#define MAX_DSCP_ID        0x3F
+#define UNIQUE_DSCP_ID     0x40
+
+#define MAX_READ_SYNC_TASK_ID 255
+#define MAX_RETRY_LOCK_NUMBER 10
+#define MAX_RETRY_LOCK_MSLEEP_TIME 10
+#define MAX_RETRY_TASK_LOCK_TIME 10
+#define MAX_RETRY_TASK_MSLEEP_TIME 5
+#define MAX_DEVICE_MEID_SIZE 14
+#define MAX_SVC_VERSION_SIZE 512
+
+//Max number of QMUX supported 
+#define MAX_MUX_NUMBER_SUPPORTED 8
+//First supported QMUX ID
+#define MUX_ID_START 0x80
+//Last supported QMUX ID
+#define MUX_ID_END   MUX_ID_START + MAX_MUX_NUMBER_SUPPORTED
+#define RMNET_QMAP_STRING "rmnet-qmap-"
+
+// Used in recursion, defined later below
+struct sGobiUSBNet;
+
+#define MAX_WQ_PROC_NAME_SIZE 512
+/*=========================================================================*/
+// Struct sGobiPrivateWorkQueues
+//
+//    Structure that defines an entry work queues per deivce
+/*=========================================================================*/
+typedef struct sGobiPrivateWorkQueues{
+   char szProcessName[MAX_WQ_PROC_NAME_SIZE];
+   struct workqueue_struct *wqprobe;
+   struct workqueue_struct *wqProcessReadCallback;
+}sGobiPrivateWorkQueues;
+
+/*=========================================================================*/
+// Struct sReadMemList
+//
+//    Structure that defines an entry in a Read Memory linked list
+/*=========================================================================*/
+typedef struct sReadMemList
+{
+   /* Data buffer */
+   void *                     mpData;
+
+   /* Transaction ID */
+   u16                        mTransactionID;
+
+   /* Size of data buffer */
+   u16                        mDataSize;
+
+   /* Next entry in linked list */
+   struct sReadMemList *      mpNext;
+
+} sReadMemList;
+
+/*=========================================================================*/
+// Struct sNotifyList
+//
+//    Structure that defines an entry in a Notification linked list
+/*=========================================================================*/
+typedef struct sNotifyList
+{
+   /* Function to be run when data becomes available */
+   void                  (* mpNotifyFunct)(struct sGobiUSBNet *, u16, void *);
+
+   /* Transaction ID */
+   u16                   mTransactionID;
+
+   /* Data to provide as parameter to mpNotifyFunct */
+   void *                mpData;
+
+   /* Next entry in linked list */
+   struct sNotifyList *  mpNext;
+
+} sNotifyList;
+
+/*=========================================================================*/
+// Struct sURBList
+//
+//    Structure that defines an entry in a URB linked list
+/*=========================================================================*/
+typedef struct sURBList
+{
+   /* The current URB */
+   struct urb *       mpURB;
+
+   /* Next entry in linked list */
+   struct sURBList *  mpNext;
+
+} sURBList;
+
+/*=========================================================================*/
+// Struct sClientMemList
+//
+//    Structure that defines an entry in a Client Memory linked list
+//      Stores data specific to a Service Type and Client ID
+/*=========================================================================*/
+typedef struct sClientMemList
+{
+   /* Client ID for this Client */
+   u16                          mClientID;
+
+   /* Linked list of Read entries */
+   /*    Stores data read from device before sending to client */
+   sReadMemList *               mpList;
+
+   /* Linked list of Notification entries */
+   /*    Stores notification functions to be run as data becomes
+         available or the device is removed */
+   sNotifyList *                mpReadNotifyList;
+
+   /* Linked list of URB entries */
+   /*    Stores pointers to outstanding URBs which need canceled
+         when the client is deregistered or the device is removed */
+   sURBList *                   mpURBList;
+
+   /* Next entry in linked list */
+   struct sClientMemList *      mpNext;
+
+   /* Wait queue object for poll() */
+   wait_queue_head_t    mWaitQueue;
+
+} sClientMemList;
+
+/*=========================================================================*/
+// Struct sURBSetupPacket
+//
+//    Structure that defines a USB Setup packet for Control URBs
+//    Taken from USB CDC specifications
+/*=========================================================================*/
+typedef struct sURBSetupPacket
+{
+   /* Request type */
+   u8    mRequestType;
+
+   /* Request code */
+   u8    mRequestCode;
+
+   /* Value */
+   u16   mValue;
+
+   /* Index */
+   u16   mIndex;
+
+   /* Length of Control URB */
+   u16   mLength;
+
+} sURBSetupPacket;
+
+// Common value for sURBSetupPacket.mLength
+#define DEFAULT_READ_URB_LENGTH 0x1000
+
+
+/*=========================================================================*/
+// Struct sAutoPM
+//
+//    Structure used to manage AutoPM thread which determines whether the
+//    device is in use or may enter autosuspend.  Also submits net
+//    transmissions asynchronously.
+/*=========================================================================*/
+typedef struct sAutoPM
+{
+   /* Thread for atomic autopm function */
+   struct task_struct *       mpThread;
+
+   /* Signal for completion when it's time for the thread to work */
+   struct completion          mThreadDoWork;
+
+   /* Time to exit? */
+   bool                       mbExit;
+
+   /* List of URB's queued to be sent to the device */
+   sURBList *                 mpURBList;
+
+   /* URB list lock (for adding and removing elements) */
+   spinlock_t                 mURBListLock;
+
+   /* Length of the URB list */
+   atomic_t                   mURBListLen;
+   
+   /* Active URB */
+   struct urb *               mpActiveURB;
+
+   /* Active URB lock (for adding and removing elements) */
+   spinlock_t                 mActiveURBLock;
+
+   /* Duplicate pointer to USB device interface */
+   struct usb_interface *     mpIntf;
+
+} sAutoPM;
+
+
+/*=========================================================================*/
+// Struct sQMIDev
+//
+//    Structure that defines the data for the QMI device
+/*=========================================================================*/
+typedef struct sQMIDev
+{
+   /* Device number */
+   dev_t                      mDevNum;
+
+   /* Device class */
+   struct class *             mpDevClass;
+
+   /* cdev struct */
+   struct cdev                mCdev;
+
+   /* is mCdev initialized? */
+   bool                       mbCdevIsInitialized;
+
+   /* Pointer to read URB */
+   struct urb *               mpReadURB;
+
+   /* Read setup packet */
+   sURBSetupPacket *          mpReadSetupPacket;
+
+   /* Read buffer attached to current read URB */
+   void *                     mpReadBuffer;
+
+   /* Inturrupt URB */
+   /*    Used to asynchronously notify when read data is available */
+   struct urb *               mpIntURB;
+
+   /* Buffer used by Inturrupt URB */
+   void *                     mpIntBuffer;
+
+   /* Pointer to memory linked list for all clients */
+   sClientMemList *           mpClientMemList;
+
+   /* Spinlock for client Memory entries */
+   spinlock_t                 mClientMemLock;
+   unsigned long              mFlag;
+   struct task_struct         *pTask;
+    /* semaphore for Notify */
+   struct semaphore           mNotifyMemLock;
+
+   /* Transaction ID associated with QMICTL "client" */
+   atomic_t                   mQMICTLTransactionID;
+
+   unsigned char              qcqmi;
+
+   int                        iInterfaceNumber;
+   struct proc_dir_entry *    proc_file;
+} sQMIDev;
+
+enum qos_flow_state {
+    FLOW_ACTIVATED = 0x01,
+    FLOW_SUSPENDED = 0x02,
+    FLOW_DELETED = 0x03,
+    FLOW_MODIFIED,
+    FLOW_ENABLED,
+    FLOW_DISABLED,
+    FLOW_INVALID = 0xff
+}; 
+
+typedef struct {
+    u8  dscp;
+    u32 qosId;
+    u8  state;
+} sMapping;
+
+typedef struct {
+    u8 count;
+    sMapping table[MAX_MAP];
+} sMappingTable;
+
+typedef struct {
+  u32 rx_packets;
+  u32 tx_packets;
+  u64 rx_bytes;
+  u64 tx_bytes;
+  u32 rx_errors;
+  u32 tx_errors;
+  u32 rx_overflows;
+  u32 tx_overflows;
+} sNetStats;
+
+#define IPV6_ADDR_LEN 16
+typedef struct ipv6_addr
+{
+   u8         ipv6addr[IPV6_ADDR_LEN];
+   u8         prefix;
+}__attribute__((__packed__)) ipv6_addr;
+
+
+typedef struct {
+    u8 instance;
+    unsigned int ipAddress;
+    ipv6_addr    ipV6Address;
+} sQMuxIPTable;
+
+typedef struct gobi_qmimux_hdr{
+   u8 pad;
+   u8 mux_id;
+   __be16 pkt_len;
+}gobi_qmimux_hdr;
+
+typedef struct qmap_ipv4_header
+{
+#ifdef LITTLE_ENDIAN
+   unsigned char ihl:4;
+   unsigned char version:4;
+   unsigned char ecn:2;
+   unsigned char dscp:6;
+#else
+   unsigned char version:4;
+   unsigned char ihl:4;
+   unsigned char dscp:6;
+   unsigned char ecn:2;
+#endif
+   unsigned short total_length;
+   unsigned short identification;
+   unsigned short fragment_offset;
+   unsigned char ttl;
+   unsigned char protocol;
+   unsigned short header_checksum;
+   unsigned int src_address;
+   unsigned int dst_address;
+} __attribute__ ((aligned (1))) *qmap_ipv4_header_t;
+
+typedef struct qmap_ipv6_header
+{
+   unsigned int version:4;
+   unsigned int traffic_class:8;
+   unsigned int flow_label:20;
+   unsigned short length;
+   unsigned char next_header;
+   unsigned char hop_limit;
+   unsigned char src_address[16];
+   unsigned char dst_address[16];
+} __attribute__ ((aligned (1))) *qmap_ipv6_header_t;
+
+enum{
+   eDataMode_Unknown=-1,
+   eDataMode_Ethernet,
+   eDataMode_RAWIP,
+};
+
+enum{
+   eNetDeviceLink_Unknown=-1,
+   eNetDeviceLink_Disconnected,
+   eNetDeviceLink_Connected,
+};
+
+/*=========================================================================*/
+// Struct sGobiUSBNet
+//
+//    Structure that defines the data associated with the Qualcomm USB device
+/*=========================================================================*/
+typedef struct sGobiUSBNet
+{
+   /* Net device structure */
+   struct usbnet *        mpNetDev;
+
+   /* Usb device interface */
+   struct usb_interface * mpIntf;
+
+   /* Pointers to usbnet_open and usbnet_stop functions */
+   int                  (* mpUSBNetOpen)(struct net_device *);
+   int                  (* mpUSBNetStop)(struct net_device *);
+
+   /* Reason(s) why interface is down */
+   /* Used by Gobi*DownReason */
+   unsigned long          mDownReason;
+#define NO_NDIS_CONNECTION    0
+#define CDC_CONNECTION_SPEED  1
+#define DRIVER_SUSPENDED      2
+#define NET_IFACE_STOPPED     3
+
+   /* QMI "device" status */
+   bool                   mbQMIValid;
+   int                   mbUnload;
+   int                   mReleaseClientIDFail;
+   /* QMI "device" memory */
+   sQMIDev                mQMIDev;
+
+   /* Device MEID */
+   char                   mMEID[MAX_DEVICE_MEID_SIZE];
+
+   /* Service version Info */
+   u8                     svcVersion[MAX_SVC_VERSION_SIZE];
+
+   /* AutoPM thread */
+   sAutoPM                mAutoPM;
+
+   /* Ethernet header templates */
+   /* IPv4 */
+   u8  eth_hdr_tmpl_ipv4[ETH_HLEN];
+   /* IPv6 */
+   u8  eth_hdr_tmpl_ipv6[ETH_HLEN];
+
+   u32 tx_qlen;
+
+   sMappingTable maps;
+
+   /*
+    * Read write semaphore so that ReleaseClientID() waits until WriteSync() exits to handle 
+    * below limitation
+    * If a thread in your driver uses this call, make sure your disconnect()
+    * method can wait for it to complete.  Since you don't have a handle on the
+    * URB used, you can't cancel the request.
+    */
+   struct rw_semaphore shutdown_rwsem;
+   int iShutdown_read_sem;
+   int iShutdown_write_sem;
+
+   struct timer_list read_tmr;
+   u16 readTimeoutCnt;
+   u16 writeTimeoutCnt;
+
+   bool bLinkState;
+   u16 mtu;
+   #ifdef CONFIG_PM
+   bool bSuspend;
+   spinlock_t sSuspendLock;
+   #endif
+   bool mIs9x15;
+   struct usb_interface *mUsb_Interface;
+   int iTaskID;
+   struct task_struct *task;
+   
+   int iReasSyncTaskID[MAX_READ_SYNC_TASK_ID];
+   struct semaphore readSem[MAX_READ_SYNC_TASK_ID];
+   struct semaphore ReadsyncSem;
+   
+   struct semaphore taskIDSem;
+   int iIsClosing;
+   struct device *qcqmidev;
+   struct device *dev;
+   u16 WDSClientID;
+   int iNetLinkStatus;
+   int iDataMode;
+   spinlock_t urb_lock;
+   spinlock_t notif_lock;
+   int iUSBState;
+   int iDeviceMuxID;
+   int iQMUXEnable;
+   int iStoppingNetDev;
+   int nRmnet;
+   int iMaxMuxID;
+   int iPacketInComplete;
+   struct sk_buff *pLastSKB;
+   struct net_device *pNetDevice[MAX_MUX_NUMBER_SUPPORTED];
+   sQMuxIPTable      qMuxIPTable[MAX_MUX_NUMBER_SUPPORTED];
+   u32 ULDatagramSize;
+   u32 ULDatagram;
+   int iIPAlias;
+   /*
+    * Workqueue and Delaywork to probe device.
+    */
+   struct workqueue_struct *wqprobe;
+   struct delayed_work dwprobe;
+   /*
+    * Workqueue and Delaywork to Process Interrupt URB.
+    */
+   struct workqueue_struct *wqProcessReadCallback;
+   struct delayed_work dwProcessReadCallback;
+   struct urb *pReadURB;
+} sGobiUSBNet;
+
+/*=========================================================================*/
+// Struct sQMIFilpStorage
+//
+//    Structure that defines the storage each file handle contains
+//       Relates the file handle to a client
+/*=========================================================================*/
+typedef struct sQMIFilpStorage
+{
+   /* Client ID */
+   u16                  mClientID;
+   int                  mDeviceInvalid;
+   /* Device pointer */
+   sGobiUSBNet *          mpDev;
+   int iSemID ;
+   struct semaphore       mReadSem;
+   int iReleaseSemID ;
+   struct semaphore       mReleasedSem;
+   int                    iIsClosing;
+   int                    iReadSyncResult;
+   int                    iInfNum;
+   struct task_struct     *pOpenTask;
+   struct task_struct     *pReadTask;
+   struct task_struct     *pWriteTask;
+   struct task_struct     *pIOCTLTask;
+   int                    iCount;
+} sQMIFilpStorage;
+
+struct gobi_qmimux_priv {
+   struct net_device *real_dev;
+   u8 mux_id;
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION( 3,0,0 )
+#ifndef kstrtol
+#define kstrtol strict_strtol
+#endif
+#endif
diff --git a/drivers/net/usb/gobi_usbnet.h b/drivers/net/usb/gobi_usbnet.h
new file mode 100644
index 00000000..b8f6253d
--- /dev/null
+++ b/drivers/net/usb/gobi_usbnet.h
@@ -0,0 +1,51 @@
+/*===========================================================================
+FILE:
+   gobi_usbnet.h
+
+DESCRIPTION:
+   header for specific usbnet_tx_timeout and usbnet_start_xmit
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+#if (LINUX_VERSION_CODE == KERNEL_VERSION( 2,6,31 ) ||\
+       LINUX_VERSION_CODE == KERNEL_VERSION( 2,6,32 ))
+void gobi_usbnet_tx_timeout_2_6_32 (struct net_device *net);
+int gobi_usbnet_start_xmit_2_6_32 (struct sk_buff *skb, struct net_device *net);
+#elif (LINUX_VERSION_CODE == KERNEL_VERSION( 2,6,35 ))
+void gobi_usbnet_tx_timeout_2_6_35 (struct net_device *net);
+netdev_tx_t gobi_usbnet_start_xmit_2_6_35 (struct sk_buff *skb,
+                     struct net_device *net);
+#elif (LINUX_VERSION_CODE == KERNEL_VERSION( 3,0,6 ))
+void gobi_usbnet_tx_timeout_3_0_6 (struct net_device *net);
+netdev_tx_t gobi_usbnet_start_xmit_3_0_6 (struct sk_buff *skb,
+                     struct net_device *net);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,10,1 ) &&\
+       LINUX_VERSION_CODE <= KERNEL_VERSION( 3,10,39 ))
+void gobi_usbnet_tx_timeout_3_10_21 (struct net_device *net);
+netdev_tx_t gobi_usbnet_start_xmit_3_10_21 (struct sk_buff *skb,
+                     struct net_device *net);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,12,0 ) &&\
+       LINUX_VERSION_CODE < KERNEL_VERSION( 3,13,0 ))
+void gobi_usbnet_tx_timeout_3_12_xx(struct net_device *net);
+netdev_tx_t gobi_usbnet_start_xmit_3_12_xx (struct sk_buff *skb,
+                     struct net_device *net);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION( 4,4,0 ) &&\
+          LINUX_VERSION_CODE < KERNEL_VERSION( 4,5,0 ))
+void gobi_usbnet_tx_timeout_4_4_xx(struct net_device *net);
+netdev_tx_t gobi_usbnet_start_xmit_4_4_xx(struct sk_buff *skb,
+                     struct net_device *net);
+
+#else
+#endif
+
diff --git a/drivers/net/usb/usbnet_2_6_32.c b/drivers/net/usb/usbnet_2_6_32.c
new file mode 100644
index 00000000..b4fd1936
--- /dev/null
+++ b/drivers/net/usb/usbnet_2_6_32.c
@@ -0,0 +1,396 @@
+/*===========================================================================
+FILE:
+   usbnet_2_6_32.c
+
+DESCRIPTION:
+   The default "usbnet_start_xmit" function is over-ridden by Sierra to provide the URB_Monitor
+   for Linux kernel 2.6.32
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+
+#include "Structs.h"
+#include "QMIDevice.h"
+#include "QMI.h"
+#include "gobi_usbnet.h"
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/module.h>
+#include <net/ip.h>
+
+#include <asm/siginfo.h>   //siginfo
+#include <linux/rcupdate.h>   //rcu_read_lock
+#include <linux/sched.h>   //find_task_by_pid_type
+
+#if (LINUX_VERSION_CODE == KERNEL_VERSION( 2,6,31 ) ||\
+	   LINUX_VERSION_CODE == KERNEL_VERSION( 2,6,32 ))
+void (*URB_monitor) (bool,unsigned char);
+EXPORT_SYMBOL(URB_monitor);
+#if 0
+/*
+ * Dummy function to test URB back-pressure. In actual implementation,
+ * customer will implement this function
+ */
+// Define PDN interfaced as per specific Sierra module PTS. The below are for MC73xx modules 
+#define PDN1_INTERFACE 8 
+#define PDN2_INTERFACE 10
+#define BACK_PRESSURE_WATERMARK 10
+static unsigned short urb_count_pdn1 = 0;
+static unsigned short urb_count_pdn2 = 0;
+void URB_monitor (bool isUpCount,unsigned char interface)
+{
+/*	printk(KERN_WARNING "[%s] isUpCount %d, intf %d", \
+			__func__, isUpCount, interface);*/
+	if (isUpCount)
+	{
+		if (interface == PDN1_INTERFACE)
+		{
+			urb_count_pdn1++;
+		}
+		else if (interface == PDN2_INTERFACE)
+		{
+			urb_count_pdn2++;
+		}
+		else
+		{
+			// unknown interface. ignore or log as needed
+		}
+	}
+	else
+	{
+		if (interface == PDN1_INTERFACE)
+		{
+			urb_count_pdn1--;
+		}
+		else if (interface == PDN2_INTERFACE)
+		{
+			urb_count_pdn2--;
+		}
+		else
+		{
+			// unknown interface. ignore or log as needed
+		}	
+	}
+	if (BACK_PRESSURE_WATERMARK <= urb_count_pdn1)
+	{
+		// Back pressure on PDN1
+		printk(KERN_WARNING "[%s] Backpressure %d on PDN1", \
+				__func__, urb_count_pdn1);
+	}	
+	if (BACK_PRESSURE_WATERMARK <= urb_count_pdn2)
+	{
+		// Back pressure on PDN2
+		printk(KERN_WARNING "[%s] Backpressure %d on PDN2", \
+				__func__, urb_count_pdn2);
+	}	
+}
+#endif // 0 End of dummy function
+
+// Get the USB interface from a usbnet pointer. The function return 0 on success, -1 on error
+__always_inline static int get_usb_interface_from_device (struct usbnet	*dev, unsigned char *pb_usb_interface)
+{
+    int iRet = -1; // set to error by default	
+	
+    if ((NULL!=dev) && (NULL!=pb_usb_interface))
+    {
+        if ((NULL != dev->intf) &&
+            (NULL != dev->intf->cur_altsetting))
+        {
+            *pb_usb_interface = dev->intf->cur_altsetting->desc.bInterfaceNumber;
+            iRet = 0;
+        } // (NULL != dev->intf) && (NULL != dev->intf->cur_altsetting)
+    } //(NULL != pURB) && (NULL!=pb_usb_interface)
+    return iRet;
+}
+
+// Get the USB interface from a URB. The function return 0 on success, -1 on error
+__always_inline static int get_usb_interface (struct urb * pURB, unsigned char *pb_usb_interface)
+{
+    int iRet = -1; // set to error by default	
+    struct sk_buff  *skb   = NULL;
+    struct skb_data	*entry = NULL;
+
+    if ((NULL!=pURB) && (NULL!=pb_usb_interface))
+    { 
+        skb = (struct sk_buff *) pURB->context;
+        if (NULL != skb)
+        {
+            entry = (struct skb_data *) skb->cb;
+            if (NULL != entry)
+            {
+                iRet = get_usb_interface_from_device (entry->dev, pb_usb_interface);
+            }
+        } // (NULL != skb)
+    } // (NULL != pURB) && (NULL!=pb_usb_interface)
+    return iRet;
+}
+
+// unlink pending rx/tx; completion handlers do all other cleanup
+static int unlink_urbs (struct usbnet *dev, struct sk_buff_head *q)
+{
+	unsigned long		flags;
+	struct sk_buff		*skb, *skbnext;
+	int			count = 0;
+
+	spin_lock_irqsave (&q->lock, flags);
+	skb_queue_walk_safe(q, skb, skbnext) {
+		struct skb_data		*entry;
+		struct urb		*urb;
+		int			retval;
+
+		entry = (struct skb_data *) skb->cb;
+		urb = entry->urb;
+
+		/*
+		 * Get reference count of the URB to avoid it to be
+		 * freed during usb_unlink_urb, which may trigger
+		 * use-after-free problem inside usb_unlink_urb since
+		 * usb_unlink_urb is always racing with .complete
+		 * handler(include defer_bh).
+		 */
+		usb_get_urb(urb);
+		spin_unlock_irqrestore(&q->lock, flags);
+		// during some PM-driven resume scenarios,
+		// these (async) unlinks complete immediately
+		retval = usb_unlink_urb (urb);
+		if (retval != -EINPROGRESS && retval != 0)
+			devdbg (dev, "unlink urb err, %d", retval);
+		else
+			count++;
+		usb_put_urb(urb);
+		spin_lock_irqsave(&q->lock, flags);
+	}
+	spin_unlock_irqrestore (&q->lock, flags);
+	return count;
+}
+
+void gobi_usbnet_tx_timeout_2_6_32 (struct net_device *net)
+{
+   struct usbnet		*dev = netdev_priv(net);
+#ifdef TX_URB_MONITOR
+   int count = 0;   
+   int iRet = -1;
+   unsigned char b_usb_if_num = 0;
+   // Get the USB interface
+   iRet = get_usb_interface_from_device (dev, &b_usb_if_num);	
+
+   count = unlink_urbs (dev, &dev->txq);
+   tasklet_schedule (&dev->bh);
+
+   if ((URB_monitor) && (0==iRet))
+   {
+       while (count)
+	   {
+			URB_monitor(false, b_usb_if_num);
+			count--;
+	   }
+   }
+#else // TX_URB_MONITOR
+   unlink_urbs (dev, &dev->txq);
+   tasklet_schedule (&dev->bh);
+#endif // TX_URB_MONITOR
+   // FIXME: device recovery -- reset?
+}
+
+/* some LK 2.4 HCDs oopsed if we freed or resubmitted urbs from
+ * completion callbacks.  2.5 should have fixed those bugs...
+ */
+
+static void defer_bh(struct usbnet *dev, struct sk_buff *skb, struct sk_buff_head *list)
+{
+   unsigned long		flags;
+
+   spin_lock_irqsave(&list->lock, flags);
+   __skb_unlink(skb, list);
+   spin_unlock(&list->lock);
+   spin_lock(&dev->done.lock);
+   __skb_queue_tail(&dev->done, skb);
+   if (dev->done.qlen == 1)
+      tasklet_schedule(&dev->bh);
+   spin_unlock_irqrestore(&dev->done.lock, flags);
+}
+
+static void tx_complete (struct urb *urb)
+{
+   struct sk_buff		*skb = (struct sk_buff *) urb->context;
+   struct skb_data		*entry = (struct skb_data *) skb->cb;
+   struct usbnet		*dev = entry->dev;
+
+#ifdef TX_URB_MONITOR
+	unsigned char b_usb_if_num = 0;
+    int iRet = get_usb_interface(urb, &b_usb_if_num);
+#endif //#ifdef TX_URB_MONITOR
+
+   if (urb->status == 0)
+   {
+      dev->net->stats.tx_packets++;
+      dev->net->stats.tx_bytes += entry->length;
+   }
+   else
+   {
+      dev->net->stats.tx_errors++;
+      switch (urb->status)
+      {
+         case -EPIPE:
+            usbnet_defer_kevent (dev, EVENT_TX_HALT);
+            break;
+       
+         /* software-driven interface shutdown */
+         case -ECONNRESET:		// async unlink
+         case -ESHUTDOWN:		// hardware gone
+            break;
+       
+         // like rx, tx gets controller i/o faults during khubd delays
+         // and so it uses the same throttling mechanism.
+         case -EPROTO:
+         case -ETIME:
+         case -EILSEQ:
+            if (!timer_pending (&dev->delay)) {
+             mod_timer (&dev->delay,
+             jiffies + THROTTLE_JIFFIES);
+            if (netif_msg_link (dev))
+               devdbg (dev, "tx throttle %d",
+                            urb->status);
+            }
+            netif_stop_queue (dev->net);
+            break;
+         default:
+            if (netif_msg_tx_err (dev))
+               devdbg (dev, "tx err %d", entry->urb->status);
+            break;
+    		}
+  	}
+
+   entry->state = tx_done;
+   defer_bh(dev, skb, &dev->txq);
+
+#ifdef TX_URB_MONITOR
+   if ((URB_monitor) && (0==iRet))
+   {
+       URB_monitor(false, b_usb_if_num);
+   }
+#endif //#ifdef TX_URB_MONITOR
+
+}
+
+int gobi_usbnet_start_xmit_2_6_32 (struct sk_buff *skb, struct net_device *net)
+{
+   struct usbnet		*dev = netdev_priv(net);
+   int			length;
+   struct urb		*urb = NULL;
+   struct skb_data		*entry;
+   struct driver_info	*info = dev->driver_info;
+   unsigned long		flags;
+   int retval;
+#ifdef TX_URB_MONITOR   
+   unsigned char b_usb_if_num = 0;
+   int iRet = -1;
+#endif //#ifdef TX_URB_MONITOR
+   // some devices want funky USB-level framing, for
+   // win32 driver (usually) and/or hardware quirks
+   if (info->tx_fixup)
+   {
+      skb = info->tx_fixup (dev, skb, GFP_ATOMIC);
+      if (!skb)
+      {
+         if (netif_msg_tx_err (dev))
+            devdbg (dev, "can't tx_fixup skb");
+         goto drop;
+      }
+   }
+   length = skb->len;
+  
+   if (!(urb = usb_alloc_urb (0, GFP_ATOMIC)))
+   {
+      if (netif_msg_tx_err (dev))
+         devdbg (dev, "no urb");
+      goto drop;
+   }
+
+   entry = (struct skb_data *) skb->cb;
+   entry->urb = urb;
+   entry->dev = dev;
+   entry->state = tx_start;
+   entry->length = length;
+  
+   usb_fill_bulk_urb (urb, dev->udev, dev->out,
+   	                         skb->data, skb->len, tx_complete, skb);
+  
+   /* don't assume the hardware handles USB_ZERO_PACKET
+    * NOTE:  strictly conforming cdc-ether devices should expect
+    * the ZLP here, but ignore the one-byte packet.
+    */
+   if (!(info->flags & FLAG_SEND_ZLP) && (length % dev->maxpacket) == 0)
+   {
+      urb->transfer_buffer_length++;
+      if (skb_tailroom(skb))
+      {
+         skb->data[skb->len] = 0;
+         __skb_put(skb, 1);
+      }
+   }
+   spin_lock_irqsave (&dev->txq.lock, flags);
+#ifdef TX_URB_MONITOR
+   iRet = get_usb_interface(urb, &b_usb_if_num);
+#endif //#ifdef TX_URB_MONITOR  
+   switch ((retval = usb_submit_urb (urb, GFP_ATOMIC)))
+   {
+      case -EPIPE:
+         netif_stop_queue (net);
+         usbnet_defer_kevent (dev, EVENT_TX_HALT);
+         break;
+      default:
+         if (netif_msg_tx_err (dev))
+            devdbg (dev, "tx: submit urb err %d", retval);
+         break;
+      	case 0:
+         net->trans_start = jiffies;
+         __skb_queue_tail (&dev->txq, skb);
+         if (dev->txq.qlen >= TX_QLEN (dev))
+            netif_stop_queue (net);
+   }
+#ifdef TX_URB_MONITOR
+   /*
+    * Call URB_monitor() with true as the URB has been successfully 
+    * submitted to the txq. 
+    */
+   if ((URB_monitor) && (0==iRet) && (0==retval))
+   {
+       URB_monitor(true, b_usb_if_num);
+   }
+#endif //#ifdef TX_URB_MONITOR
+   spin_unlock_irqrestore (&dev->txq.lock, flags);
+   if (retval)
+   {
+      if (netif_msg_tx_err (dev))
+       devdbg (dev, "drop, code %d", retval);
+      drop:
+      retval = NET_XMIT_SUCCESS;
+      dev->net->stats.tx_dropped++;
+      if (skb)
+         dev_kfree_skb_any (skb);
+      usb_free_urb (urb);
+   }
+   else if (netif_msg_tx_queued (dev))
+   {
+      devdbg (dev, "> tx, len %d, type 0x%x",
+                  length, skb->protocol);
+   }
+   return NETDEV_TX_OK;
+}
+#endif /* LINUX_VERSION_CODE == KERNEL_VERSION( 2,6,31 ) */
+
diff --git a/drivers/net/usb/usbnet_2_6_35.c b/drivers/net/usb/usbnet_2_6_35.c
new file mode 100644
index 00000000..059326df
--- /dev/null
+++ b/drivers/net/usb/usbnet_2_6_35.c
@@ -0,0 +1,400 @@
+/*===========================================================================
+FILE:
+   usbnet_2_6_35.c
+
+DESCRIPTION:
+   The default "usbnet_start_xmit" function is over-ridden by Sierra to provide the URB_Monitor
+   for Linux kernel 2.6.35
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+
+#include "Structs.h"
+#include "QMIDevice.h"
+#include "QMI.h"
+#include "gobi_usbnet.h"
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/module.h>
+#include <net/ip.h>
+
+#include <asm/siginfo.h>   //siginfo
+#include <linux/rcupdate.h>   //rcu_read_lock
+#include <linux/sched.h>   //find_task_by_pid_type
+
+#if (LINUX_VERSION_CODE == KERNEL_VERSION( 2,6,35 ))
+void (*URB_monitor) (bool,unsigned char);
+EXPORT_SYMBOL(URB_monitor);
+#if 0
+/*
+ * Dummy function to test URB back-pressure. In actual implementation,
+ * customer will implement this function
+ */
+// Define PDN interfaced as per specific Sierra module PTS. The below are for MC73xx modules 
+#define PDN1_INTERFACE 8 
+#define PDN2_INTERFACE 10
+#define BACK_PRESSURE_WATERMARK 10
+static unsigned short urb_count_pdn1 = 0;
+static unsigned short urb_count_pdn2 = 0;
+void URB_monitor (bool isUpCount,unsigned char interface)
+{
+/*   printk(KERN_WARNING "[%s] isUpCount %d, intf %d", \
+         __func__, isUpCount, interface);*/
+   if (isUpCount)
+   {
+      if (interface == PDN1_INTERFACE)
+      {
+         urb_count_pdn1++;
+      }
+      else if (interface == PDN2_INTERFACE)
+      {
+         urb_count_pdn2++;
+      }
+      else
+      {
+         // unknown interface. ignore or log as needed
+      }
+   }
+   else
+   {
+      if (interface == PDN1_INTERFACE)
+      {
+         urb_count_pdn1--;
+      }
+      else if (interface == PDN2_INTERFACE)
+      {
+         urb_count_pdn2--;
+      }
+      else
+      {
+         // unknown interface. ignore or log as needed
+      }   
+   }
+   if (BACK_PRESSURE_WATERMARK <= urb_count_pdn1)
+   {
+      // Back pressure on PDN1
+      printk(KERN_WARNING "[%s] Backpressure %d on PDN1", \
+            __func__, urb_count_pdn1);
+   }   
+   if (BACK_PRESSURE_WATERMARK <= urb_count_pdn2)
+   {
+      // Back pressure on PDN2
+      printk(KERN_WARNING "[%s] Backpressure %d on PDN2", \
+            __func__, urb_count_pdn2);
+   }   
+}
+#endif // 0 End of dummy function
+
+// Get the USB interface from a usbnet pointer. The function return 0 on success, -1 on error
+__always_inline static int get_usb_interface_from_device (struct usbnet   *dev, unsigned char *pb_usb_interface)
+{
+    int iRet = -1; // set to error by default   
+   
+    if ((NULL!=dev) && (NULL!=pb_usb_interface))
+    {
+        if ((NULL != dev->intf) &&
+            (NULL != dev->intf->cur_altsetting))
+        {
+            *pb_usb_interface = dev->intf->cur_altsetting->desc.bInterfaceNumber;
+            iRet = 0;
+        } // (NULL != dev->intf) && (NULL != dev->intf->cur_altsetting)
+    } //(NULL != pURB) && (NULL!=pb_usb_interface)
+    return iRet;
+}
+
+// Get the USB interface from a URB. The function return 0 on success, -1 on error
+__always_inline static int get_usb_interface (struct urb * pURB, unsigned char *pb_usb_interface)
+{
+    int iRet = -1; // set to error by default   
+    struct sk_buff  *skb   = NULL;
+    struct skb_data   *entry = NULL;
+
+    if ((NULL!=pURB) && (NULL!=pb_usb_interface))
+    { 
+        skb = (struct sk_buff *) pURB->context;
+        if (NULL != skb)
+        {
+            entry = (struct skb_data *) skb->cb;
+            if (NULL != entry)
+            {
+                iRet = get_usb_interface_from_device (entry->dev, pb_usb_interface);
+            }
+        } // (NULL != skb)
+    } // (NULL != pURB) && (NULL!=pb_usb_interface)
+    return iRet;
+}
+
+// unlink pending rx/tx; completion handlers do all other cleanup
+
+static int unlink_urbs (struct usbnet *dev, struct sk_buff_head *q)
+{
+   unsigned long      flags;
+   struct sk_buff      *skb, *skbnext;
+   int         count = 0;
+
+   spin_lock_irqsave (&q->lock, flags);
+   skb_queue_walk_safe(q, skb, skbnext) {
+      struct skb_data      *entry;
+      struct urb      *urb;
+      int         retval;
+
+      entry = (struct skb_data *) skb->cb;
+      urb = entry->urb;
+
+      // during some PM-driven resume scenarios,
+      // these (async) unlinks complete immediately
+      retval = usb_unlink_urb (urb);
+      if (retval != -EINPROGRESS && retval != 0)
+         netdev_dbg(dev->net, "unlink urb err, %d\n", retval);
+      else
+         count++;
+   }
+   spin_unlock_irqrestore (&q->lock, flags);
+   return count;
+}
+
+void gobi_usbnet_tx_timeout_2_6_35(struct net_device *net)
+{
+   struct usbnet      *dev = netdev_priv(net);
+#ifdef TX_URB_MONITOR
+   int count = 0;   
+   int iRet = -1;
+   unsigned char b_usb_if_num = 0;
+   // Get the USB interface
+   iRet = get_usb_interface_from_device (dev, &b_usb_if_num);   
+
+   count = unlink_urbs (dev, &dev->txq);
+   tasklet_schedule (&dev->bh);
+
+   if ((URB_monitor) && (0==iRet))
+   {
+       while (count)
+      {
+         URB_monitor(false, b_usb_if_num);
+         count--;
+      }
+   }
+#else // TX_URB_MONITOR
+   unlink_urbs (dev, &dev->txq);
+   tasklet_schedule (&dev->bh);
+#endif // TX_URB_MONITOR
+   // FIXME: device recovery -- reset?
+}
+
+/* some LK 2.4 HCDs oopsed if we freed or resubmitted urbs from
+ * completion callbacks.  2.5 should have fixed those bugs...
+ */
+
+static void defer_bh(struct usbnet *dev, struct sk_buff *skb, struct sk_buff_head *list)
+{
+   unsigned long      flags;
+
+   spin_lock_irqsave(&list->lock, flags);
+   __skb_unlink(skb, list);
+   spin_unlock(&list->lock);
+   spin_lock(&dev->done.lock);
+   __skb_queue_tail(&dev->done, skb);
+   if (dev->done.qlen == 1)
+      tasklet_schedule(&dev->bh);
+   spin_unlock_irqrestore(&dev->done.lock, flags);
+}
+
+static void tx_complete (struct urb *urb)
+{
+   struct sk_buff      *skb = (struct sk_buff *) urb->context;
+   struct skb_data      *entry = (struct skb_data *) skb->cb;
+   struct usbnet      *dev = entry->dev;
+
+#ifdef TX_URB_MONITOR
+   unsigned char b_usb_if_num = 0;
+    int iRet = get_usb_interface(urb, &b_usb_if_num);
+#endif //#ifdef TX_URB_MONITOR
+
+   if (urb->status == 0) {
+      dev->net->stats.tx_packets++;
+      dev->net->stats.tx_bytes += entry->length;
+   } else {
+      dev->net->stats.tx_errors++;
+
+      switch (urb->status) {
+      case -EPIPE:
+         usbnet_defer_kevent (dev, EVENT_TX_HALT);
+         break;
+
+      /* software-driven interface shutdown */
+      case -ECONNRESET:      // async unlink
+      case -ESHUTDOWN:      // hardware gone
+         break;
+
+      // like rx, tx gets controller i/o faults during khubd delays
+      // and so it uses the same throttling mechanism.
+      case -EPROTO:
+      case -ETIME:
+      case -EILSEQ:
+         usb_mark_last_busy(dev->udev);
+         if (!timer_pending (&dev->delay)) {
+            mod_timer (&dev->delay,
+               jiffies + THROTTLE_JIFFIES);
+            netif_dbg(dev, link, dev->net,
+                 "tx throttle %d\n", urb->status);
+         }
+         netif_stop_queue (dev->net);
+         break;
+      default:
+         netif_dbg(dev, tx_err, dev->net,
+              "tx err %d\n", entry->urb->status);
+         break;
+      }
+   }
+
+   gobi_usb_autopm_put_interface_async(dev->intf);
+   urb->dev = NULL;
+   entry->state = tx_done;
+   defer_bh(dev, skb, &dev->txq);
+
+#ifdef TX_URB_MONITOR
+   if ((URB_monitor) && (0==iRet))
+   {
+       URB_monitor(false, b_usb_if_num);
+   }
+#endif //#ifdef TX_URB_MONITOR
+
+}
+
+int gobi_usbnet_start_xmit_2_6_35 (struct sk_buff *skb, struct net_device *net)
+{
+   struct usbnet      *dev = netdev_priv(net);
+   int         length;
+   struct urb      *urb = NULL;
+   struct skb_data      *entry;
+   struct driver_info   *info = dev->driver_info;
+   unsigned long      flags;
+   int retval;
+#ifdef TX_URB_MONITOR   
+   unsigned char b_usb_if_num = 0;
+   int iRet = -1;
+#endif //#ifdef TX_URB_MONITOR
+   // some devices want funky USB-level framing, for
+   // win32 driver (usually) and/or hardware quirks
+   if (info->tx_fixup) {
+      skb = info->tx_fixup (dev, skb, GFP_ATOMIC);
+      if (!skb) {
+         netif_dbg(dev, tx_err, dev->net, "can't tx_fixup skb\n");
+         goto drop;
+      }
+   }
+   length = skb->len;
+
+   if (!(urb = usb_alloc_urb (0, GFP_ATOMIC))) {
+      netif_dbg(dev, tx_err, dev->net, "no urb\n");
+      goto drop;
+   }
+
+   entry = (struct skb_data *) skb->cb;
+   entry->urb = urb;
+   entry->dev = dev;
+   entry->state = tx_start;
+   entry->length = length;
+
+   usb_fill_bulk_urb (urb, dev->udev, dev->out,
+         skb->data, skb->len, tx_complete, skb);
+
+   /* don't assume the hardware handles USB_ZERO_PACKET
+    * NOTE:  strictly conforming cdc-ether devices should expect
+    * the ZLP here, but ignore the one-byte packet.
+    */
+   if (length % dev->maxpacket == 0) {
+      if (!(info->flags & FLAG_SEND_ZLP)) {
+         urb->transfer_buffer_length++;
+         if (skb_tailroom(skb)) {
+            skb->data[skb->len] = 0;
+            __skb_put(skb, 1);
+         }
+      } else
+         urb->transfer_flags |= URB_ZERO_PACKET;
+   }
+
+   spin_lock_irqsave(&dev->txq.lock, flags);
+   retval = gobi_usb_autopm_get_interface_async(dev->intf);
+   if (retval < 0) {
+      spin_unlock_irqrestore(&dev->txq.lock, flags);
+      goto drop;
+   }
+
+#ifdef CONFIG_PM
+   /* if this triggers the device is still a sleep */
+   if (test_bit(EVENT_DEV_ASLEEP, &dev->flags)) {
+      /* transmission will be done in resume */
+      usb_anchor_urb(urb, &dev->deferred);
+      /* no use to process more packets */
+      netif_stop_queue(net);
+      spin_unlock_irqrestore(&dev->txq.lock, flags);
+      netdev_dbg(dev->net, "Delaying transmission for resumption\n");
+      goto deferred;
+   }
+#endif
+
+#ifdef TX_URB_MONITOR
+   iRet = get_usb_interface(urb, &b_usb_if_num);
+#endif //#ifdef TX_URB_MONITOR  
+   switch ((retval = usb_submit_urb (urb, GFP_ATOMIC))) {
+   case -EPIPE:
+      netif_stop_queue (net);
+      usbnet_defer_kevent (dev, EVENT_TX_HALT);
+      gobi_usb_autopm_put_interface_async(dev->intf);
+      break;
+   default:
+      gobi_usb_autopm_put_interface_async(dev->intf);
+      netif_dbg(dev, tx_err, dev->net,
+           "tx: submit urb err %d\n", retval);
+      break;
+   case 0:
+      net->trans_start = jiffies;
+      __skb_queue_tail (&dev->txq, skb);
+      if (dev->txq.qlen >= TX_QLEN (dev))
+         netif_stop_queue (net);
+   }
+#ifdef TX_URB_MONITOR
+   /*
+    * Call URB_monitor() with true as the URB has been successfully 
+    * submitted to the txq. 
+    */
+   if ((URB_monitor) && (0==iRet) && (0==retval))
+   {
+       URB_monitor(true, b_usb_if_num);
+   }
+#endif //#ifdef TX_URB_MONITOR
+
+   spin_unlock_irqrestore (&dev->txq.lock, flags);
+
+   if (retval) {
+      netif_dbg(dev, tx_err, dev->net, "drop, code %d\n", retval);
+drop:
+      dev->net->stats.tx_dropped++;
+      if (skb)
+         dev_kfree_skb_any (skb);
+      usb_free_urb (urb);
+   } else
+      netif_dbg(dev, tx_queued, dev->net,
+           "> tx, len %d, type 0x%x\n", length, skb->protocol);
+#ifdef CONFIG_PM
+deferred:
+#endif
+   return NETDEV_TX_OK;
+}
+#endif /* #if (LINUX_VERSION_CODE == KERNEL_VERSION( 2,6,35 )) */
+
diff --git a/drivers/net/usb/usbnet_3_0_6.c b/drivers/net/usb/usbnet_3_0_6.c
new file mode 100644
index 00000000..1bad0aee
--- /dev/null
+++ b/drivers/net/usb/usbnet_3_0_6.c
@@ -0,0 +1,432 @@
+/*===========================================================================
+FILE:
+   usbnet_3_0_6.c
+
+DESCRIPTION:
+   The default "usbnet_start_xmit" function is over-ridden by Sierra to provide the URB_Monitor
+   for Linux kernel 3.0.6
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+
+#include "Structs.h"
+#include "QMIDevice.h"
+#include "QMI.h"
+#include "gobi_usbnet.h"
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/module.h>
+#include <net/ip.h>
+
+#include <asm/siginfo.h>   //siginfo
+#include <linux/rcupdate.h>   //rcu_read_lock
+#include <linux/sched.h>   //find_task_by_pid_type
+
+#if (LINUX_VERSION_CODE == KERNEL_VERSION( 3,0,6 ))
+void (*URB_monitor) (bool,unsigned char);
+EXPORT_SYMBOL(URB_monitor);
+#if 0
+/*
+ * Dummy function to test URB back-pressure. In actual implementation,
+ * customer will implement this function
+ */
+// Define PDN interfaced as per specific Sierra module PTS. The below are for MC73xx modules 
+#define PDN1_INTERFACE 8 
+#define PDN2_INTERFACE 10
+#define BACK_PRESSURE_WATERMARK 10
+static unsigned short urb_count_pdn1 = 0;
+static unsigned short urb_count_pdn2 = 0;
+void URB_monitor (bool isUpCount,unsigned char interface)
+{
+/*   printk(KERN_WARNING "[%s] isUpCount %d, intf %d", \
+         __func__, isUpCount, interface);*/
+   if (isUpCount)
+   {
+      if (interface == PDN1_INTERFACE)
+      {
+         urb_count_pdn1++;
+      }
+      else if (interface == PDN2_INTERFACE)
+      {
+         urb_count_pdn2++;
+      }
+      else
+      {
+         // unknown interface. ignore or log as needed
+      }
+   }
+   else
+   {
+      if (interface == PDN1_INTERFACE)
+      {
+         urb_count_pdn1--;
+      }
+      else if (interface == PDN2_INTERFACE)
+      {
+         urb_count_pdn2--;
+      }
+      else
+      {
+         // unknown interface. ignore or log as needed
+      }   
+   }
+   if (BACK_PRESSURE_WATERMARK <= urb_count_pdn1)
+   {
+      // Back pressure on PDN1
+      printk(KERN_WARNING "[%s] Backpressure %d on PDN1", \
+            __func__, urb_count_pdn1);
+   }   
+   if (BACK_PRESSURE_WATERMARK <= urb_count_pdn2)
+   {
+      // Back pressure on PDN2
+      printk(KERN_WARNING "[%s] Backpressure %d on PDN2", \
+            __func__, urb_count_pdn2);
+   }   
+}
+#endif // 0 End of dummy function
+
+// Get the USB interface from a usbnet pointer. The function return 0 on success, -1 on error
+__always_inline static int get_usb_interface_from_device (struct usbnet   *dev, unsigned char *pb_usb_interface)
+{
+    int iRet = -1; // set to error by default   
+   
+    if ((NULL!=dev) && (NULL!=pb_usb_interface))
+    {
+        if ((NULL != dev->intf) &&
+            (NULL != dev->intf->cur_altsetting))
+        {
+            *pb_usb_interface = dev->intf->cur_altsetting->desc.bInterfaceNumber;
+            iRet = 0;
+        } // (NULL != dev->intf) && (NULL != dev->intf->cur_altsetting)
+    } //(NULL != pURB) && (NULL!=pb_usb_interface)
+    return iRet;
+}
+
+// Get the USB interface from a URB. The function return 0 on success, -1 on error
+__always_inline static int get_usb_interface (struct urb * pURB, unsigned char *pb_usb_interface)
+{
+    int iRet = -1; // set to error by default   
+    struct sk_buff  *skb   = NULL;
+    struct skb_data   *entry = NULL;
+
+    if ((NULL!=pURB) && (NULL!=pb_usb_interface))
+    { 
+        skb = (struct sk_buff *) pURB->context;
+        if (NULL != skb)
+        {
+            entry = (struct skb_data *) skb->cb;
+            if (NULL != entry)
+            {
+                iRet = get_usb_interface_from_device (entry->dev, pb_usb_interface);
+            }
+        } // (NULL != skb)
+    } // (NULL != pURB) && (NULL!=pb_usb_interface)
+    return iRet;
+}
+
+// unlink pending rx/tx; completion handlers do all other cleanup
+static int unlink_urbs (struct usbnet *dev, struct sk_buff_head *q)
+{
+   unsigned long      flags;
+   struct sk_buff      *skb, *skbnext;
+   int         count = 0;
+
+   spin_lock_irqsave (&q->lock, flags);
+   skb_queue_walk_safe(q, skb, skbnext) {
+      struct skb_data      *entry;
+      struct urb      *urb;
+      int         retval;
+
+      entry = (struct skb_data *) skb->cb;
+      urb = entry->urb;
+
+      // during some PM-driven resume scenarios,
+      // these (async) unlinks complete immediately
+      retval = usb_unlink_urb (urb);
+      if (retval != -EINPROGRESS && retval != 0)
+        netdev_dbg(dev->net, "unlink urb err, %d\n", retval);
+      else
+         count++;
+   }
+   spin_unlock_irqrestore (&q->lock, flags);
+   return count;
+}
+
+void gobi_usbnet_tx_timeout_3_0_6 (struct net_device *net)
+{
+   struct usbnet      *dev = netdev_priv(net);
+#ifdef TX_URB_MONITOR
+   int count = 0;   
+   int iRet = -1;
+   unsigned char b_usb_if_num = 0;
+   // Get the USB interface
+   iRet = get_usb_interface_from_device (dev, &b_usb_if_num);   
+
+   count = unlink_urbs (dev, &dev->txq);
+   tasklet_schedule (&dev->bh);
+
+   if ((URB_monitor) && (0==iRet))
+   {
+       while (count)
+      {
+         URB_monitor(false, b_usb_if_num);
+         count--;
+      }
+   }
+#else // TX_URB_MONITOR
+   unlink_urbs (dev, &dev->txq);
+   tasklet_schedule (&dev->bh);
+#endif // TX_URB_MONITOR
+   // FIXME: device recovery -- reset?
+}
+
+/* some LK 2.4 HCDs oopsed if we freed or resubmitted urbs from
+ * completion callbacks.  2.5 should have fixed those bugs...
+ */
+
+static void defer_bh(struct usbnet *dev, struct sk_buff *skb, struct sk_buff_head *list)
+{
+   unsigned long      flags;
+
+   spin_lock_irqsave(&list->lock, flags);
+   __skb_unlink(skb, list);
+   spin_unlock(&list->lock);
+   spin_lock(&dev->done.lock);
+   __skb_queue_tail(&dev->done, skb);
+   if (dev->done.qlen == 1)
+      tasklet_schedule(&dev->bh);
+   spin_unlock_irqrestore(&dev->done.lock, flags);
+}
+
+static void tx_complete (struct urb *urb)
+{
+   struct sk_buff      *skb = (struct sk_buff *) urb->context;
+   struct skb_data      *entry = (struct skb_data *) skb->cb;
+   struct usbnet      *dev = entry->dev;
+
+#ifdef TX_URB_MONITOR
+   unsigned char b_usb_if_num = 0;
+    int iRet = get_usb_interface(urb, &b_usb_if_num);
+#endif //#ifdef TX_URB_MONITOR
+
+   if (urb->status == 0)
+   {
+      if (!(dev->driver_info->flags & FLAG_MULTI_PACKET))
+         dev->net->stats.tx_packets++;
+      dev->net->stats.tx_bytes += entry->length;
+   }
+   else
+   {
+      dev->net->stats.tx_errors++;
+      switch (urb->status)
+      {
+         case -EPIPE:
+            usbnet_defer_kevent (dev, EVENT_TX_HALT);
+            break;
+       
+         /* software-driven interface shutdown */
+         case -ECONNRESET:      // async unlink
+         case -ESHUTDOWN:      // hardware gone
+            break;
+       
+         // like rx, tx gets controller i/o faults during khubd delays
+         // and so it uses the same throttling mechanism.
+         case -EPROTO:
+         case -ETIME:
+         case -EILSEQ:
+            if (!timer_pending (&dev->delay)) {
+             mod_timer (&dev->delay,
+             jiffies + THROTTLE_JIFFIES);
+            if (netif_msg_link (dev))
+            #if (LINUX_VERSION_CODE != KERNEL_VERSION( 3,0,6 ))
+               devdbg (dev, "tx throttle %d",
+                            urb->status);
+            #else
+                     netif_dbg(dev, link, dev->net,
+                                   "tx throttle %d\n", urb->status);
+            #endif
+            }
+            netif_stop_queue (dev->net);
+            break;
+         default:
+            if (netif_msg_tx_err (dev))
+            #if (LINUX_VERSION_CODE != KERNEL_VERSION( 3,0,6 ))
+               devdbg (dev, "tx err %d", entry->urb->status);
+            #else
+               netif_dbg(dev, tx_err, dev->net,
+                           "tx err %d\n", entry->urb->status);
+            #endif
+            break;
+      }
+   }
+
+   gobi_usb_autopm_put_interface_async(dev->intf);
+   urb->dev = NULL;
+   entry->state = tx_done;
+   defer_bh(dev, skb, &dev->txq);
+
+#ifdef TX_URB_MONITOR
+   if ((URB_monitor) && (0==iRet))
+   {
+       URB_monitor(false, b_usb_if_num);
+   }
+#endif //#ifdef TX_URB_MONITOR
+
+}
+
+netdev_tx_t gobi_usbnet_start_xmit_3_0_6 (struct sk_buff *skb,
+                 struct net_device *net)
+{
+   struct usbnet      *dev = netdev_priv(net);
+   int         length;
+   struct urb      *urb = NULL;
+   struct skb_data      *entry;
+   struct driver_info   *info = dev->driver_info;
+   unsigned long      flags;
+   int retval;
+#ifdef TX_URB_MONITOR   
+   unsigned char b_usb_if_num = 0;
+   int iRet = -1;
+#endif //#ifdef TX_URB_MONITOR
+
+   // some devices want funky USB-level framing, for
+   // win32 driver (usually) and/or hardware quirks
+   if (info->tx_fixup) {
+      skb = info->tx_fixup (dev, skb, GFP_ATOMIC);
+      if (!skb) {
+         if (netif_msg_tx_err(dev)) {
+            netif_dbg(dev, tx_err, dev->net, "can't tx_fixup skb\n");
+            goto drop;
+         } else {
+            /* cdc_ncm collected packet; waits for more */
+            goto not_drop;
+         }
+      }
+   }
+   length = skb->len;
+
+   if (!(urb = usb_alloc_urb (0, GFP_ATOMIC))) {
+      netif_dbg(dev, tx_err, dev->net, "no urb\n");
+      goto drop;
+   }
+
+   entry = (struct skb_data *) skb->cb;
+   entry->urb = urb;
+   entry->dev = dev;
+   entry->state = tx_start;
+   entry->length = length;
+
+   usb_fill_bulk_urb (urb, dev->udev, dev->out,
+         skb->data, skb->len, tx_complete, skb);
+
+   /* don't assume the hardware handles USB_ZERO_PACKET
+    * NOTE:  strictly conforming cdc-ether devices should expect
+    * the ZLP here, but ignore the one-byte packet.
+    * NOTE2: CDC NCM specification is different from CDC ECM when
+    * handling ZLP/short packets, so cdc_ncm driver will make short
+    * packet itself if needed.
+    */
+   if (length % dev->maxpacket == 0) {
+      if (!(info->flags & FLAG_SEND_ZLP)) {
+         if (!(info->flags & FLAG_MULTI_PACKET)) {
+            urb->transfer_buffer_length++;
+            if (skb_tailroom(skb)) {
+               skb->data[skb->len] = 0;
+               __skb_put(skb, 1);
+            }
+         }
+      } else
+         urb->transfer_flags |= URB_ZERO_PACKET;
+   }
+
+   spin_lock_irqsave(&dev->txq.lock, flags);
+   retval = gobi_usb_autopm_get_interface_async(dev->intf);
+   if (retval < 0) {
+      spin_unlock_irqrestore(&dev->txq.lock, flags);
+      goto drop;
+   }
+
+#ifdef CONFIG_PM
+   /* if this triggers the device is still a sleep */
+   if (test_bit(EVENT_DEV_ASLEEP, &dev->flags)) {
+      /* transmission will be done in resume */
+      usb_anchor_urb(urb, &dev->deferred);
+      /* no use to process more packets */
+      netif_stop_queue(net);
+      spin_unlock_irqrestore(&dev->txq.lock, flags);
+      netdev_dbg(dev->net, "Delaying transmission for resumption\n");
+      goto deferred;
+   }
+#endif
+
+#ifdef TX_URB_MONITOR
+   iRet = get_usb_interface(urb, &b_usb_if_num);
+#endif //#ifdef TX_URB_MONITOR  
+
+   switch ((retval = usb_submit_urb (urb, GFP_ATOMIC))) {
+   case -EPIPE:
+      netif_stop_queue (net);
+      usbnet_defer_kevent (dev, EVENT_TX_HALT);
+      gobi_usb_autopm_put_interface_async(dev->intf);
+      break;
+   default:
+      gobi_usb_autopm_put_interface_async(dev->intf);
+      netif_dbg(dev, tx_err, dev->net,
+           "tx: submit urb err %d\n", retval);
+      break;
+   case 0:
+      net->trans_start = jiffies;
+      __skb_queue_tail (&dev->txq, skb);
+      if (dev->txq.qlen >= TX_QLEN (dev))
+         netif_stop_queue (net);
+   }
+#ifdef TX_URB_MONITOR
+   /*
+    * This can be called from here or from inside the
+    * case 0 in the above switch. There will be one less
+    * condition to check
+    */
+   /*
+    * Call URB_monitor() with true as the URB has been successfully 
+    * submitted to the txq. 
+    */
+   if ((URB_monitor) && (0==iRet) && (0==retval))
+   {
+       URB_monitor(true, b_usb_if_num);
+   }
+#endif //#ifdef TX_URB_MONITOR
+
+   spin_unlock_irqrestore (&dev->txq.lock, flags);
+
+   if (retval) {
+      netif_dbg(dev, tx_err, dev->net, "drop, code %d\n", retval);
+drop:
+      dev->net->stats.tx_dropped++;
+not_drop:
+      if (skb)
+         dev_kfree_skb_any (skb);
+      usb_free_urb (urb);
+   } else
+      netif_dbg(dev, tx_queued, dev->net,
+           "> tx, len %d, type 0x%x\n", length, skb->protocol);
+#ifdef CONFIG_PM
+deferred:
+#endif
+   return NETDEV_TX_OK;
+}
+#endif /* #if (LINUX_VERSION_CODE == KERNEL_VERSION( 3,0,6 )) */
+
diff --git a/drivers/net/usb/usbnet_3_10_21.c b/drivers/net/usb/usbnet_3_10_21.c
new file mode 100644
index 00000000..7f4e8b08
--- /dev/null
+++ b/drivers/net/usb/usbnet_3_10_21.c
@@ -0,0 +1,457 @@
+/*===========================================================================
+FILE:
+   usbnet_3_10_21.c
+
+DESCRIPTION:
+   The default "usbnet_start_xmit" function is over-ridden by Sierra to provide the URB_Monitor
+   for Linux kernel 3.10.1 to 3.10.39
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+
+#include "Structs.h"
+#include "QMIDevice.h"
+#include "QMI.h"
+#include "gobi_usbnet.h"
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/module.h>
+#include <net/ip.h>
+
+#include <asm/siginfo.h>   //siginfo
+#include <linux/rcupdate.h>   //rcu_read_lock
+#include <linux/sched.h>   //find_task_by_pid_type
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,10,1 ) &&\
+     LINUX_VERSION_CODE <= KERNEL_VERSION( 3,10,39))
+void (*URB_monitor) (bool,unsigned char);
+EXPORT_SYMBOL(URB_monitor);
+#if 0
+/*
+ * Dummy function to test URB back-pressure. In actual implementation,
+ * customer will implement this function
+ */
+// Define PDN interfaced as per specific Sierra module PTS. The below are for MC73xx modules 
+#define PDN1_INTERFACE 8 
+#define PDN2_INTERFACE 10
+#define BACK_PRESSURE_WATERMARK 10
+static unsigned short urb_count_pdn1 = 0;
+static unsigned short urb_count_pdn2 = 0;
+void URB_monitor (bool isUpCount,unsigned char interface)
+{
+/*   printk(KERN_WARNING "[%s] isUpCount %d, intf %d", \
+         __func__, isUpCount, interface);*/
+   if (isUpCount)
+   {
+      if (interface == PDN1_INTERFACE)
+      {
+         urb_count_pdn1++;
+      }
+      else if (interface == PDN2_INTERFACE)
+      {
+         urb_count_pdn2++;
+      }
+      else
+      {
+         // unknown interface. ignore or log as needed
+      }
+   }
+   else
+   {
+      if (interface == PDN1_INTERFACE)
+      {
+         urb_count_pdn1--;
+      }
+      else if (interface == PDN2_INTERFACE)
+      {
+         urb_count_pdn2--;
+      }
+      else
+      {
+         // unknown interface. ignore or log as needed
+      }   
+   }
+   if (BACK_PRESSURE_WATERMARK <= urb_count_pdn1)
+   {
+      // Back pressure on PDN1
+      printk(KERN_WARNING "[%s] Backpressure %d on PDN1", \
+            __func__, urb_count_pdn1);
+   }   
+   if (BACK_PRESSURE_WATERMARK <= urb_count_pdn2)
+   {
+      // Back pressure on PDN2
+      printk(KERN_WARNING "[%s] Backpressure %d on PDN2", \
+            __func__, urb_count_pdn2);
+   }   
+}
+#endif // 0 End of dummy function
+
+// Get the USB interface from a usbnet pointer. The function return 0 on success, -1 on error
+__always_inline static int get_usb_interface_from_device (struct usbnet   *dev, unsigned char *pb_usb_interface)
+{
+    int iRet = -1; // set to error by default   
+   
+    if ((NULL!=dev) && (NULL!=pb_usb_interface))
+    {
+        if ((NULL != dev->intf) &&
+            (NULL != dev->intf->cur_altsetting))
+        {
+            *pb_usb_interface = dev->intf->cur_altsetting->desc.bInterfaceNumber;
+            iRet = 0;
+        } // (NULL != dev->intf) && (NULL != dev->intf->cur_altsetting)
+    } //(NULL != pURB) && (NULL!=pb_usb_interface)
+    return iRet;
+}
+
+// Get the USB interface from a URB. The function return 0 on success, -1 on error
+__always_inline static int get_usb_interface (struct urb * pURB, unsigned char *pb_usb_interface)
+{
+    int iRet = -1; // set to error by default   
+    struct sk_buff  *skb   = NULL;
+    struct skb_data   *entry = NULL;
+
+    if ((NULL!=pURB) && (NULL!=pb_usb_interface))
+    { 
+        skb = (struct sk_buff *) pURB->context;
+        if (NULL != skb)
+        {
+            entry = (struct skb_data *) skb->cb;
+            if (NULL != entry)
+            {
+                iRet = get_usb_interface_from_device (entry->dev, pb_usb_interface);
+            }
+        } // (NULL != skb)
+    } // (NULL != pURB) && (NULL!=pb_usb_interface)
+    return iRet;
+}
+
+// unlink pending rx/tx; completion handlers do all other cleanup
+
+static int unlink_urbs (struct usbnet *dev, struct sk_buff_head *q)
+{
+   unsigned long      flags;
+   struct sk_buff      *skb;
+   int         count = 0;
+
+   spin_lock_irqsave (&q->lock, flags);
+   while (!skb_queue_empty(q)) {
+      struct skb_data      *entry;
+      struct urb      *urb;
+      int         retval;
+
+      skb_queue_walk(q, skb) {
+         entry = (struct skb_data *) skb->cb;
+         if (entry->state != unlink_start)
+            goto found;
+      }
+      break;
+found:
+      entry->state = unlink_start;
+      urb = entry->urb;
+
+      /*
+       * Get reference count of the URB to avoid it to be
+       * freed during usb_unlink_urb, which may trigger
+       * use-after-free problem inside usb_unlink_urb since
+       * usb_unlink_urb is always racing with .complete
+       * handler(include defer_bh).
+       */
+      usb_get_urb(urb);
+      spin_unlock_irqrestore(&q->lock, flags);
+      // during some PM-driven resume scenarios,
+      // these (async) unlinks complete immediately
+      retval = usb_unlink_urb (urb);
+      if (retval != -EINPROGRESS && retval != 0)
+         netdev_dbg(dev->net, "unlink urb err, %d\n", retval);
+      else
+         count++;
+      usb_put_urb(urb);
+      spin_lock_irqsave(&q->lock, flags);
+   }
+   spin_unlock_irqrestore (&q->lock, flags);
+   return count;
+}
+
+
+void gobi_usbnet_tx_timeout_3_10_21 (struct net_device *net)
+{
+   struct usbnet      *dev = netdev_priv(net);
+#ifdef TX_URB_MONITOR
+   int count = 0;   
+   int iRet = -1;
+   unsigned char b_usb_if_num = 0;
+   // Get the USB interface
+   iRet = get_usb_interface_from_device (dev, &b_usb_if_num);   
+
+   count = unlink_urbs (dev, &dev->txq);
+   tasklet_schedule (&dev->bh);
+
+   if ((URB_monitor) && (0==iRet))
+   {
+       while (count)
+      {
+         URB_monitor(false, b_usb_if_num);
+         count--;
+      }
+   }
+#else // TX_URB_MONITOR
+   unlink_urbs (dev, &dev->txq);
+   tasklet_schedule (&dev->bh);
+#endif // TX_URB_MONITOR
+   // FIXME: device recovery -- reset?
+}
+
+/* some LK 2.4 HCDs oopsed if we freed or resubmitted urbs from
+ * completion callbacks.  2.5 should have fixed those bugs...
+ */
+
+static enum skb_state defer_bh(struct usbnet *dev, struct sk_buff *skb,
+      struct sk_buff_head *list, enum skb_state state)
+{
+   unsigned long      flags;
+   enum skb_state       old_state;
+   struct skb_data *entry = (struct skb_data *) skb->cb;
+
+   spin_lock_irqsave(&list->lock, flags);
+   old_state = entry->state;
+   entry->state = state;
+   __skb_unlink(skb, list);
+   spin_unlock(&list->lock);
+   spin_lock(&dev->done.lock);
+   __skb_queue_tail(&dev->done, skb);
+   if (dev->done.qlen == 1)
+      tasklet_schedule(&dev->bh);
+   spin_unlock_irqrestore(&dev->done.lock, flags);
+   return old_state;
+}
+
+static void tx_complete (struct urb *urb)
+{
+   struct sk_buff      *skb = (struct sk_buff *) urb->context;
+   struct skb_data      *entry = (struct skb_data *) skb->cb;
+   struct usbnet      *dev = entry->dev;
+
+#ifdef TX_URB_MONITOR
+   unsigned char b_usb_if_num = 0;
+    int iRet = get_usb_interface(urb, &b_usb_if_num);
+#endif //#ifdef TX_URB_MONITOR
+
+   if (urb->status == 0) {
+      if (!(dev->driver_info->flags & FLAG_MULTI_PACKET))
+         dev->net->stats.tx_packets++;
+      dev->net->stats.tx_bytes += entry->length;
+   } else {
+      dev->net->stats.tx_errors++;
+
+      switch (urb->status) {
+      case -EPIPE:
+         usbnet_defer_kevent (dev, EVENT_TX_HALT);
+         break;
+
+      /* software-driven interface shutdown */
+      case -ECONNRESET:      // async unlink
+      case -ESHUTDOWN:      // hardware gone
+         break;
+
+      // like rx, tx gets controller i/o faults during khubd delays
+      // and so it uses the same throttling mechanism.
+      case -EPROTO:
+      case -ETIME:
+      case -EILSEQ:
+         usb_mark_last_busy(dev->udev);
+         if (!timer_pending (&dev->delay)) {
+            mod_timer (&dev->delay,
+               jiffies + THROTTLE_JIFFIES);
+            netif_dbg(dev, link, dev->net,
+                 "tx throttle %d\n", urb->status);
+         }
+         netif_stop_queue (dev->net);
+         break;
+      default:
+         netif_dbg(dev, tx_err, dev->net,
+              "tx err %d\n", entry->urb->status);
+         break;
+      }
+   }
+
+   gobi_usb_autopm_put_interface_async(dev->intf);
+   (void) defer_bh(dev, skb, &dev->txq, tx_done);
+
+#ifdef TX_URB_MONITOR
+   if ((URB_monitor) && (0==iRet))
+   {
+       URB_monitor(false, b_usb_if_num);
+   }
+#endif //#ifdef TX_URB_MONITOR
+
+}
+
+/* The caller must hold list->lock */ 
+static void __usbnet_queue_skb(struct sk_buff_head *list,
+                                struct sk_buff *newsk, enum skb_state state)
+{
+    struct skb_data *entry = (struct skb_data *) newsk->cb;
+
+    __skb_queue_tail(list, newsk);
+    entry->state = state;
+}
+
+netdev_tx_t gobi_usbnet_start_xmit_3_10_21 (struct sk_buff *skb,
+                 struct net_device *net)
+{
+   struct usbnet      *dev = netdev_priv(net);
+   int         length;
+   struct urb      *urb = NULL;
+   struct skb_data      *entry;
+   struct driver_info   *info = dev->driver_info;
+   unsigned long      flags;
+   int retval;
+#ifdef TX_URB_MONITOR   
+   unsigned char b_usb_if_num = 0;
+   int iRet = -1;
+#endif //#ifdef TX_URB_MONITOR
+
+   if (skb)
+      skb_tx_timestamp(skb);
+
+   // some devices want funky USB-level framing, for
+   // win32 driver (usually) and/or hardware quirks
+   if (info->tx_fixup) {
+      skb = info->tx_fixup (dev, skb, GFP_ATOMIC);
+      if (!skb) {
+         /* packet collected; minidriver waiting for more */
+         if (info->flags & FLAG_MULTI_PACKET)
+            goto not_drop;
+         netif_dbg(dev, tx_err, dev->net, "can't tx_fixup skb\n");
+         goto drop;
+      }
+   }
+   length = skb->len;
+
+   if (!(urb = usb_alloc_urb (0, GFP_ATOMIC))) {
+      netif_dbg(dev, tx_err, dev->net, "no urb\n");
+      goto drop;
+   }
+
+   entry = (struct skb_data *) skb->cb;
+   entry->urb = urb;
+   entry->dev = dev;
+   entry->length = length;
+
+   usb_fill_bulk_urb (urb, dev->udev, dev->out,
+         skb->data, skb->len, tx_complete, skb);
+
+   /* don't assume the hardware handles USB_ZERO_PACKET
+    * NOTE:  strictly conforming cdc-ether devices should expect
+    * the ZLP here, but ignore the one-byte packet.
+    * NOTE2: CDC NCM specification is different from CDC ECM when
+    * handling ZLP/short packets, so cdc_ncm driver will make short
+    * packet itself if needed.
+    */
+   if (length % dev->maxpacket == 0) {
+      if (!(info->flags & FLAG_SEND_ZLP)) {
+         if (!(info->flags & FLAG_MULTI_PACKET)) {
+            urb->transfer_buffer_length++;
+            if (skb_tailroom(skb)) {
+               skb->data[skb->len] = 0;
+               __skb_put(skb, 1);
+            }
+         }
+      } else
+         urb->transfer_flags |= URB_ZERO_PACKET;
+   }
+
+   spin_lock_irqsave(&dev->txq.lock, flags);
+   retval = gobi_usb_autopm_get_interface_async(dev->intf);
+   if (retval < 0) {
+      spin_unlock_irqrestore(&dev->txq.lock, flags);
+      goto drop;
+   }
+
+#ifdef CONFIG_PM
+   /* if this triggers the device is still a sleep */
+   if (test_bit(EVENT_DEV_ASLEEP, &dev->flags)) {
+      /* transmission will be done in resume */
+      usb_anchor_urb(urb, &dev->deferred);
+      /* no use to process more packets */
+      netif_stop_queue(net);
+      usb_put_urb(urb);
+      spin_unlock_irqrestore(&dev->txq.lock, flags);
+      netdev_dbg(dev->net, "Delaying transmission for resumption\n");
+      goto deferred;
+   }
+#endif
+
+#ifdef TX_URB_MONITOR
+   iRet = get_usb_interface(urb, &b_usb_if_num);
+#endif //#ifdef TX_URB_MONITOR  
+
+   switch ((retval = usb_submit_urb (urb, GFP_ATOMIC))) {
+   case -EPIPE:
+      netif_stop_queue (net);
+      usbnet_defer_kevent (dev, EVENT_TX_HALT);
+      gobi_usb_autopm_put_interface_async(dev->intf);
+      break;
+   default:
+      gobi_usb_autopm_put_interface_async(dev->intf);
+      netif_dbg(dev, tx_err, dev->net,
+           "tx: submit urb err %d\n", retval);
+      break;
+   case 0:
+      net->trans_start = jiffies;
+      __usbnet_queue_skb(&dev->txq, skb, tx_start);
+      if (dev->txq.qlen >= TX_QLEN (dev))
+         netif_stop_queue (net);
+   }
+
+#ifdef TX_URB_MONITOR
+   /*
+    * This can be called from here or from inside the
+    * case 0 in the above switch. There will be one less
+    * condition to check
+    */
+   /*
+    * Call URB_monitor() with true as the URB has been successfully 
+    * submitted to the txq. 
+    */
+   if ((URB_monitor) && (0==iRet) && (0==retval))
+   {
+       URB_monitor(true, b_usb_if_num);
+   }
+#endif //#ifdef TX_URB_MONITOR
+
+   spin_unlock_irqrestore (&dev->txq.lock, flags);
+
+   if (retval) {
+      netif_dbg(dev, tx_err, dev->net, "drop, code %d\n", retval);
+drop:
+      dev->net->stats.tx_dropped++;
+not_drop:
+      if (skb)
+         dev_kfree_skb_any (skb);
+      usb_free_urb (urb);
+   } else
+      netif_dbg(dev, tx_queued, dev->net,
+           "> tx, len %d, type 0x%x\n", length, skb->protocol);
+#ifdef CONFIG_PM
+deferred:
+#endif
+   return NETDEV_TX_OK;
+}
+#endif /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,10,1 ) &&\
+               LINUX_VERSION_CODE <= KERNEL_VERSION( 3,10,39))*/
+
diff --git a/drivers/net/usb/usbnet_3_12_xx.c b/drivers/net/usb/usbnet_3_12_xx.c
new file mode 100644
index 00000000..b775b9d6
--- /dev/null
+++ b/drivers/net/usb/usbnet_3_12_xx.c
@@ -0,0 +1,513 @@
+/*===========================================================================
+FILE:
+   usbnet_3_12_xx.c
+
+DESCRIPTION:
+   The default "usbnet_start_xmit" function is over-ridden by Sierra to provide the URB_Monitor
+   for Linux kernel 3.12.0 to 3.12.xx
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+
+#include "Structs.h"
+#include "QMIDevice.h"
+#include "QMI.h"
+#include "gobi_usbnet.h"
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/module.h>
+#include <net/ip.h>
+
+#include <asm/siginfo.h>   //siginfo
+#include <linux/rcupdate.h>   //rcu_read_lock
+#include <linux/sched.h>   //find_task_by_pid_type
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,12,0 ) &&\
+     LINUX_VERSION_CODE < KERNEL_VERSION( 3,13,00))
+#if 1
+void (*URB_monitor) (bool,unsigned char);
+EXPORT_SYMBOL(URB_monitor);
+#else
+/*
+ * Dummy function to test URB back-pressure. In actual implementation,
+ * customer will implement this function
+ */
+// Define PDN interfaced as per specific Sierra module PTS. The below are for MC73xx modules 
+#define PDN1_INTERFACE 8 
+#define PDN2_INTERFACE 10
+#define BACK_PRESSURE_WATERMARK 1//10
+static unsigned short urb_count_pdn1 = 0;
+static unsigned short urb_count_pdn2 = 0;
+void URB_monitor (bool isUpCount,unsigned char interface)
+{
+/*   printk(KERN_WARNING "[%s] isUpCount %d, intf %d", \
+         __func__, isUpCount, interface);*/
+   if (isUpCount)
+   {
+      if (interface == PDN1_INTERFACE)
+      {
+         urb_count_pdn1++;
+      }
+      else if (interface == PDN2_INTERFACE)
+      {
+         urb_count_pdn2++;
+      }
+      else
+      {
+         // unknown interface. ignore or log as needed
+      }
+   }
+   else
+   {
+      if (interface == PDN1_INTERFACE)
+      {
+         urb_count_pdn1--;
+      }
+      else if (interface == PDN2_INTERFACE)
+      {
+         urb_count_pdn2--;
+      }
+      else
+      {
+         // unknown interface. ignore or log as needed
+      }   
+   }
+   if (BACK_PRESSURE_WATERMARK <= urb_count_pdn1)
+   {
+      // Back pressure on PDN1
+      printk(KERN_WARNING "[%s] Backpressure %d on PDN1", \
+            __func__, urb_count_pdn1);
+   }   
+   if (BACK_PRESSURE_WATERMARK <= urb_count_pdn2)
+   {
+      // Back pressure on PDN2
+      printk(KERN_WARNING "[%s] Backpressure %d on PDN2", \
+            __func__, urb_count_pdn2);
+   }
+}
+
+
+#endif // 0 End of dummy function
+
+// Get the USB interface from a usbnet pointer. The function return 0 on success, -1 on error
+__always_inline static int get_usb_interface_from_device (struct usbnet   *dev, unsigned char *pb_usb_interface)
+{
+   int iRet = -1; // set to error by default   
+
+   if ((NULL!=dev) && (NULL!=pb_usb_interface))
+   {
+      if ((NULL != dev->intf) &&
+         (NULL != dev->intf->cur_altsetting))
+      {
+         *pb_usb_interface = dev->intf->cur_altsetting->desc.bInterfaceNumber;
+         iRet = 0;
+      } // (NULL != dev->intf) && (NULL != dev->intf->cur_altsetting)
+   } //(NULL != pURB) && (NULL!=pb_usb_interface)
+   return iRet;
+}
+
+// Get the USB interface from a URB. The function return 0 on success, -1 on error
+__always_inline static int get_usb_interface (struct urb * pURB, unsigned char *pb_usb_interface)
+{
+   int iRet = -1; // set to error by default   
+   struct sk_buff  *skb   = NULL;
+   struct skb_data   *entry = NULL;
+
+   if ((NULL!=pURB) && (NULL!=pb_usb_interface))
+   { 
+      skb = (struct sk_buff *) pURB->context;
+      if (NULL != skb)
+      {
+         entry = (struct skb_data *) skb->cb;
+         if (NULL != entry)
+         {
+            iRet = get_usb_interface_from_device (entry->dev, pb_usb_interface);
+         }
+      } // (NULL != skb)
+   } // (NULL != pURB) && (NULL!=pb_usb_interface)
+   return iRet;
+}
+
+// unlink pending rx/tx; completion handlers do all other cleanup
+
+static int unlink_urbs (struct usbnet *dev, struct sk_buff_head *q)
+{
+   unsigned long      flags;
+   struct sk_buff      *skb;
+   int         count = 0;
+
+   spin_lock_irqsave (&q->lock, flags);
+   while (!skb_queue_empty(q)) {
+      struct skb_data      *entry;
+      struct urb      *urb;
+      int         retval;
+
+      skb_queue_walk(q, skb) {
+         entry = (struct skb_data *) skb->cb;
+         if (entry->state != unlink_start)
+            goto found;
+      }
+      break;
+found:
+      entry->state = unlink_start;
+      urb = entry->urb;
+
+      /*
+       * Get reference count of the URB to avoid it to be
+       * freed during usb_unlink_urb, which may trigger
+       * use-after-free problem inside usb_unlink_urb since
+       * usb_unlink_urb is always racing with .complete
+       * handler(include defer_bh).
+       */
+      usb_get_urb(urb);
+      spin_unlock_irqrestore(&q->lock, flags);
+      // during some PM-driven resume scenarios,
+      // these (async) unlinks complete immediately
+      retval = usb_unlink_urb (urb);
+      if (retval != -EINPROGRESS && retval != 0)
+         netdev_dbg(dev->net, "unlink urb err, %d\n", retval);
+      else
+         count++;
+      usb_put_urb(urb);
+      spin_lock_irqsave(&q->lock, flags);
+   }
+   spin_unlock_irqrestore (&q->lock, flags);
+   return count;
+}
+
+
+void gobi_usbnet_tx_timeout_3_12_xx (struct net_device *net)
+{
+   struct usbnet      *dev = netdev_priv(net);
+#ifdef TX_URB_MONITOR
+   int count = 0;   
+   int iRet = -1;
+   unsigned char b_usb_if_num = 0;
+   // Get the USB interface
+   iRet = get_usb_interface_from_device (dev, &b_usb_if_num);   
+
+   count = unlink_urbs (dev, &dev->txq);
+   tasklet_schedule (&dev->bh);
+
+   if ((URB_monitor) && (0==iRet))
+   {
+       while (count)
+      {
+         URB_monitor(false, b_usb_if_num);
+         count--;
+      }
+   }
+#else // TX_URB_MONITOR
+   unlink_urbs (dev, &dev->txq);
+   tasklet_schedule (&dev->bh);
+#endif // TX_URB_MONITOR
+   // FIXME: device recovery -- reset?
+}
+
+/* some LK 2.4 HCDs oopsed if we freed or resubmitted urbs from
+ * completion callbacks.  2.5 should have fixed those bugs...
+ */
+
+static enum skb_state defer_bh(struct usbnet *dev, struct sk_buff *skb,
+      struct sk_buff_head *list, enum skb_state state)
+{
+   unsigned long      flags;
+   enum skb_state       old_state;
+   struct skb_data *entry = (struct skb_data *) skb->cb;
+
+   spin_lock_irqsave(&list->lock, flags);
+   old_state = entry->state;
+   entry->state = state;
+   __skb_unlink(skb, list);
+   spin_unlock(&list->lock);
+   spin_lock(&dev->done.lock);
+   __skb_queue_tail(&dev->done, skb);
+   if (dev->done.qlen == 1)
+      tasklet_schedule(&dev->bh);
+   spin_unlock_irqrestore(&dev->done.lock, flags);
+   return old_state;
+}
+
+static void tx_complete (struct urb *urb)
+{
+   struct sk_buff      *skb = (struct sk_buff *) urb->context;
+   struct skb_data      *entry = (struct skb_data *) skb->cb;
+   struct usbnet      *dev = entry->dev;
+
+#ifdef TX_URB_MONITOR
+   unsigned char b_usb_if_num = 0;
+    int iRet = get_usb_interface(urb, &b_usb_if_num);
+#endif //#ifdef TX_URB_MONITOR
+
+   if (urb->status == 0) {
+      if (!(dev->driver_info->flags & FLAG_MULTI_PACKET))
+         dev->net->stats.tx_packets++;
+      dev->net->stats.tx_bytes += entry->length;
+   } else {
+      dev->net->stats.tx_errors++;
+
+      switch (urb->status) {
+      case -EPIPE:
+         usbnet_defer_kevent (dev, EVENT_TX_HALT);
+         break;
+
+      /* software-driven interface shutdown */
+      case -ECONNRESET:      // async unlink
+      case -ESHUTDOWN:      // hardware gone
+         break;
+
+      // like rx, tx gets controller i/o faults during khubd delays
+      // and so it uses the same throttling mechanism.
+      case -EPROTO:
+      case -ETIME:
+      case -EILSEQ:
+         usb_mark_last_busy(dev->udev);
+         if (!timer_pending (&dev->delay)) {
+            mod_timer (&dev->delay,
+               jiffies + THROTTLE_JIFFIES);
+            netif_dbg(dev, link, dev->net,
+                 "tx throttle %d\n", urb->status);
+         }
+         netif_stop_queue (dev->net);
+         break;
+      default:
+         netif_dbg(dev, tx_err, dev->net,
+              "tx err %d\n", entry->urb->status);
+         break;
+      }
+   }
+
+   gobi_usb_autopm_put_interface_async(dev->intf);
+   (void) defer_bh(dev, skb, &dev->txq, tx_done);
+
+#ifdef TX_URB_MONITOR
+   if ((URB_monitor) && (0==iRet))
+   {
+      URB_monitor(false, b_usb_if_num);
+   }
+#endif //#ifdef TX_URB_MONITOR
+
+}
+
+static int build_dma_sg(const struct sk_buff *skb, struct urb *urb)
+{
+   unsigned num_sgs, total_len = 0;
+   int i, s = 0;
+
+   num_sgs = skb_shinfo(skb)->nr_frags + 1;
+   if (num_sgs == 1)
+      return 0;
+
+   /* reserve one for zero packet */
+   urb->sg = kmalloc((num_sgs + 1) * sizeof(struct scatterlist),
+                    GFP_ATOMIC);
+   if (!urb->sg)
+      return -ENOMEM;
+
+   urb->num_sgs = num_sgs;
+   sg_init_table(urb->sg, urb->num_sgs);
+
+   sg_set_buf(&urb->sg[s++], skb->data, skb_headlen(skb));
+   total_len += skb_headlen(skb);
+
+   for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+      struct skb_frag_struct *f = &skb_shinfo(skb)->frags[i];
+
+      total_len += skb_frag_size(f);
+      sg_set_page(&urb->sg[i + s], f->page.p, f->size,
+                    f->page_offset);
+   }
+   urb->transfer_buffer_length = total_len;
+
+   return 1;
+}
+
+
+/* The caller must hold list->lock */ 
+static void __usbnet_queue_skb(struct sk_buff_head *list,
+                                struct sk_buff *newsk, enum skb_state state)
+{
+   struct skb_data *entry = (struct skb_data *) newsk->cb;
+
+   __skb_queue_tail(list, newsk);
+   entry->state = state;
+}
+
+netdev_tx_t gobi_usbnet_start_xmit_3_12_xx (struct sk_buff *skb,
+                 struct net_device *net)
+{
+   struct usbnet           *dev = netdev_priv(net);
+   int                     length;
+   struct urb              *urb = NULL;
+   struct skb_data         *entry;
+   struct driver_info      *info = dev->driver_info;
+   unsigned long           flags;
+   int retval;
+#ifdef TX_URB_MONITOR
+unsigned char        b_usb_if_num = 0;
+int iRet = -1;
+#endif //#ifdef TX_URB_MONITOR
+
+   if (skb)
+      skb_tx_timestamp(skb);
+
+   // some devices want funky USB-level framing, for
+   // win32 driver (usually) and/or hardware quirks
+   if (info->tx_fixup) {
+         skb = info->tx_fixup (dev, skb, GFP_ATOMIC);
+         if (!skb) {
+                 /* packet collected; minidriver waiting for more */
+                 if (info->flags & FLAG_MULTI_PACKET)
+                         goto not_drop;
+                 netif_dbg(dev, tx_err, dev->net, "can't tx_fixup skb\n");
+                 goto drop;
+         }
+   }
+
+   if (!(urb = usb_alloc_urb (0, GFP_ATOMIC))) {
+         netif_dbg(dev, tx_err, dev->net, "no urb\n");
+         goto drop;
+   }
+
+   entry = (struct skb_data *) skb->cb;
+   entry->urb = urb;
+   entry->dev = dev;
+
+   usb_fill_bulk_urb (urb, dev->udev, dev->out,
+                 skb->data, skb->len, tx_complete, skb);
+
+   if (dev->can_dma_sg) {
+         if (build_dma_sg(skb, urb) < 0)
+                 goto drop;
+   }
+   length = urb->transfer_buffer_length;
+
+   /* don't assume the hardware handles USB_ZERO_PACKET
+     * NOTE:  strictly conforming cdc-ether devices should expect
+     * the ZLP here, but ignore the one-byte packet.
+     * NOTE2: CDC NCM specification is different from CDC ECM when
+     * handling ZLP/short packets, so cdc_ncm driver will make short
+     * packet itself if needed.
+     */
+   if (length % dev->maxpacket == 0) {
+         if (!(info->flags & FLAG_SEND_ZLP)) {
+                 if (!(info->flags & FLAG_MULTI_PACKET)) {
+                         length++;
+                         if (skb_tailroom(skb) && !urb->num_sgs) {
+                                 skb->data[skb->len] = 0;
+                                 __skb_put(skb, 1);
+                         } else if (urb->num_sgs)
+                                 sg_set_buf(&urb->sg[urb->num_sgs++],
+                                                 dev->padding_pkt, 1);
+                 }
+         } else
+                 urb->transfer_flags |= URB_ZERO_PACKET;
+   }
+   entry->length = urb->transfer_buffer_length = length;
+
+   spin_lock_irqsave(&dev->txq.lock, flags);
+   retval = gobi_usb_autopm_get_interface_async(dev->intf);
+   if (retval < 0) {
+         spin_unlock_irqrestore(&dev->txq.lock, flags);
+         goto drop;
+   }
+
+#ifdef CONFIG_PM
+   /* if this triggers the device is still a sleep */
+   if (test_bit(EVENT_DEV_ASLEEP, &dev->flags)) 
+   {
+      /* transmission will be done in resume */
+      usb_anchor_urb(urb, &dev->deferred);
+      /* no use to process more packets */
+      netif_stop_queue(net);
+      usb_put_urb(urb);
+      spin_unlock_irqrestore(&dev->txq.lock, flags);
+      netdev_dbg(dev->net, "Delaying transmission for resumption\n");
+      goto deferred;
+   }
+#endif
+   #ifdef TX_URB_MONITOR
+   iRet = get_usb_interface(urb, &b_usb_if_num);
+   #endif //#ifdef TX_URB_MONITOR
+   switch ((retval = usb_submit_urb (urb, GFP_ATOMIC))) 
+   {
+   case -EPIPE:
+         netif_stop_queue (net);
+         usbnet_defer_kevent (dev, EVENT_TX_HALT);
+         gobi_usb_autopm_put_interface_async(dev->intf);
+         break;
+   default:
+         gobi_usb_autopm_put_interface_async(dev->intf);
+         netif_dbg(dev, tx_err, dev->net,
+                   "tx: submit urb err %d\n", retval);
+         break;
+   case 0:
+         net->trans_start = jiffies;
+         __usbnet_queue_skb(&dev->txq, skb, tx_start);
+         if (dev->txq.qlen >= TX_QLEN (dev))
+                 netif_stop_queue (net);
+   }
+
+#ifdef TX_URB_MONITOR
+/*
+ * This can be called from here or from inside the
+ * case 0 in the above switch. There will be one less
+ * condition to check
+ */
+/*
+ * Call URB_monitor() with true as the URB has been successfully 
+ * submitted to the txq. 
+ */
+if ((0==iRet) && (0==retval))//(URB_monitor) && 
+{
+   URB_monitor(true, b_usb_if_num);
+}
+#endif //#ifdef TX_URB_MONITOR
+
+   spin_unlock_irqrestore (&dev->txq.lock, flags);
+
+   if (retval) {
+      netif_dbg(dev, tx_err, dev->net, "drop, code %d\n", retval);
+drop:
+   dev->net->stats.tx_dropped++;
+not_drop:
+   if (skb)
+      dev_kfree_skb_any (skb);
+      if (urb) 
+      {
+         kfree(urb->sg);
+         usb_free_urb(urb);
+      }
+   } else
+      netif_dbg(dev, tx_queued, dev->net,
+      "> tx, len %d, type 0x%x\n", length, skb->protocol);
+#ifdef CONFIG_PM
+deferred:
+#endif
+   return NETDEV_TX_OK;
+}
+
+#endif 
+/********* 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 3,12,0 ) &&\
+               LINUX_VERSION_CODE < KERNEL_VERSION( 3,13,00))
+               
+***********/
+
+
+
+
diff --git a/drivers/net/usb/usbnet_4_4_xx.c b/drivers/net/usb/usbnet_4_4_xx.c
new file mode 100644
index 00000000..bb09e34f
--- /dev/null
+++ b/drivers/net/usb/usbnet_4_4_xx.c
@@ -0,0 +1,514 @@
+/*===========================================================================
+FILE:
+   usbnet_4_4_xx.c
+
+DESCRIPTION:
+   The default "usbnet_start_xmit" function is over-ridden by Sierra to provide the URB_Monitor
+   for Linux kernel 4.4.0 to 4.4.xx
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+===========================================================================*/
+
+#include <linux/version.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 4,4,0 ) &&\
+     LINUX_VERSION_CODE < KERNEL_VERSION( 4,5,0))
+
+//---------------------------------------------------------------------------
+// Include Files
+//---------------------------------------------------------------------------
+
+#include "Structs.h"
+#include "QMIDevice.h"
+#include "QMI.h"
+#include "gobi_usbnet.h"
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/module.h>
+#include <net/ip.h>
+
+#include <asm/siginfo.h>   //siginfo
+#include <linux/rcupdate.h>   //rcu_read_lock
+#include <linux/sched.h>   //find_task_by_pid_type
+#if 1 
+void (*URB_monitor) (bool,unsigned char);
+EXPORT_SYMBOL(URB_monitor);
+#else
+/*
+ * Dummy function to test URB back-pressure. In actual implementation,
+ * customer will implement this function
+ */
+// Define PDN interfaced as per specific Sierra module PTS. The below are for MC73xx modules 
+#define PDN1_INTERFACE 8 
+#define PDN2_INTERFACE 10
+#define BACK_PRESSURE_WATERMARK 1//10
+static unsigned short urb_count_pdn1 = 0;
+static unsigned short urb_count_pdn2 = 0;
+void URB_monitor (bool isUpCount,unsigned char interface)
+{
+/*   printk(KERN_WARNING "[%s] isUpCount %d, intf %d", \
+         __func__, isUpCount, interface);*/
+   if (isUpCount)
+   {
+      if (interface == PDN1_INTERFACE)
+      {
+         urb_count_pdn1++;
+      }
+      else if (interface == PDN2_INTERFACE)
+      {
+         urb_count_pdn2++;
+      }
+      else
+      {
+         // unknown interface. ignore or log as needed
+      }
+   }
+   else
+   {
+      if (interface == PDN1_INTERFACE)
+      {
+         urb_count_pdn1--;
+      }
+      else if (interface == PDN2_INTERFACE)
+      {
+         urb_count_pdn2--;
+      }
+      else
+      {
+         // unknown interface. ignore or log as needed
+      }   
+   }
+   if (BACK_PRESSURE_WATERMARK <= urb_count_pdn1)
+   {
+      // Back pressure on PDN1
+      printk(KERN_WARNING "[%s] Backpressure %d on PDN1", \
+            __func__, urb_count_pdn1);
+   }   
+   if (BACK_PRESSURE_WATERMARK <= urb_count_pdn2)
+   {
+      // Back pressure on PDN2
+      printk(KERN_WARNING "[%s] Backpressure %d on PDN2", \
+            __func__, urb_count_pdn2);
+   }
+}
+
+
+#endif // 0 End of dummy function
+
+// Get the USB interface from a usbnet pointer. The function return 0 on success, -1 on error
+__always_inline static int get_usb_interface_from_device (struct usbnet   *dev, unsigned char *pb_usb_interface)
+{
+   int iRet = -1; // set to error by default   
+
+   if ((NULL!=dev) && (NULL!=pb_usb_interface))
+   {
+      if ((NULL != dev->intf) &&
+         (NULL != dev->intf->cur_altsetting))
+      {
+         *pb_usb_interface = dev->intf->cur_altsetting->desc.bInterfaceNumber;
+         iRet = 0;
+      } // (NULL != dev->intf) && (NULL != dev->intf->cur_altsetting)
+   } //(NULL != pURB) && (NULL!=pb_usb_interface)
+   return iRet;
+}
+
+// Get the USB interface from a URB. The function return 0 on success, -1 on error
+__always_inline static int get_usb_interface (struct urb * pURB, unsigned char *pb_usb_interface)
+{
+   int iRet = -1; // set to error by default   
+   struct sk_buff  *skb   = NULL;
+   struct skb_data   *entry = NULL;
+
+   if ((NULL!=pURB) && (NULL!=pb_usb_interface))
+   { 
+      skb = (struct sk_buff *) pURB->context;
+      if (NULL != skb)
+      {
+         entry = (struct skb_data *) skb->cb;
+         if (NULL != entry)
+         {
+            iRet = get_usb_interface_from_device (entry->dev, pb_usb_interface);
+         }
+      } // (NULL != skb)
+   } // (NULL != pURB) && (NULL!=pb_usb_interface)
+   return iRet;
+}
+
+// unlink pending rx/tx; completion handlers do all other cleanup
+
+static int unlink_urbs (struct usbnet *dev, struct sk_buff_head *q)
+{
+   unsigned long      flags;
+   struct sk_buff      *skb;
+   int         count = 0;
+
+   spin_lock_irqsave (&q->lock, flags);
+   while (!skb_queue_empty(q)) {
+      struct skb_data      *entry;
+      struct urb      *urb;
+      int         retval;
+
+      skb_queue_walk(q, skb) {
+         entry = (struct skb_data *) skb->cb;
+         if (entry->state != unlink_start)
+            goto found;
+      }
+      break;
+found:
+      entry->state = unlink_start;
+      urb = entry->urb;
+
+      /*
+       * Get reference count of the URB to avoid it to be
+       * freed during usb_unlink_urb, which may trigger
+       * use-after-free problem inside usb_unlink_urb since
+       * usb_unlink_urb is always racing with .complete
+       * handler(include defer_bh).
+       */
+      usb_get_urb(urb);
+      spin_unlock_irqrestore(&q->lock, flags);
+      // during some PM-driven resume scenarios,
+      // these (async) unlinks complete immediately
+      retval = usb_unlink_urb (urb);
+      if (retval != -EINPROGRESS && retval != 0)
+         netdev_dbg(dev->net, "unlink urb err, %d\n", retval);
+      else
+         count++;
+      usb_put_urb(urb);
+      spin_lock_irqsave(&q->lock, flags);
+   }
+   spin_unlock_irqrestore (&q->lock, flags);
+   return count;
+}
+
+
+void gobi_usbnet_tx_timeout_4_4_xx (struct net_device *net)
+{
+   struct usbnet      *dev = netdev_priv(net);
+#ifdef TX_URB_MONITOR
+   int count = 0;   
+   int iRet = -1;
+   unsigned char b_usb_if_num = 0;
+   // Get the USB interface
+   iRet = get_usb_interface_from_device (dev, &b_usb_if_num);   
+
+   count = unlink_urbs (dev, &dev->txq);
+   tasklet_schedule (&dev->bh);
+
+   if ((URB_monitor) && (0==iRet))
+   {
+       while (count)
+      {
+         URB_monitor(false, b_usb_if_num);
+         count--;
+      }
+   }
+#else // TX_URB_MONITOR
+   unlink_urbs (dev, &dev->txq);
+   tasklet_schedule (&dev->bh);
+#endif // TX_URB_MONITOR
+   // FIXME: device recovery -- reset?
+}
+
+/* some LK 2.4 HCDs oopsed if we freed or resubmitted urbs from
+ * completion callbacks.  2.5 should have fixed those bugs...
+ */
+
+static enum skb_state defer_bh(struct usbnet *dev, struct sk_buff *skb,
+      struct sk_buff_head *list, enum skb_state state)
+{
+   unsigned long      flags;
+   enum skb_state       old_state;
+   struct skb_data *entry = (struct skb_data *) skb->cb;
+
+   spin_lock_irqsave(&list->lock, flags);
+   old_state = entry->state;
+   entry->state = state;
+   __skb_unlink(skb, list);
+   spin_unlock(&list->lock);
+   spin_lock(&dev->done.lock);
+   __skb_queue_tail(&dev->done, skb);
+   if (dev->done.qlen == 1)
+      tasklet_schedule(&dev->bh);
+   spin_unlock_irqrestore(&dev->done.lock, flags);
+   return old_state;
+}
+
+static void tx_complete (struct urb *urb)
+{
+   struct sk_buff      *skb = (struct sk_buff *) urb->context;
+   struct skb_data      *entry = (struct skb_data *) skb->cb;
+   struct usbnet      *dev = entry->dev;
+
+#ifdef TX_URB_MONITOR
+   unsigned char b_usb_if_num = 0;
+    int iRet = get_usb_interface(urb, &b_usb_if_num);
+#endif //#ifdef TX_URB_MONITOR
+
+   if (urb->status == 0) {
+      if (!(dev->driver_info->flags & FLAG_MULTI_PACKET))
+         dev->net->stats.tx_packets++;
+      dev->net->stats.tx_bytes += entry->length;
+   } else {
+      dev->net->stats.tx_errors++;
+
+      switch (urb->status) {
+      case -EPIPE:
+         usbnet_defer_kevent (dev, EVENT_TX_HALT);
+         break;
+
+      /* software-driven interface shutdown */
+      case -ECONNRESET:      // async unlink
+      case -ESHUTDOWN:      // hardware gone
+         break;
+
+      // like rx, tx gets controller i/o faults during khubd delays
+      // and so it uses the same throttling mechanism.
+      case -EPROTO:
+      case -ETIME:
+      case -EILSEQ:
+         usb_mark_last_busy(dev->udev);
+         if (!timer_pending (&dev->delay)) {
+            mod_timer (&dev->delay,
+               jiffies + THROTTLE_JIFFIES);
+            netif_dbg(dev, link, dev->net,
+                 "tx throttle %d\n", urb->status);
+         }
+         netif_stop_queue (dev->net);
+         break;
+      default:
+         netif_dbg(dev, tx_err, dev->net,
+              "tx err %d\n", entry->urb->status);
+         break;
+      }
+   }
+
+   gobi_usb_autopm_put_interface_async(dev->intf);
+   (void) defer_bh(dev, skb, &dev->txq, tx_done);
+
+#ifdef TX_URB_MONITOR
+   if ((URB_monitor) && (0==iRet))
+   {
+      URB_monitor(false, b_usb_if_num);
+   }
+#endif //#ifdef TX_URB_MONITOR
+
+}
+
+static int build_dma_sg(const struct sk_buff *skb, struct urb *urb)
+{
+   unsigned num_sgs, total_len = 0;
+   int i, s = 0;
+
+   num_sgs = skb_shinfo(skb)->nr_frags + 1;
+   if (num_sgs == 1)
+      return 0;
+
+   /* reserve one for zero packet */
+   urb->sg = kmalloc((num_sgs + 1) * sizeof(struct scatterlist),
+                    GFP_ATOMIC);
+   if (!urb->sg)
+      return -ENOMEM;
+
+   urb->num_sgs = num_sgs;
+   sg_init_table(urb->sg, urb->num_sgs);
+
+   sg_set_buf(&urb->sg[s++], skb->data, skb_headlen(skb));
+   total_len += skb_headlen(skb);
+
+   for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+      struct skb_frag_struct *f = &skb_shinfo(skb)->frags[i];
+
+      total_len += skb_frag_size(f);
+      sg_set_page(&urb->sg[i + s], f->page.p, f->size,
+                    f->page_offset);
+   }
+   urb->transfer_buffer_length = total_len;
+
+   return 1;
+}
+
+
+/* The caller must hold list->lock */ 
+static void __usbnet_queue_skb(struct sk_buff_head *list,
+                                struct sk_buff *newsk, enum skb_state state)
+{
+   struct skb_data *entry = (struct skb_data *) newsk->cb;
+
+   __skb_queue_tail(list, newsk);
+   entry->state = state;
+}
+
+netdev_tx_t gobi_usbnet_start_xmit_4_4_xx (struct sk_buff *skb,
+                 struct net_device *net)
+{
+   struct usbnet           *dev = netdev_priv(net);
+   int                     length;
+   struct urb              *urb = NULL;
+   struct skb_data         *entry;
+   struct driver_info      *info = dev->driver_info;
+   unsigned long           flags;
+   int retval;
+#ifdef TX_URB_MONITOR
+unsigned char        b_usb_if_num = 0;
+int iRet = -1;
+#endif //#ifdef TX_URB_MONITOR
+
+   if (skb)
+      skb_tx_timestamp(skb);
+
+   // some devices want funky USB-level framing, for
+   // win32 driver (usually) and/or hardware quirks
+   if (info->tx_fixup) {
+         skb = info->tx_fixup (dev, skb, GFP_ATOMIC);
+         if (!skb) {
+                 /* packet collected; minidriver waiting for more */
+                 if (info->flags & FLAG_MULTI_PACKET)
+                         goto not_drop;
+                 netif_dbg(dev, tx_err, dev->net, "can't tx_fixup skb\n");
+                 goto drop;
+         }
+   }
+
+   if (!(urb = usb_alloc_urb (0, GFP_ATOMIC))) {
+         netif_dbg(dev, tx_err, dev->net, "no urb\n");
+         goto drop;
+   }
+
+   entry = (struct skb_data *) skb->cb;
+   entry->urb = urb;
+   entry->dev = dev;
+
+   usb_fill_bulk_urb (urb, dev->udev, dev->out,
+                 skb->data, skb->len, tx_complete, skb);
+
+   if (dev->can_dma_sg) {
+         if (build_dma_sg(skb, urb) < 0)
+                 goto drop;
+   }
+   length = urb->transfer_buffer_length;
+
+   /* don't assume the hardware handles USB_ZERO_PACKET
+     * NOTE:  strictly conforming cdc-ether devices should expect
+     * the ZLP here, but ignore the one-byte packet.
+     * NOTE2: CDC NCM specification is different from CDC ECM when
+     * handling ZLP/short packets, so cdc_ncm driver will make short
+     * packet itself if needed.
+     */
+   if (length % dev->maxpacket == 0) {
+         if (!(info->flags & FLAG_SEND_ZLP)) {
+                 if (!(info->flags & FLAG_MULTI_PACKET)) {
+                         length++;
+                         if (skb_tailroom(skb) && !urb->num_sgs) {
+                                 skb->data[skb->len] = 0;
+                                 __skb_put(skb, 1);
+                         } else if (urb->num_sgs)
+                                 sg_set_buf(&urb->sg[urb->num_sgs++],
+                                                 dev->padding_pkt, 1);
+                 }
+         } else
+                 urb->transfer_flags |= URB_ZERO_PACKET;
+   }
+   entry->length = urb->transfer_buffer_length = length;
+
+   spin_lock_irqsave(&dev->txq.lock, flags);
+   retval = gobi_usb_autopm_get_interface_async(dev->intf);
+   if (retval < 0) {
+         spin_unlock_irqrestore(&dev->txq.lock, flags);
+         goto drop;
+   }
+
+#ifdef CONFIG_PM
+   /* if this triggers the device is still a sleep */
+   if (test_bit(EVENT_DEV_ASLEEP, &dev->flags)) 
+   {
+      /* transmission will be done in resume */
+      usb_anchor_urb(urb, &dev->deferred);
+      /* no use to process more packets */
+      netif_stop_queue(net);
+      usb_put_urb(urb);
+      spin_unlock_irqrestore(&dev->txq.lock, flags);
+      netdev_dbg(dev->net, "Delaying transmission for resumption\n");
+      goto deferred;
+   }
+#endif
+   #ifdef TX_URB_MONITOR
+   iRet = get_usb_interface(urb, &b_usb_if_num);
+   #endif //#ifdef TX_URB_MONITOR
+   switch ((retval = usb_submit_urb (urb, GFP_ATOMIC))) 
+   {
+   case -EPIPE:
+         netif_stop_queue (net);
+         usbnet_defer_kevent (dev, EVENT_TX_HALT);
+         gobi_usb_autopm_put_interface_async(dev->intf);
+         break;
+   default:
+         gobi_usb_autopm_put_interface_async(dev->intf);
+         netif_dbg(dev, tx_err, dev->net,
+                   "tx: submit urb err %d\n", retval);
+         break;
+   case 0:
+         net->trans_start = jiffies;
+         __usbnet_queue_skb(&dev->txq, skb, tx_start);
+         if (dev->txq.qlen >= TX_QLEN (dev))
+                 netif_stop_queue (net);
+   }
+
+#ifdef TX_URB_MONITOR
+/*
+ * This can be called from here or from inside the
+ * case 0 in the above switch. There will be one less
+ * condition to check
+ */
+/*
+ * Call URB_monitor() with true as the URB has been successfully 
+ * submitted to the txq. 
+ */
+if ((0==iRet) && (0==retval))//(URB_monitor) && 
+{
+   URB_monitor(true, b_usb_if_num);
+}
+#endif //#ifdef TX_URB_MONITOR
+
+   spin_unlock_irqrestore (&dev->txq.lock, flags);
+
+   if (retval) {
+      netif_dbg(dev, tx_err, dev->net, "drop, code %d\n", retval);
+drop:
+   dev->net->stats.tx_dropped++;
+not_drop:
+   if (skb)
+      dev_kfree_skb_any (skb);
+      if (urb) 
+      {
+         kfree(urb->sg);
+         usb_free_urb(urb);
+      }
+   } else
+      netif_dbg(dev, tx_queued, dev->net,
+      "> tx, len %d, type 0x%x\n", length, skb->protocol);
+#ifdef CONFIG_PM
+deferred:
+#endif
+   return NETDEV_TX_OK;
+}
+
+#endif 
+/********* 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 4,4,0 ) &&\
+               LINUX_VERSION_CODE < KERNEL_VERSION( 4,5,0))
+               
+***********/
+
+
+
+
diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c
index 55a8fb25..9cbb7f36 100644
--- a/drivers/usb/serial/qcserial.c
+++ b/drivers/usb/serial/qcserial.c
@@ -142,7 +142,6 @@ static const struct usb_device_id id_table[] = {
 	{USB_DEVICE(0x0AF0, 0x8120)},	/* Option GTM681W */
 
 	/* non-Gobi Sierra Wireless devices */
-	{DEVICE_SWI(0x03f0, 0x4e1d)},	/* HP lt4111 LTE/EV-DO/HSPA+ Gobi 4G Module */
 	{DEVICE_SWI(0x0f3d, 0x68a2)},	/* Sierra Wireless MC7700 */
 	{DEVICE_SWI(0x114f, 0x68a2)},	/* Sierra Wireless MC7750 */
 	{DEVICE_SWI(0x1199, 0x68a2)},	/* Sierra Wireless MC7710 */
@@ -182,7 +181,11 @@ static const struct usb_device_id id_table[] = {
 	{DEVICE_SWI(0x413c, 0x81d1)},   /* Dell Wireless 5818 */
 	{DEVICE_SWI(0x413c, 0x81d2)},   /* Dell Wireless 5818 */
 
+	{USB_DEVICE(0x03f0, 0x4e1d), .driver_info = 0xffffffff },
+	// {DEVICE_G1K(0x03f0, 0x4e1d)},	/* TEST */
+	// {DEVICE_SWI(0x03f0, 0x4e1d)},	/* HP lt4111 LTE/EV-DO/HSPA+ Gobi 4G Module */
 	/* Huawei devices */
+	// {DEVICE_HWI(0x03f0, 0x4e1d)},	/* HP lt4111 LTE/HSPA+ Gobi 4G Modem (Huawei me9715) */
 	{DEVICE_HWI(0x03f0, 0x581d)},	/* HP lt4112 LTE/HSPA+ Gobi 4G Modem (Huawei me906e) */
 
 	{ }				/* Terminating entry */
@@ -232,8 +235,10 @@ static int qcprobe(struct usb_serial *serial, const struct usb_device_id *id)
 	bool sendsetup = false;
 
 	/* we only support vendor specific functions */
-	if (intf->desc.bInterfaceClass != USB_CLASS_VENDOR_SPEC)
+	if (intf->desc.bInterfaceClass != USB_CLASS_VENDOR_SPEC) {
+		printk("%s: faild: %d", __func__, intf->desc.bInterfaceClass);
 		goto done;
+	}
 
 	nintf = serial->dev->actconfig->desc.bNumInterfaces;
 	dev_dbg(dev, "Num Interfaces = %d\n", nintf);
-- 
2.20.1

