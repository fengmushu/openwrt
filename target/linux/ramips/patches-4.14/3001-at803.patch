diff --git a/drivers/net/ethernet/mediatek/Kconfig b/drivers/net/ethernet/mediatek/Kconfig
index 43656f961891..2bc33d5038e5 100644
--- a/drivers/net/ethernet/mediatek/Kconfig
+++ b/drivers/net/ethernet/mediatek/Kconfig
@@ -10,6 +10,7 @@ config NET_MEDIATEK_SOC
 	tristate "MediaTek SoC Gigabit Ethernet support"
 	depends on NET_VENDOR_MEDIATEK
 	select PHYLIB
+	select PHYLINK
 	---help---
 	  This driver supports the gigabit ethernet MACs in the
 	  MediaTek SoC family.
diff --git a/drivers/net/phy/at803x.c b/drivers/net/phy/at803x.c
index dedf4b190f39..4ee7e6c7f9e6 100644
--- a/drivers/net/phy/at803x.c
+++ b/drivers/net/phy/at803x.c
@@ -11,6 +11,7 @@
  * option) any later version.
  */
 
+#include <linux/ethtool.h>
 #include <linux/phy.h>
 #include <linux/mdio.h>
 #include <linux/module.h>
@@ -58,6 +59,11 @@
 
 #define AT803X_MODE_CFG_MASK			0x0F
 #define AT803X_MODE_CFG_SGMII			0x01
+#define AT803X_MODE_CFG_BX1000_RGMII_50		0x02
+#define AT803X_MODE_CFG_BX1000_RGMII_75		0x03
+#define AT803X_MODE_FIBER			0x01
+#define AT803X_MODE_COPPER			0x00
+
 
 #define AT803X_PSSR			0x11	/*PHY-Specific Status Register*/
 #define AT803X_PSSR_MR_AN_COMPLETE	0x0200
@@ -79,6 +85,16 @@ MODULE_DESCRIPTION("Atheros 803x PHY driver");
 MODULE_AUTHOR("Matus Ujhelyi");
 MODULE_LICENSE("GPL");
 
+struct at803x_phy_hw_stat {
+	const char *string;
+	u8 reg;
+	u8 bits;
+};
+
+static struct at803x_phy_hw_stat at803x_hw_stats[] = {
+	{ "phy_idle_errors", 10, 8 },
+};
+
 struct at803x_priv {
 	bool phy_reset:1;
 	struct gpio_desc *gpiod_reset;
@@ -94,6 +110,40 @@ struct at803x_context {
 	u16 led_control;
 };
 
+static int at803x_phy_get_sset_count(struct phy_device *phydev)
+{
+	return ARRAY_SIZE(at803x_hw_stats);
+}
+
+static void at803x_phy_get_strings(struct phy_device *phydev, u8 *data)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(at803x_hw_stats); i++)
+		memcpy(data + i * ETH_GSTRING_LEN,
+		       at803x_hw_stats[i].string, ETH_GSTRING_LEN);
+}
+
+static void at803x_phy_get_stats(struct phy_device *phydev,
+		       struct ethtool_stats *stats, u64 *data)
+{
+	unsigned int i;
+	int val;
+	struct at803x_phy_hw_stat stat;
+	u64 ret;
+
+	for (i = 0; i < ARRAY_SIZE(at803x_hw_stats); i++) {
+		stat = at803x_hw_stats[i];
+		val = phy_read(phydev, stat.reg);
+		if (val < 0) {
+			ret = U64_MAX;
+		} else {
+			ret = val & ((1 << stat.bits) - 1);
+		}
+		data[i] = ret;
+	}
+}
+
 static int at803x_debug_reg_read(struct phy_device *phydev, u16 reg)
 {
 	int ret;
@@ -124,12 +174,14 @@ static int at803x_debug_reg_mask(struct phy_device *phydev, u16 reg,
 
 static inline int at803x_enable_rx_delay(struct phy_device *phydev)
 {
+	pr_warn("at803x_enable_rx_delay\n");
 	return at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_0, 0,
 					AT803X_DEBUG_RX_CLK_DLY_EN);
 }
 
 static inline int at803x_enable_tx_delay(struct phy_device *phydev)
 {
+	pr_warn("at803x_enable_tx_delay\n");
 	return at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_5, 0,
 					AT803X_DEBUG_TX_CLK_DLY_EN);
 }
@@ -263,6 +315,8 @@ static int at803x_probe(struct phy_device *phydev)
 	struct at803x_priv *priv;
 	struct gpio_desc *gpiod_reset;
 
+	printk("at803x_probe\n");
+
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
@@ -290,14 +344,27 @@ static void at803x_disable_smarteee(struct phy_device *phydev)
 	phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV, 0);
 }
 
+static int at803x_mode(struct phy_device *phydev)
+{
+	int mode;
+
+	mode = phy_read(phydev, AT803X_REG_CHIP_CONFIG) & AT803X_MODE_CFG_MASK;
+
+	if (mode == AT803X_MODE_CFG_BX1000_RGMII_50 ||
+	    mode == AT803X_MODE_CFG_BX1000_RGMII_75)
+		return AT803X_MODE_FIBER;
+	return AT803X_MODE_COPPER;
+}
+
 static int at803x_config_init(struct phy_device *phydev)
 {
 	struct at803x_platform_data *pdata;
 	int ret;
 	u32 v;
 
-	if (phydev->drv->phy_id == ATH8031_PHY_ID &&
-		phydev->interface == PHY_INTERFACE_MODE_SGMII)
+	if ( (phydev->drv->phy_id == ATH8031_PHY_ID &&
+		phydev->interface == PHY_INTERFACE_MODE_SGMII) ||
+		(at803x_mode(phydev) == AT803X_MODE_FIBER) )
 	{
 		v = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
 		/* select SGMII/fiber page */
@@ -403,6 +470,8 @@ static void at803x_link_change_notify(struct phy_device *phydev)
 	u8 fixup_rgmii_tx_delay = 0;
 	pdata = dev_get_platdata(&phydev->mdio.dev);
 
+	pr_warn("at803x_link_change_notify\n");
+
 	/*
 	 * Conduct a hardware reset for AT8030/2 every time a link loss is
 	 * signalled. This is necessary to circumvent a hardware bug that
@@ -461,11 +530,108 @@ static void at803x_link_change_notify(struct phy_device *phydev)
 	}
 }
 
+
+static int at803x_read_status(struct phy_device *phydev) {
+	int ccr, ret;
+	int pssr;
+
+	ccr = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
+
+	/* Handle (Fiber) SGMII to RGMII mode */
+	if (at803x_mode(phydev) == AT803X_MODE_FIBER) {
+
+		/* select SGMII/fiber page */
+		ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG,
+						ccr & ~AT803X_BT_BX_REG_SEL);
+		if (ret)
+			return ret;
+
+		/* check if the SGMII link is OK. */
+		pssr = phy_read(phydev, AT803X_PSSR);
+
+		// pr_warn("803x_read_status: %x\n", pssr);
+
+		if (pssr < 0)
+		    return pssr;
+
+		/* select Copper page */
+		
+		ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG,
+						ccr | AT803X_BT_BX_REG_SEL);
+		if (ret)
+			return ret;
+		
+#define		PSSR_LINK      BIT(10)
+#define		PSSR_SYNC_STATUS      BIT(8)
+
+		if (pssr & PSSR_LINK)
+			phydev->link = 1;
+	        else
+			phydev->link = 0;
+
+		if (!(pssr & PSSR_SYNC_STATUS))
+			pr_warn("at803x_pssr: No SYNC: %4x\n", pssr);
+
+	  	phydev->duplex = DUPLEX_FULL;
+		phydev->speed  = SPEED_1000;
+
+		phydev->lp_advertising = ADVERTISED_1000baseT_Full;
+		phydev->supported = ADVERTISED_1000baseT_Full;
+
+		phydev->pause = 0;
+		phydev->asym_pause = 0;
+		return 0;
+	} else {
+	    return genphy_read_status(phydev);
+	}
+}
+
+static int at803x_config_aneg(struct phy_device *phydev)
+{
+    	pr_warn("at803x_config_aneg: enter\n");
+    	//return genphy_config_aneg(phydev);
+	return 0;
+}
+
+
+
 static int at803x_aneg_done(struct phy_device *phydev)
 {
-	int ccr;
+	int ccr, ret;
+	int aneg_done;
+
+	pr_warn("803x_aneg_done: enter\n");
+
+	if (at803x_mode(phydev) == AT803X_MODE_FIBER) {
 
-	int aneg_done = genphy_aneg_done(phydev);
+		aneg_done = BMSR_ANEGCOMPLETE;
+
+		ccr = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
+	
+		/* select SGMII/fiber page */
+		ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG,
+						ccr & ~AT803X_BT_BX_REG_SEL);
+		if (ret)
+			return ret;
+
+		/* check if the SGMII link is OK. */
+		if (!(phy_read(phydev, AT803X_PSSR) & AT803X_PSSR_MR_AN_COMPLETE)) {
+			pr_warn("803x_aneg_done: SGMII link is not ok\n");
+			aneg_done = 0;
+		}
+
+
+		/* select Copper page */
+		ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG,
+						ccr | AT803X_BT_BX_REG_SEL);
+		if (ret)
+			return ret;
+
+
+		return aneg_done;
+	}
+
+	aneg_done = genphy_aneg_done(phydev);
 	if (aneg_done != BMSR_ANEGCOMPLETE)
 		return aneg_done;
 
@@ -540,11 +706,15 @@ static struct phy_driver at803x_driver[] = {
 	.resume			= at803x_resume,
 	.features		= PHY_GBIT_FEATURES,
 	.flags			= PHY_HAS_INTERRUPT,
-	.config_aneg		= genphy_config_aneg,
-	.read_status		= genphy_read_status,
+	.config_aneg		= at803x_config_aneg,
+	.read_status		= at803x_read_status,
 	.aneg_done		= at803x_aneg_done,
-	.ack_interrupt		= &at803x_ack_interrupt,
-	.config_intr		= &at803x_config_intr,
+	.ack_interrupt		= at803x_ack_interrupt,
+	.config_intr		= at803x_config_intr,
+	.set_loopback		= genphy_loopback,
+	.get_sset_count		= at803x_phy_get_sset_count,
+	.get_strings		= at803x_phy_get_strings,
+	.get_stats		= at803x_phy_get_stats,
 }, {
 	/* ATHEROS 8032 */
 	.phy_id			= ATH8032_PHY_ID,
